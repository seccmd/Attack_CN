{
    "Process Injection": {
        "translated_name": "プロセスインジェクション",
        "translated_description": "敵対者は、プロセスベースの防御を回避したり、権限を上げるためにコードをプロセスにインジェクトする可能性があります。プロセスインジェクションは別の生存中のプロセスのアドレス空間に任意のコードを実行する方法です。別のプロセスのコンテキストでコードを実行することで、プロセスのメモリー、システム/ネットワークリソース、アクセス権などにアクセス可能になります。プロセスインジェクションによる実行は、セキュリティープロダクトからは隠れることができますし、LEGITIMATEプロセスの下にmaskingすることで検出を回避することができます。\n\n多くの異なる方法でコードをプロセスにインジェクトすることがあります。多くは、LEGITIMATEな機能を悪用して実現されています。この実装は、各主要OSに対応していますが、プラットフォーム固有です。\n\nより洗練されたサンプルでは、複数のプロセスインジェクションを実行し、モジュールをセグメント化し、さらに検出を回避するために名付けられたパイプや他のインタープログレスコミュニケーション（IPC）メカニズムを使用して通信チャネルとして機能します。"
    },
    "Exfiltration Over Webhook": {
        "translated_name": "ウェブホーケンのエクスフィルテーション",
        "translated_description": "以下是翻译后的内容：\n\n攻撃者は、プライマリーのコマンド・アンド・コントロールチャネルではなく、ウェブフックエンドポイントにデータを漏出することがあります。ウェブフックは、サーバーがHTTP/Ｓでクライアントにデータをプッシュする簡単なメカニズムです。（Citation: RedHat Webhooks）多くのパブリック・アンド・コマーシャルサービス、例えばDiscord、Slack、`webhook. site`などは、他のサービス（例えばGitHub、Jira、Trelloなど）が使用するウェブフックエンドポイントを作成できるようにサポートしています。（Citation: Discord Intro to Webhooks）リンクされたサービスで起こる変更（例えばリポジトリの更新やチケットの修正）に対して、これらのサービスは自動的にデータをウェブフックエンドポイントに投稿し、消費アプリケーションに使用するためです。\n\n攻撃者は、自主環境を被害者の所有SaaSサービスのリンクで、自動的な[Automated Exfiltration](https://attack. mitre. org/techniques/T1020)のためのメール、チャットメッセージその他のデータの漏出を実現することがあります。（Citation: Push Security SaaS Attacks Repository Webhooks）代わりに、ウェブフックエンドポイントにサービスをリンクするのではなく、ステージされたデータを手動でURLに投稿し、漏出することもできます。（Citation: Microsoft SQL Server）\n\nウェブフックエンドポイントアクセスは、しばしばHTTPS経由で行われます。これにより、アドバーサリーには追加のレベルの保護が提供されます。ウェブフックを使用した漏出も、一般に使われているSaaSアプリケーションや協力サービスにポイントすることで、通常のネットワークトラフィックに溶け込むことができます。（Citation: CyberArk Labs Discord）（Citation: Talos Discord Webhook Abuse）（Citation: Checkmarx Webhooks）"
    },
    "COR_PROFILER": {
        "translated_name": "コーポファイラー (Kōropofirā)",
        "translated_description": "以下是翻译后的内容：\n\nアドバーサリーは、COR_プロファイラー環境変数を使用して、 .NET CLR をロードするプログラムの実行フローを乗っ取ります。COR_プロファイラーは、.NET フレームワークの機能で、開発者が指定するアンマネージ（.NET 外部）プロファイラー DLL を各 .NET プロセスにロードします。これらのプロファイラは、.NET CLR によって実行されるマネージド コードをモニターし、トラブルシューティングし、デバッグするために設計されています。(引用：Microsoft Profiling 2017)(引用：Microsoft COR_PROFILER 2013)\n\nCOR_プロファイラー環境変数は、システム、ユーザーあるいはプロセス スコープで設定できるため、影響の度合が異なる結果になる。システムやユーザー範囲での環境変数スコープはレジストリーに指定されており、[Component Object Model](https://attack.mitre.org/techniques/T1559/001)（COM）オブジェクトをプロファイラー DLL として登録することができます。プロセス スコープの COR_PROFILER はまたレジストリーを変更せずにインメモリーで作成することもできます。.NET フレームワーク 4 以降では、プロファイラー DLL が登録される必要がありませんが、COR_プロファイラー _PATH 環境変数に DLL の位置を指定することにより実現することができます。(引用：Microsoft COR_PROFILER 2013)\n\nアドバーサリーは、COR_プロファイラー を悪用して、.NET プロセスすべてで悪意の DLL を実行し、CLR が呼び出されるたびに持続性を確立することができます。COR_プロファイラー はまた権限を上げる（例えば [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)）もしくは .NET プロセスが高い許可レベルで実行している場合には、権限を上げることができます。また COR_プロファイラー を使用して .NET プロセスの防御機能をhook し、[Impair Defenses](https://attack.mitre.org/techniques/T1562) を抑制することもできます。(引用：RedCanary Mockingbird 2020)(引用：Red Canary COR_PROFILER 2020)(引用：Almond COR_PROFILER 2019)(引用：GitHub OmerYa Invisi-Shell)(引用：subTee .NET Profilers 2017)"
    }
}