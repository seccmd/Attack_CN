---
hide:
  - toc
---

# 持久性

攻击者试图保持对目标系统的访问。

### 技术： 120

| 编号 | 名字 | 描述 |
| --- | --- | --- |
| [T1037](../techniques/T1037.md) | 启动或登录初始化脚本 | 对手可能会使用在启动或登录初始化时自动执行的脚本来建立持久性。(引用: Mandiant APT29 Eye Spy Email Nov 22)(引用: Anomali Rocke March 2019) 初始化脚本可用于执行管理功能，通常可以执行其他程序或将信息发送到内部日志服务器。这些脚本可能因操作系统和本地或远程应用而异。  对手可能会使用这些脚本在单个系统上保持持久性。根据登录脚本的访问配置，可能需要本地凭据或管理员帐户。  对手还可能能够提升其权限，因为某些启动或登录初始化脚本以更高的权限运行。 |
| [T1037.001](../techniques/T1037.001.md) | 登录脚本（Windows） | 攻击者可能使用在登录初始化时自动执行的Windows登录脚本来建立持久性。Windows允许在特定用户或用户组登录系统时运行登录脚本。(引用: TechNet登录脚本) 这是通过将脚本路径添加到<code>HKCU\Environment\UserInitMprLogonScript</code>注册表项来完成的。(引用: Hexacorn登录脚本)  攻击者可能使用这些脚本在单个系统上保持持久性。根据登录脚本的访问配置，可能需要本地凭据或管理员帐户。 |
| [T1037.002](../techniques/T1037.002.md) | 登录钩子 | 对手可能会使用登录钩子在用户登录时执行以建立持久性。登录钩子是一个plist文件，指向一个特定的脚本，在用户登录时以root权限执行。plist文件位于<code>/Library/Preferences/com.apple.loginwindow.plist</code>文件中，可以使用<code>defaults</code>命令行实用程序进行修改。注销钩子的行为相同，其中脚本可以在用户注销时执行。所有钩子都需要管理员权限才能修改或创建钩子。(引用: Login Scripts Apple Dev)(引用: LoginWindowScripts Apple Dev)  对手可以在<code>com.apple.loginwindow.plist</code>文件中添加或插入指向恶意脚本的路径，使用<code>LoginHook</code>或<code>LogoutHook</code>键值对。恶意脚本将在下次用户登录时执行。如果已经存在登录钩子，对手可以向现有登录钩子添加额外的命令。系统一次只能有一个登录和注销钩子。(引用: S1 macOs Persistence)(引用: Wardle Persistence Chapter)  **注意：** 登录钩子在macOS 10.11版本中被弃用，取而代之的是[启动守护程序](https://attack.mitre.org/techniques/T1543/004)和[启动代理](https://attack.mitre.org/techniques/T1543/001) |
| [T1037.003](../techniques/T1037.003.md) | 网络登录脚本 | 对手可能会使用在登录初始化时自动执行的网络登录脚本来建立持久性。网络登录脚本可以使用Active Directory或组策略对象分配。(引用: Petri Logon Script AD) 这些登录脚本以分配给它们的用户的权限运行。根据网络中的系统，初始化这些脚本可能适用于一个或多个甚至所有系统。  对手可能会使用这些脚本在网络上保持持久性。根据登录脚本的访问配置，可能需要本地凭据或管理员账户。 |
| [T1037.004](../techniques/T1037.004.md) | RC脚本 | 对手可能通过修改在类Unix系统启动期间执行的RC脚本来建立持久性。这些文件允许系统管理员在不同运行级别启动自定义服务。修改RC脚本需要root权限。  对手可以通过将恶意二进制路径或shell命令添加到<code>rc.local</code>、<code>rc.common</code>和其他特定于类Unix发行版的RC脚本来建立持久性。(引用: IranThreats Kittens Dec 2017)(引用: Intezer HiddenWasp Map 2019) 重启后，系统以root身份执行脚本的内容，从而实现持久性。  对手滥用RC脚本在默认使用root用户的轻量级类Unix发行版（如IoT或嵌入式系统）中特别有效。(引用: intezer-kaiji-malware)  一些类Unix系统已经迁移到Systemd并弃用了RC脚本。在macOS中，这是一种弃用的机制，取而代之的是[Launchd](https://attack.mitre.org/techniques/T1053/004)。(引用: Apple Developer Doco Archive Launchd)(引用: Startup Items) 此技术可用于Mac OS X Panther v10.3及更早版本，这些版本仍然执行RC脚本。(引用: Methods of Mac Malware Persistence) 为了保持向后兼容性，一些系统（如Ubuntu）将在存在正确文件权限的情况下执行RC脚本。(引用: Ubuntu Manpage systemd rc) |
| [T1037.005](../techniques/T1037.005.md) | 启动项 | 对手可能会使用在启动初始化时自动执行的启动项来建立持久性。启动项在启动过程的最后阶段执行，包含shell脚本或其他可执行文件以及系统用于确定所有启动项执行顺序的配置信息。(引用: Startup Items)  这在技术上是一种已弃用的技术（被[启动守护程序](https://attack.mitre.org/techniques/T1543/004)取代），因此适当的文件夹<code>/Library/StartupItems</code>默认情况下可能不存在于系统上，但在macOS Sierra上默认存在。启动项是一个目录，其可执行文件和配置属性列表（plist），<code>StartupParameters.plist</code>，位于顶级目录中。  对手可以在StartupItems目录中创建适当的文件夹/文件来注册他们自己的持久性机制。(引用: Methods of Mac Malware Persistence) 此外，由于启动项在macOS的启动阶段运行，它们将以提升的root用户身份运行。 |
| [T1053](../techniques/T1053.md) | 计划任务/作业 | 对手可能会滥用任务调度功能来促进恶意代码的初始或定期执行。所有主要操作系统中都存在用于在指定日期和时间执行程序或脚本的实用程序。只要满足适当的身份验证要求（例如：Windows 环境中的 RPC 和文件及打印机共享），也可以在远程系统上调度任务。在远程系统上调度任务通常可能需要成为远程系统上管理员或其他特权组的成员。(引用: TechNet Task Scheduler Security)  对手可能会使用任务调度在系统启动时或定期执行程序以实现持久性。这些机制也可以被滥用以在指定账户（例如具有提升权限/特权的账户）的上下文中运行进程。类似于[系统二进制代理执行](https://attack.mitre.org/techniques/T1218)，对手还滥用任务调度来潜在地掩盖受信任系统进程下的一次性执行。(引用: ProofPoint Serpent) |
| [T1053.002](../techniques/T1053.002.md) | At | 攻击者可能滥用[at](https://attack.mitre.org/software/S0110)实用程序来执行任务调度，以初始或重复执行恶意代码。[at](https://attack.mitre.org/software/S0110)实用程序作为Windows、Linux和macOS中的可执行文件存在，用于在指定的时间和日期调度任务。尽管在Windows环境中已弃用，转而使用[计划任务](https://attack.mitre.org/techniques/T1053/005)的[schtasks](https://attack.mitre.org/software/S0111)，但使用[at](https://attack.mitre.org/software/S0110)需要任务调度程序服务正在运行，并且用户必须以本地管理员组成员的身份登录。除了显式运行`at`命令外，攻击者还可以通过直接利用[Windows管理工具](https://attack.mitre.org/techniques/T1047) `Win32_ScheduledJob` WMI类来调度任务。(Citation: Malicious Life by Cybereason)  在Linux和macOS上，超级用户以及添加到<code>at.allow</code>文件中的任何用户都可以调用[at](https://attack.mitre.org/software/S0110)。如果<code>at.allow</code>文件不存在，则检查<code>at.deny</code>文件。未列在<code>at.deny</code>中的每个用户名都允许调用[at](https://attack.mitre.org/software/S0110)。如果<code>at.deny</code>存在且为空，则允许全局使用[at](https://attack.mitre.org/software/S0110)。如果两个文件都不存在（通常是基线情况），则只有超级用户可以使用[at](https://attack.mitre.org/software/S0110)。(Citation: Linux at)  攻击者可能使用[at](https://attack.mitre.org/software/S0110)在系统启动时或按计划执行程序以实现[持久性](https://attack.mitre.org/tactics/TA0003)。[at](https://attack.mitre.org/software/S0110)还可用于在[横向移动](https://attack.mitre.org/tactics/TA0008)期间进行远程[执行](https://attack.mitre.org/tactics/TA0002)或在指定账户（如SYSTEM）的上下文中运行进程。  在Linux环境中，攻击者还可能滥用[at](https://attack.mitre.org/software/S0110)通过任务生成交互式系统shell或运行系统命令来突破受限环境。同样，如果二进制文件允许通过<code>sudo</code>以超级用户身份运行，[at](https://attack.mitre.org/software/S0110)也可用于[权限提升](https://attack.mitre.org/tactics/TA0004)。(Citation: GTFObins at) |
| [T1053.003](../techniques/T1053.003.md) | Cron | 对手可能会滥用<code>cron</code>实用程序来执行任务调度，以初始或定期执行恶意代码。(引用: 20 macOS Common Tools and Techniques) <code>cron</code>实用程序是类Unix操作系统的基于时间的作业调度程序。<code>crontab</code>文件包含要运行的cron条目和指定的执行时间。任何<code>crontab</code>文件都存储在特定于操作系统的文件路径中。  对手可能会在Linux或Unix环境中使用<code>cron</code>在系统启动时或定期执行程序以实现[持久性](https://attack.mitre.org/tactics/TA0003)。 |
| [T1053.005](../techniques/T1053.005.md) | 计划任务 | 对手可能会滥用Windows任务计划程序来执行任务调度，以初始或定期执行恶意代码。有多种方法可以访问Windows中的任务计划程序。可以直接在命令行上运行[schtasks](https://attack.mitre.org/software/S0111)实用程序，或者可以通过控制面板中的管理工具部分打开任务计划程序的GUI。(引用: Stack Overflow) 在某些情况下，对手使用了Windows任务计划程序的.NET包装器，或者使用了Windows netapi32库和[Windows管理工具](https://attack.mitre.org/techniques/T1047) (WMI)来创建计划任务。对手还可以利用Powershell Cmdlet `Invoke-CimMethod`，该Cmdlet利用WMI类`PS_ScheduledTask`通过XML路径创建计划任务。(引用: Red Canary - Atomic Red Team)  对手可能会使用Windows任务计划程序在系统启动时或定期执行程序以保持持久性。Windows任务计划程序还可以被滥用以进行远程执行作为横向移动的一部分，或在指定帐户（如SYSTEM）的上下文中运行进程。类似于[系统二进制代理执行](https://attack.mitre.org/techniques/T1218)，对手还滥用了Windows任务计划程序，以便在签名/受信任的系统进程下掩盖一次性执行。(引用: ProofPoint Serpent)  对手还可能创建“隐藏”计划任务（即[隐藏工件](https://attack.mitre.org/techniques/T1564)），这些任务可能对防御工具和用于枚举任务的手动查询不可见。具体来说，对手可能通过删除关联的安全描述符（SD）注册表值（删除此值必须使用SYSTEM权限完成）来隐藏任务。(引用: SigmaHQ)(引用: Tarrask scheduled task) 对手还可能采用其他方法隐藏任务，例如更改关联注册表项中的元数据（例如`Index`值）。(引用: Defending Against Scheduled Task Attacks in Windows Environments) |
| [T1053.006](../techniques/T1053.006.md) | Systemd计时器 | 对手可能滥用systemd计时器来执行任务调度，以初始或定期执行恶意代码。Systemd计时器是文件扩展名为<code>.timer</code>的单元文件，用于控制服务。计时器可以设置为在日历事件或相对于起点的时间跨度后运行。它们可以作为Linux环境中[Cron](https://attack.mitre.org/techniques/T1053/003)的替代品。(引用: archlinux Systemd Timers Aug 2020) Systemd计时器可以通过<code>systemctl</code>命令行实用程序远程激活，该实用程序通过[SSH](https://attack.mitre.org/techniques/T1021/004)操作。(引用: Systemd Remote Control)  每个<code>.timer</code>文件必须有一个对应的<code>.service</code>文件，名称相同，例如<code>example.timer</code>和<code>example.service</code>。<code>.service</code>文件是[Systemd服务](https://attack.mitre.org/techniques/T1543/002)单元文件，由systemd系统和服务管理器管理。(引用: Linux man-pages: systemd January 2014) 特权计时器写入<code>/etc/systemd/system/</code>和<code>/usr/lib/systemd/system</code>，而用户级别的写入<code>~/.config/systemd/user/</code>。  对手可能使用systemd计时器在系统启动时或定期执行恶意代码以实现持久性。(引用: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(引用: gist Arch package compromise 10JUL2018)(引用: acroread package compromised Arch Linux Mail 8JUL2018) 使用特权路径安装的计时器可能用于保持root级别的持久性。对手也可能安装用户级别的计时器以实现用户级别的持久性。(引用: Falcon Sandbox smp: 28553b3a9d) |
| [T1053.007](../techniques/T1053.007.md) | 容器编排任务 | 对手可能会滥用容器编排工具（如 Kubernetes）提供的任务调度功能，来调度部署配置为执行恶意代码的容器。容器编排任务会在特定日期和时间运行这些自动化任务，类似于 Linux 系统上的 cron 任务。这种类型的部署还可以配置为随着时间的推移维护一定数量的容器，从而自动化在集群中保持持久性的过程。  在 Kubernetes 中，可以使用 CronJob 来调度运行一个或多个容器以执行特定任务的 Job。(引用: Kubernetes Jobs)(引用: Kubernetes CronJob) 因此，对手可能会利用 CronJob 来调度部署在集群内各个节点上执行恶意代码的 Job。(引用: Threat Matrix for Kubernetes) |
| [T1078](../techniques/T1078.md) | 有效账户 | 对手可能会获取和滥用现有账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的一种手段。被破坏的凭据可能用于绕过系统内各种资源上的访问控制，甚至可能用于对远程系统和外部可用服务（如 VPN、Outlook Web Access、网络设备和远程桌面）的持久访问。(引用: volexity_0day_sophos_FW) 被破坏的凭据还可能授予对手对特定系统的更高权限或对网络中受限区域的访问权限。对手可能选择不使用恶意软件或工具，而是利用这些凭据提供的合法访问权限，使其存在更难被检测到。  在某些情况下，对手可能会滥用不活跃的账户：例如，那些属于不再是组织成员的个人的账户。使用这些账户可能使对手能够规避检测，因为原账户用户不会在场，无法识别其账户上发生的任何异常活动。(引用: CISA MFA PrintNightmare)  由于本地、域和云账户在系统网络中的权限重叠，对手可能能够跨账户和系统进行横向移动，以达到高水平的访问（即域或企业管理员），从而绕过企业内部设置的访问控制。(引用: TechNet Credential Theft) |
| [T1078.001](../techniques/T1078.001.md) | 默认帐户 | 对手可能会获取和滥用默认帐户的凭据，作为获得初始访问、持久性、权限提升或防御规避的一种手段。默认帐户是内置于操作系统中的帐户，例如 Windows 系统上的来宾或管理员帐户。默认帐户还包括其他类型系统、软件或设备上的默认工厂/提供商设置帐户，包括 AWS 中的 root 用户帐户和 Kubernetes 中的默认服务帐户。（引用：Microsoft 本地帐户 2019 年 2 月）（引用：AWS Root 用户）（引用：Kubernetes 威胁矩阵）  默认帐户不仅限于客户端机器，还包括为设备（如网络设备和计算机应用程序）预设的帐户，无论它们是内部的、开源的还是商业的。安装后未更改的预设用户名和密码组合的设备对组织构成严重威胁，因为它们是对手的容易目标。同样，对手还可能利用公开披露或被盗的 [私钥](https://attack.mitre.org/techniques/T1552/004) 或凭据材料，通过 [远程服务](https://attack.mitre.org/techniques/T1021) 合法连接到远程环境。（引用：Metasploit SSH 模块） |
| [T1078.002](../techniques/T1078.002.md) | 域账户 | 对手可能会获取和滥用域账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的一种手段。(引用: TechNet Credential Theft) 域账户是由Active Directory域服务管理的账户，访问和权限配置在属于该域的系统和服务中。域账户可以覆盖用户、管理员和服务。(引用: Microsoft AD Accounts)  对手可能通过各种手段（如[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)或密码重用）来妥协域账户，其中一些具有高权限，从而访问域的特权资源。 |
| [T1078.003](../techniques/T1078.003.md) | 本地账户 | 对手可能获取和滥用本地账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的手段。本地账户是组织为用户、远程支持、服务或单个系统或服务的管理配置的账户。  本地账户也可能被滥用以提升权限并通过[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)收集凭据。密码重用可能允许在网络上的一组机器上滥用本地账户，以实现权限提升和横向移动。 |
| [T1087.001](../techniques/T1087.001.md) | 本地账户 | 对手可能会创建本地账户以保持对受害者系统的访问。本地账户是由组织配置供用户、远程支持、服务或单个系统或服务的管理使用的账户。  例如，具有足够访问权限的情况下，可以使用 Windows <code>net user /add</code> 命令创建本地账户。在 macOS 系统上，可以使用 <code>dscl -create</code> 命令创建本地账户。本地账户也可以添加到网络设备，通常通过常见的[网络设备 CLI](https://attack.mitre.org/techniques/T1059/008)命令如 <code>username</code>，或使用 `kubectl` 实用程序添加到 Kubernetes 集群。(引用: cisco_username_cmd)(引用: Kubernetes Service Accounts Security)  这些账户可以用于建立不需要在系统上部署持久远程访问工具的次要凭证访问。 |
| [T1087.002](../techniques/T1087.002.md) | 域账户 | 对手可能会创建域账户以保持对受害者系统的访问。域账户是由Active Directory域服务管理的账户，访问和权限配置在属于该域的系统和服务之间。域账户可以涵盖用户、管理员和服务账户。具有足够访问权限的情况下，可以使用<code>net user /add /domain</code>命令创建域账户。(引用: Savill 1999)  这些账户可以用于建立不需要在系统上部署持久远程访问工具的次要凭证访问。 |
| [T1087.004](../techniques/T1087.004.md) | 云账户 | 对手可能会创建云账户以保持对受害者系统的访问。具有足够访问权限的此类账户可用于建立不需要在系统上部署持久远程访问工具的次要凭据访问。(引用: Microsoft O365 Admin Roles)(引用: Microsoft Support O365 Add Another Admin, October 2019)(引用: AWS Create IAM User)(引用: GCP Create Cloud Identity Users)(引用: Microsoft Azure AD Users)  除了用户账户外，云账户还可能与服务相关联。云提供商以不同方式处理服务账户的概念。在Azure中，服务账户包括服务主体和托管身份，可以链接到各种资源，如OAuth应用程序、无服务器函数和虚拟机，以授予这些资源在环境中执行各种活动的权限。(引用: Microsoft Entra ID Service Principals) 在GCP中，服务账户也可以链接到特定资源，并且可以被其他账户模拟以进行[临时提升的云访问](https://attack.mitre.org/techniques/T1548/005)。(引用: GCP Service Accounts) 虽然AWS没有特定的服务账户概念，但资源可以直接授予权限以承担角色。(引用: AWS Instance Profiles)(引用: AWS Lambda Execution Role)  对手可能会创建仅有权访问特定云服务的账户，从而减少被检测的机会。  一旦对手创建了云账户，他们可以操纵该账户以确保持久性并允许访问其他资源——例如，通过添加[额外的云凭据](https://attack.mitre.org/techniques/T1098/001)或分配[额外的云角色](https://attack.mitre.org/techniques/T1098/003)。 |
| [T1098](../techniques/T1098.md) | 账户操纵 | 对手可能会操纵账户以保持和/或提升对受害者系统的访问权限。账户操纵可能包括任何保持或修改对手访问被破坏账户的操作，例如修改凭据或权限组。(引用: FireEye SMOKEDHAM June 2021) 这些操作还可能包括旨在颠覆安全策略的账户活动，例如执行迭代密码更新以绕过密码持续时间策略并保持被破坏凭据的寿命。  为了创建或操纵账户，对手必须已经在系统或域上具有足够的权限。然而，账户操纵也可能导致权限提升，其中修改授予对其他角色、权限或更高权限的[有效账户](https://attack.mitre.org/techniques/T1078)的访问权限。 |
| [T1098.001](../techniques/T1098.001.md) | 额外的云凭据 | 对手可能会向云账户添加对手控制的凭据，以保持对受害者账户和环境中实例的持续访问。  例如，对手可能会向 Azure / Entra ID 中的服务主体和应用程序添加凭据，除了现有的合法凭据之外。(引用: Microsoft SolarWinds Customer Guidance)(引用: Blue Cloud of Death)(引用: Blue Cloud of Death Video) 这些凭据包括 x509 密钥和密码。(引用: Microsoft SolarWinds Customer Guidance) 在具有足够权限的情况下，有多种方法可以添加凭据，包括 Azure Portal、Azure 命令行界面和 Azure 或 Az PowerShell 模块。(引用: Demystifying Azure AD Service Principals)  在基础设施即服务 (IaaS) 环境中，在通过[云账户](https://attack.mitre.org/techniques/T1078/004)获得访问权限后，对手可能会使用 AWS 中的 <code>CreateKeyPair</code> 或 <code>ImportKeyPair</code> API 或 GCP 中的 <code>gcloud compute os-login ssh-keys add</code> 命令生成或导入自己的 SSH 密钥。这允许在不进一步使用被妥协的云账户的情况下持续访问环境中的实例。(引用: Expel IO Evil in AWS)(引用: Expel Behind the Scenes)  对手还可能使用 AWS 中的 <code>CreateAccessKey</code> API 或 GCP 中的 <code>gcloud iam service-accounts keys create</code> 命令向账户添加访问密钥。或者，他们可能使用 AWS 中的 <code>CreateLoginProfile</code> API 添加一个密码，该密码可用于登录 AWS 管理控制台以进行[云服务仪表板](https://attack.mitre.org/techniques/T1538)。(引用: Permiso Scattered Spider 2023)(引用: Lacework AI Resource Hijacking 2024) 如果目标账户的权限与请求账户不同，对手也可能能够在环境中提升其权限（即[云账户](https://attack.mitre.org/techniques/T1078/004)）。(引用: Rhino Security Labs AWS Privilege Escalation)(引用: Sysdig ScarletEel 2.0) 例如，在 Entra ID 环境中，具有应用程序管理员角色的对手可以向其应用程序的服务主体添加一组新的凭据。通过这样做，对手将能够访问服务主体的角色和权限，这些角色和权限可能与应用程序管理员的不同。(引用: SpecterOps Azure Privilege Escalation)  在 AWS 环境中，具有适当权限的对手还可以使用 `sts:GetFederationToken` API 调用创建一组临时凭据，以[伪造 Web 凭据](https://attack.mitre.org/techniques/T1606)，这些凭据与原始用户账户的权限相关联。这些临时凭据可能在其生命周期内保持有效，即使原始账户的 API 凭据被停用。 (引用: Crowdstrike AWS User Federation Persistence)  在启用了应用程序密码功能的 Entra ID 环境中，对手可能能够向用户账户添加应用程序密码。(引用: Mandiant APT42 Operations 2024) 由于应用程序密码旨在用于不支持多因素身份验证 (MFA) 的旧设备，添加应用程序密码可以允许对手绕过 MFA 要求。此外，即使用户的主密码被重置，应用程序密码也可能保持有效。(引用: Microsoft Entra ID App Passwords) |
| [T1098.002](../techniques/T1098.002.md) | 额外的电子邮件委托权限 | 攻击者可能会授予额外的权限级别，以保持对攻击者控制的电子邮件帐户的持久访问。  例如，<code>Add-MailboxPermission</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001) cmdlet（在本地Exchange和基于云的服务Office 365中可用）向邮箱添加权限。(引用: Microsoft - Add-MailboxPermission)(引用: FireEye APT35 2018)(引用: Crowdstrike Hiding in Plain Sight 2018) 在Google Workspace中，可以通过Google Admin控制台启用委托，用户可以通过其Gmail设置委托帐户。(引用: Gmail委托)(引用: Google确保您的信息安全)  攻击者还可以通过单独的文件夹权限或角色分配邮箱文件夹权限。在Office 365环境中，攻击者可能会为“信息存储顶部”（根目录）、收件箱或其他邮箱文件夹分配默认或匿名用户权限或角色。通过为一个文件夹分配一个或两个用户权限，攻击者可以利用租户中的任何其他帐户来保持对目标用户邮件文件夹的持久访问。(引用: Mandiant Defend UNC2452白皮书)  这可能用于持久威胁事件以及BEC（商业电子邮件入侵）事件，其中攻击者可以向他们希望入侵的帐户添加[额外的云角色](https://attack.mitre.org/techniques/T1098/003)。这可能进一步启用其他技术以获取系统访问权限。例如，受入侵的业务帐户通常用于向目标业务网络中的其他帐户发送消息，同时创建收件箱规则（例如：[内部鱼叉式钓鱼](https://attack.mitre.org/techniques/T1534)），以便消息规避垃圾邮件/钓鱼检测机制。(引用: Bienstock, D. - 防御O365 - 2019) |
| [T1098.003](../techniques/T1098.003.md) | 附加云角色 | 对手可能会向对手控制的云帐户添加附加角色或权限，以保持对租户的持久访问。例如，对手可能会在基于云的环境中更新 IAM 策略，或在 Office 365 环境中添加新的全局管理员。(引用: AWS IAM Policies and Permissions)(引用: Google Cloud IAM Policies)(引用: Microsoft Support O365 Add Another Admin, October 2019)(引用: Microsoft O365 Admin Roles) 具有足够权限的情况下，受损帐户可以获得几乎无限的访问数据和设置的权限（包括重置其他管理员密码的能力）。(引用: Expel AWS Attacker) (引用: Microsoft O365 Admin Roles)   此帐户修改可能紧随[创建帐户](https://attack.mitre.org/techniques/T1136)或其他恶意帐户活动之后。对手还可能修改他们已破坏的现有[有效帐户](https://attack.mitre.org/techniques/T1078)。这可能导致权限提升，特别是如果添加的角色允许横向移动到其他帐户。  例如，在 AWS 环境中，具有适当权限的对手可能能够使用 <code>CreatePolicyVersion</code> API 定义 IAM 策略的新版本，或使用 <code>AttachUserPolicy</code> API 将具有附加或不同权限的 IAM 策略附加到受损用户帐户。(引用: Rhino Security Labs AWS Privilege Escalation)  在某些情况下，对手可能会向受害者云租户之外的对手控制的帐户添加角色。这允许这些外部帐户在受害者租户内执行操作，而无需对手[创建帐户](https://attack.mitre.org/techniques/T1136)或修改受害者拥有的帐户。(引用: Invictus IR DangerDev 2024) |
| [T1098.004](../techniques/T1098.004.md) | SSH 授权密钥 | 对手可能会修改 SSH <code>authorized_keys</code> 文件以在受害者主机上保持持久性。Linux 发行版和 macOS 通常使用基于密钥的身份验证来保护 SSH 会话的身份验证过程以进行远程管理。SSH 中的 <code>authorized_keys</code> 文件指定可用于登录配置该文件的用户帐户的 SSH 密钥。此文件通常位于用户主目录下的 <code>&lt;user-home&gt;/.ssh/authorized_keys</code>。(引用: SSH Authorized Keys) 用户可以编辑系统的 SSH 配置文件，将指令 PubkeyAuthentication 和 RSAAuthentication 修改为值“yes”以确保启用公钥和 RSA 身份验证。SSH 配置文件通常位于 <code>/etc/ssh/sshd_config</code> 下。  对手可能会直接使用脚本或 shell 命令修改 SSH <code>authorized_keys</code> 文件以添加他们自己提供的公钥。在云环境中，对手可能能够通过命令行界面或 REST API 修改特定虚拟机的 SSH authorized_keys 文件。例如，通过使用 Google Cloud CLI 的“add-metadata”命令，对手可以向用户帐户添加 SSH 密钥。(引用: Google Cloud Add Metadata)(引用: Google Cloud Privilege Escalation) 类似地，在 Azure 中，对手可以通过向 API 发送 PATCH 请求来更新虚拟机的 authorized_keys 文件。(引用: Azure Update Virtual Machines) 这确保了拥有相应私钥的对手可以通过 SSH 以现有用户身份登录。(引用: Venafi SSH Key Abuse)(引用: Cybereason Linux Exim Worm) 这也可能导致权限提升，其中虚拟机或实例具有与请求用户不同的权限。  如果通过云 API 或命令行界面修改 authorized_keys 文件，对手可能会在目标虚拟机上实现权限提升，如果他们向更高权限的用户添加密钥。  SSH 密钥也可以添加到网络设备上的帐户，例如使用 `ip ssh pubkey-chain` [网络设备 CLI](https://attack.mitre.org/techniques/T1059/008) 命令。(引用: cisco_ip_ssh_pubkey_ch_cmd) |
| [T1098.005](../techniques/T1098.005.md) | 设备注册 | 对手可能会将设备注册到对手控制的帐户。设备可以注册到多因素身份验证 (MFA) 系统，该系统处理对网络的身份验证，或注册到设备管理系统，该系统处理设备访问和合规性。  MFA 系统（例如 Duo 或 Okta）允许用户将设备与其帐户关联，以完成 MFA 要求。对手如果破坏了用户的凭据，可能会注册新设备以绕过初始 MFA 要求并获得对网络的持续访问。(引用: CISA MFA PrintNightmare)(引用: DarkReading FireEye SolarWinds) 在某些情况下，MFA 自助注册过程可能只需要用户名和密码即可注册帐户的第一个设备或注册到不活跃的帐户。(引用: Mandiant APT29 Microsoft 365 2022)  同样，具有现有网络访问权限的对手可能会将设备注册到 Entra ID 和/或其设备管理系统 Microsoft Intune，以便在绕过条件访问策略的情况下访问敏感数据或资源。(引用: AADInternals - Device Registration)(引用: AADInternals - Conditional Access Bypass)(引用: Microsoft DEV-0537)   注册到 Entra ID 的设备可能能够通过组织内部电子邮件进行 [内部鱼叉式网络钓鱼](https://attack.mitre.org/techniques/T1534) 活动，这些电子邮件不太可能被电子邮件客户端视为可疑。(引用: Microsoft - Device Registration) 此外，对手可能能够通过注册大量设备对 Entra ID 租户执行 [服务耗尽泛洪](https://attack.mitre.org/techniques/T1499/002)。(引用: AADInternals - BPRT) |
| [T1098.006](../techniques/T1098.006.md) | 附加容器集群角色 | 对手可能会向对手控制的用户或服务账户添加附加角色或权限，以保持对容器编排系统的持久访问。例如，具有足够权限的对手可能会创建 RoleBinding 或 ClusterRoleBinding，将角色或集群角色绑定到 Kubernetes 账户。(引用: Kubernetes RBAC)(引用: Aquasec Kubernetes Attack 2023) 在使用基于属性的访问控制 (ABAC) 的情况下，具有足够权限的对手可能会修改 Kubernetes ABAC 策略，以赋予目标账户额外的权限。(引用: Kuberentes ABAC)  此账户修改可能紧随[创建账户](https://attack.mitre.org/techniques/T1136)或其他恶意账户活动之后。对手还可能修改他们已破坏的现有[有效账户](https://attack.mitre.org/techniques/T1078)。  请注意，在云环境中部署的容器编排系统（如 Google Kubernetes Engine、Amazon Elastic Kubernetes Service 和 Azure Kubernetes Service）中，云角色基于访问控制 (RBAC) 分配或 ABAC 策略通常可以替代或补充本地权限分配。(引用: Google Cloud Kubernetes IAM)(引用: AWS EKS IAM Roles for Service Accounts)(引用: Microsoft Azure Kubernetes Service Service Accounts) 在这些情况下，此技术可能与[附加云角色](https://attack.mitre.org/techniques/T1098/003)结合使用。 |
| [T1098.007](../techniques/T1098.007.md) | 附加本地或域组 | 对手可能会向对手控制的账户添加附加本地或域组，以在系统或域中保持持久访问。  在Windows上，账户可以使用`net localgroup`和`net group`命令将现有用户添加到本地和域组。(引用: Microsoft Net Localgroup)(引用: Microsoft Net Group) 在Linux上，对手可能会使用`usermod`命令实现相同的目的。(引用: Linux Usermod)  例如，账户可能会被添加到Windows设备上的本地管理员组，以保持提升的权限。它们还可能被添加到远程桌面用户组，这允许它们利用[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)将来登录到终端。(引用: Microsoft RDP Logons) 在Linux上，账户可能会被添加到sudoers组，允许它们持久地利用[使用Sudo和Sudo缓存](https://attack.mitre.org/techniques/T1548/003)获得提升的权限。  在Windows环境中，机器账户也可能被添加到域组。这允许本地SYSTEM账户在域上获得权限。(引用: RootDSE AD Detection 2022) |
| [T1133](../techniques/T1133.md) | 外部远程服务 | 对手可能会利用外部远程服务来初始访问和/或在网络中保持持久性。远程服务如 VPN、Citrix 和其他访问机制允许用户从外部位置连接到内部企业网络资源。通常有远程服务网关来管理这些服务的连接和凭据认证。服务如 [Windows Remote Management](https://attack.mitre.org/techniques/T1021/006) 和 [VNC](https://attack.mitre.org/techniques/T1021/005) 也可以外部使用。(引用: MacOS VNC software for Remote Desktop)  使用服务的 [Valid Accounts](https://attack.mitre.org/techniques/T1078) 通常是一个要求，这些凭据可以通过凭据钓鱼或在入侵企业网络后从用户那里获取。(引用: Volexity Virtual Private Keylogging) 访问远程服务可以作为操作期间的冗余或持久访问机制。  也可以通过不需要认证的暴露服务获得访问。在容器化环境中，这可能包括暴露的 Docker API、Kubernetes API 服务器、kubelet 或 Web 应用程序如 Kubernetes 仪表板。(引用: Trend Micro Exposed Docker Server)(引用: Unit 42 Hildegard Malware) |
| [T1136](../techniques/T1136.md) | 创建账户 | 对手可能会创建账户以保持对受害者系统的访问。(引用: Symantec WastedLocker June 2020) 具有足够访问权限的情况下，创建此类账户可用于建立不需要在系统上部署持久远程访问工具的次要凭证访问。  账户可以在本地系统或域或云租户中创建。在云环境中，对手可能会创建仅有权访问特定服务的账户，这可以减少被检测的机会。 |
| [T1137](../techniques/T1137.md) | Office 应用程序启动 | 对手可能利用基于 Microsoft Office 的应用程序在启动之间保持持久性。Microsoft Office 是企业网络中基于 Windows 操作系统的常见应用程序套件。可以使用多种机制在启动 Office 应用程序时保持持久性；这可能包括使用 Office 模板宏和加载项。  在 Outlook 中发现了多种可以滥用以获得持久性的功能，例如 Outlook 规则、表单和主页。(引用: SensePost Ruler GitHub) 这些持久性机制可以在 Outlook 中工作，也可以通过 Office 365 使用。(引用: TechNet O365 Outlook Rules) |
| [T1137.001](../techniques/T1137.001.md) | Office模板宏 | 对手可能会滥用 Microsoft Office 模板在受损系统上获得持久性。Microsoft Office 包含作为常见 Office 应用程序一部分的模板，用于自定义样式。应用程序中的基本模板在每次启动应用程序时使用。(引用: Microsoft Change Normal Template)  Office Visual Basic for Applications (VBA) 宏 (引用: MSDN VBA in Office) 可以插入到基本模板中，并在相应的 Office 应用程序启动时用于执行代码以获得持久性。Word 和 Excel 的示例已被发现并发布。默认情况下，Word 创建了一个可以修改以包含恶意宏的 Normal.dotm 模板。Excel 默认没有创建模板文件，但可以添加一个模板文件，该文件将在启动时自动加载。(引用: enigma0x3 normal.dotm)(引用: Hexacorn Office Template Macros) 共享模板也可以存储并从远程位置提取。(引用: GlobalDotName Jun 2019)  Word Normal.dotm 位置：<br> <code>C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Templates\Normal.dotm</code>  Excel Personal.xlsb 位置：<br> <code>C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Excel\XLSTART\PERSONAL.XLSB</code>  对手还可以通过劫持应用程序的搜索顺序来更改基本模板的位置，例如 Word 2016 将首先在 <code>C:\Program Files (x86)\Microsoft Office\root\Office16\</code> 下查找 Normal.dotm，或通过修改 GlobalDotName 注册表项。通过修改 GlobalDotName 注册表项，对手可以指定一个任意位置、文件名和文件扩展名，用于在应用程序启动时加载的模板。要滥用 GlobalDotName，对手可能首先需要将模板注册为受信任的文档或将其放置在受信任的位置。(引用: GlobalDotName Jun 2019)  根据系统或企业安全策略对宏的使用，对手可能需要启用宏以执行不受限制的操作。 |
| [T1137.002](../techniques/T1137.002.md) | Office测试 | 攻击者可能滥用Microsoft Office的“Office Test”注册表项以在受感染系统上获得持久性。存在一个Office Test注册表位置，允许用户指定一个任意DLL，该DLL将在每次启动Office应用程序时执行。此注册表项被认为是Microsoft在开发Office应用程序时用于加载DLL以进行测试和调试的。此注册表项在Office安装期间默认不会创建。（引用：Hexacorn Office Test）（引用：Palo Alto Office Test Sofacy）  存在用户和全局的Office Test功能注册表项，例如：  * <code>HKEY_CURRENT_USER\Software\Microsoft\Office test\Special\Perf</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Office test\Special\Perf</code>  攻击者可能会添加此注册表项并指定一个恶意DLL，该DLL将在每次启动Office应用程序（如Word或Excel）时执行。 |
| [T1137.003](../techniques/T1137.003.md) | Outlook表单 | 对手可能滥用Microsoft Outlook表单在受感染系统上获得持久性。Outlook表单用于在Outlook消息中呈现和功能的模板。可以创建自定义Outlook表单，当对手使用相同的自定义Outlook表单发送特定格式的电子邮件时，将执行代码。(引用: SensePost Outlook Forms)  一旦恶意表单被添加到用户的邮箱中，它们将在Outlook启动时加载。当对手向用户发送特定格式的电子邮件时，恶意表单将执行。(引用: SensePost Outlook Forms) |
| [T1137.004](../techniques/T1137.004.md) | Outlook主页 | 对手可能会滥用Microsoft Outlook的主页功能在被破坏的系统上获得持久性。Outlook主页是一个用于自定义Outlook文件夹显示的旧功能。此功能允许加载和显示内部或外部URL，每当打开文件夹时都会加载和显示。可以制作一个恶意的HTML页面，当由Outlook主页加载时会执行代码。(引用: SensePost Outlook Home Page)  一旦恶意主页被添加到用户的邮箱中，它们将在Outlook启动时加载。当加载/重新加载正确的Outlook文件夹时，恶意主页将执行。(引用: SensePost Outlook Home Page) |
| [T1137.005](../techniques/T1137.005.md) | Outlook规则 | 对手可能会滥用Microsoft Outlook规则在被破坏的系统上获得持久性。Outlook规则允许用户定义自动行为来管理电子邮件消息。例如，一个合法的规则可能会自动将包含特定词语的电子邮件从特定发件人移动到Outlook中的特定文件夹。恶意的Outlook规则可以创建，当对手向该用户发送特定构造的电子邮件时触发代码执行。(引用: SilentBreak Outlook Rules)  一旦恶意规则被添加到用户的邮箱中，它们将在Outlook启动时加载。当对手向用户发送特定构造的电子邮件时，恶意规则将执行。(引用: SilentBreak Outlook Rules) |
| [T1137.006](../techniques/T1137.006.md) | 加载项 | 对手可能会滥用Microsoft Office加载项，以在被破坏的系统上获得持久性。Office加载项可用于向Office程序添加功能。(引用: Microsoft Office Add-ins) 不同的Office产品可以使用不同类型的加载项；包括Word/Excel加载项库（WLL/XLL）、VBA加载项、Office组件对象模型（COM）加载项、自动化加载项、VBA编辑器（VBE）、Visual Studio Tools for Office（VSTO）加载项和Outlook加载项。(引用: MRWLabs Office Persistence Add-ins)(引用: FireEye Mail CDS 2018)  加载项可以用于获得持久性，因为它们可以设置为在Office应用程序启动时执行代码。 |
| [T1176](../techniques/T1176.md) | 浏览器扩展 | 对手可能会滥用 Internet 浏览器扩展来建立对受害者系统的持久访问。浏览器扩展或插件是可以添加功能并自定义 Internet 浏览器各个方面的小程序。它们可以直接安装或通过浏览器的应用商店安装，通常具有浏览器可以访问的所有内容的访问权限和权限。(引用: Wikipedia Browser Extension)(引用: Chrome Extensions Definition)  恶意扩展可以通过伪装成合法扩展的恶意应用商店下载、通过社会工程或已被对手破坏的系统安装到浏览器中。浏览器应用商店的安全性可能有限，因此恶意扩展可能很容易击败自动扫描程序。(引用: Malicious Chrome Extension Numbers) 根据浏览器的不同，对手还可能操纵扩展的更新 URL 以从对手控制的服务器安装更新，或操纵移动配置文件以静默安装其他扩展。  在 macOS 11 之前，对手可以通过命令行使用 <code>profiles</code> 工具静默安装浏览器扩展，以安装恶意 <code>.mobileconfig</code> 文件。在 macOS 11+ 中，使用 <code>profiles</code> 工具不再能够安装配置文件，但可以种植和安装 <code>.mobileconfig</code> 文件，需用户交互。(引用: xorrior chrome extensions macOS)  一旦安装了扩展，它可以在后台浏览网站，窃取用户在浏览器中输入的所有信息（包括凭据），并用作持久性的 RAT 安装程序。(引用: Chrome Extension Crypto Miner)(引用: ICEBRG Chrome Extensions)(引用: Banker Google Chrome Extension Steals Creds)(引用: Catch All Chrome Extension)  也有使用恶意 Chrome 扩展通过 [命令和控制](https://attack.mitre.org/tactics/TA0011) 进行持久后门的僵尸网络实例。(引用: Stantinko Botnet)(引用: Chrome Extension C2 Malware) 对手还可能使用浏览器扩展修改浏览器权限和组件、隐私设置和其他安全控制以进行 [防御规避](https://attack.mitre.org/tactics/TA0005)。(引用: Browers FriarFox)(引用: Browser Adrozek) |
| [T1197](../techniques/T1197.md) | BITS 任务 | 对手可能会滥用 BITS 任务来持续执行代码并执行各种后台任务。Windows 后台智能传输服务 (BITS) 是一种通过 [组件对象模型](https://attack.mitre.org/techniques/T1559/001) (COM) 暴露的低带宽、异步文件传输机制。(引用: Microsoft COM)(引用: Microsoft BITS) BITS 通常用于更新程序、消息传递程序和其他首选在后台运行的应用程序（使用可用的空闲带宽）而不打断其他网络应用程序。文件传输任务作为 BITS 任务实现，其中包含一个或多个文件操作的队列。  创建和管理 BITS 任务的接口可通过 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 和 [BITSAdmin](https://attack.mitre.org/software/S0190) 工具访问。(引用: Microsoft BITS)(引用: Microsoft BITSAdmin)  对手可能会滥用 BITS 下载（例如 [入口工具传输](https://attack.mitre.org/techniques/T1105)）、执行甚至在运行恶意代码后进行清理（例如 [指标移除](https://attack.mitre.org/techniques/T1070)）。BITS 任务是自包含的 BITS 任务数据库，没有新文件或注册表修改，并且通常被主机防火墙允许。(引用: CTU BITS Malware June 2016)(引用: Mondok Windows PiggyBack BITS May 2007)(引用: Symantec BITS May 2007) BITS 启用的执行还可以通过创建长期任务（默认最大寿命为 90 天且可扩展）或在任务完成或出错时调用任意程序（包括系统重启后）来实现持久性。(引用: PaloAlto UBoatRAT Nov 2017)(引用: CTU BITS Malware June 2016)  BITS 上传功能也可用于执行 [通过替代协议外传](https://attack.mitre.org/techniques/T1048)。(引用: CTU BITS Malware June 2016) |
| [T1205](../techniques/T1205.md) | 流量信号 | 对手可能会使用流量信号来隐藏用于持久性或命令和控制的开放端口或其他恶意功能。流量信号涉及发送一个魔法值或序列到系统以触发特殊响应，例如打开关闭的端口或执行恶意任务。这可能采取发送具有某些特征的一系列数据包的形式，然后端口将被打开供对手使用命令和控制。通常，这些数据包序列包括尝试连接到预定义序列的关闭端口（即[端口敲击](https://attack.mitre.org/techniques/T1205/001)），但也可以涉及不寻常的标志、特定字符串或其他独特特征。在序列完成后，打开端口可以通过基于主机的防火墙实现，但也可以通过自定义软件实现。  对手还可能与已经打开的端口通信，但监听该端口的服务只有在传递适当的魔法值时才会响应命令或触发其他恶意功能。  观察触发通信的信号数据包可以通过不同的方法进行。一种方法，最初由 Cd00r 实现 (引用: Hartrell cd00r 2002)，是使用 libpcap 库来嗅探相关数据包。另一种方法利用原始套接字，使恶意软件能够使用其他程序已经打开的端口。  在网络设备上，对手可能会使用精心制作的数据包来启用[网络设备身份验证](https://attack.mitre.org/techniques/T1556/004)以用于设备提供的标准服务，例如 telnet。此类信号还可以用于打开关闭的服务端口，例如 telnet，或触发恶意软件植入物上的模块修改，添加、删除或更改恶意功能。对手可能会使用精心制作的数据包尝试连接到一个或多个（打开或关闭的）端口，但也可能尝试连接到路由器接口、广播和网络地址 IP 上的相同端口以实现其目标和目的。(引用: Cisco Synful Knock Evolution)(引用: Mandiant - Synful Knock)(引用: Cisco Blog Legacy Device Attacks) 要在嵌入式设备上启用此流量信号，对手必须首先实现并利用[补丁系统映像](https://attack.mitre.org/techniques/T1601/001)，因为架构的单片性质。  对手还可能使用 Wake-on-LAN 功能来打开已关闭的系统。Wake-on-LAN 是一种硬件功能，允许通过发送魔法数据包来打开或唤醒已关闭的系统。一旦系统打开，它可能成为横向移动的目标。(引用: Bleeping Computer - Ryuk WoL)(引用: AMD Magic Packet) |
| [T1205.001](../techniques/T1205.001.md) | 端口敲击 | 对手可能会使用端口敲击来隐藏用于持久性或命令和控制的开放端口。为了启用端口，对手会向一系列预定义的关闭端口发送一系列尝试连接。在完成序列后，通常由主机防火墙打开端口，但也可以由自定义软件实现。  这种技术已被观察到用于动态打开监听端口以及在不同系统上启动与监听服务器的连接。  可以通过不同的方法观察触发通信的信号包。一种方法，最初由 Cd00r 实现 (引用: Hartrell cd00r 2002)，是使用 libpcap 库嗅探相关数据包。另一种方法利用原始套接字，使恶意软件能够使用其他程序已打开的端口。 |
| [T1205.002](../techniques/T1205.002.md) | 套接字过滤器 | 对手可能会将过滤器附加到网络套接字，以监视然后激活用于持久性或命令和控制的后门。具有提升权限的对手可以使用诸如`libpcap`库之类的功能打开套接字并安装过滤器，以允许或禁止某些类型的数据通过套接字。过滤器可能适用于通过指定网络接口（如果未指定，则适用于每个接口）的所有流量。当网络接口接收到与过滤器条件匹配的数据包时，可以在主机上触发其他操作，例如激活反向shell。  为了建立连接，对手会向目标主机发送与安装的过滤器条件匹配的精心制作的数据包。(引用: haking9 libpcap network sniffing) 对手已经使用这些套接字过滤器来触发植入物的安装、进行ping返回以及调用命令shell。与[协议隧道](https://attack.mitre.org/techniques/T1572)结合使用时，这些套接字过滤器的通信也可能被使用。(引用: exatrack bpf filters passive backdoors)(引用: Leonardo Turla Penquin May 2020)  可以在安装了`libpcap`的任何类Unix平台上或在使用`Winpcap`的Windows主机上安装过滤器。对手可以使用`libpcap`与`pcap_setfilter`或标准库函数`setsockopt`与`SO_ATTACH_FILTER`选项。由于套接字连接在接收到数据包之前未激活，因此由于主机上的活动缺乏、CPU开销低以及对原始套接字使用的可见性有限，这种行为可能难以检测。 |
| [T1505](../techniques/T1505.md) | 服务器软件组件 | 对手可能会滥用服务器的合法可扩展开发功能，以在系统上建立持久访问。企业服务器应用程序可能包括允许开发人员编写和安装软件或脚本以扩展主应用程序功能的功能。对手可能会安装恶意组件以扩展和滥用服务器应用程序。(引用: volexity_0day_sophos_FW) |
| [T1505.001](../techniques/T1505.001.md) | SQL存储过程 | 对手可能滥用SQL存储过程在系统上建立持久访问。SQL存储过程是可以保存和重用的代码，以便数据库用户不必浪费时间重写经常使用的SQL查询。存储过程可以通过使用过程名称的SQL语句或通过定义的事件（例如启动/重启SQL服务器应用程序时）调用。  对手可能会编写恶意存储过程，这些过程可以在SQL数据库服务器中提供持久机制。(引用: NetSPI Startup Stored Procedures)(引用: Kaspersky MSSQL Aug 2019) 要通过SQL语法执行操作系统命令，对手可能需要启用其他功能，例如MSSQL Server的xp_cmdshell。(引用: NetSPI Startup Stored Procedures)(引用: Kaspersky MSSQL Aug 2019)(引用: Microsoft xp_cmdshell 2017)  Microsoft SQL Server可以启用通用语言运行时（CLR）集成。启用CLR集成后，应用程序开发人员可以使用任何.NET框架语言（例如VB .NET、C#等）编写存储过程。(引用: Microsoft CLR Integration 2017) 对手可能会编写或修改与存储过程链接的CLR程序集，因为这些CLR程序集可以执行任意命令。(引用: NetSPI SQL Server CLR) |
| [T1505.002](../techniques/T1505.002.md) | 传输代理 | 对手可能会滥用Microsoft传输代理，以在系统上建立持久访问。Microsoft Exchange传输代理可以在通过传输管道的电子邮件消息上操作，以执行各种任务，例如过滤垃圾邮件、过滤恶意附件、记录或在所有外发电子邮件末尾添加公司签名。(引用: Microsoft TransportAgent Jun 2016)(引用: ESET LightNeuron May 2019) 传输代理可以由应用程序开发人员编写，然后编译为.NET程序集，随后在Exchange服务器上注册。传输代理将在电子邮件处理的指定阶段被调用，并执行开发人员定义的任务。  对手可能会注册恶意传输代理，以在Exchange Server中提供持久性机制，该机制可以由对手指定的电子邮件事件触发。(引用: ESET LightNeuron May 2019) 尽管恶意传输代理可能会对通过Exchange传输管道的所有电子邮件进行调用，但代理可以配置为仅在响应对手定义的条件时执行特定任务。例如，传输代理可能仅在收件人电子邮件地址与对手提供的列表中的条目匹配时，执行诸如复制传输中的附件并保存以供稍后外传的操作。 |
| [T1505.003](../techniques/T1505.003.md) | Web Shell | 对手可能会在 Web 服务器上植入 Web shell 以建立对系统的持久访问。Web shell 是放置在公开可访问的 Web 服务器上的 Web 脚本，允许对手访问 Web 服务器作为进入网络的网关。Web shell 可能提供一组功能来执行或在托管 Web 服务器的系统上提供命令行界面。(引用: volexity_0day_sophos_FW)  除了服务器端脚本，Web shell 可能还有一个客户端界面程序，用于与 Web 服务器通信（例如，[China Chopper](https://attack.mitre.org/software/S0020) Web shell 客户端）。(引用: Lee 2013) |
| [T1505.004](../techniques/T1505.004.md) | IIS 组件 | 对手可能会安装在 Internet 信息服务 (IIS) Web 服务器上运行的恶意组件以建立持久性。IIS 提供了几种扩展 Web 服务器功能的机制。例如，可以安装 Internet 服务器应用程序编程接口 (ISAPI) 扩展和筛选器来检查和/或修改传入和传出的 IIS Web 请求。扩展和筛选器作为 DLL 文件部署，导出三个函数：<code>Get{Extension/Filter}Version</code>、<code>Http{Extension/Filter}Proc</code> 和（可选）<code>Terminate{Extension/Filter}</code>。还可以安装 IIS 模块以扩展 IIS Web 服务器。(引用: Microsoft ISAPI Extension Overview 2017)(引用: Microsoft ISAPI Filter Overview 2017)(引用: IIS Backdoor 2011)(引用: Trustwave IIS Module 2013)  对手可能会安装恶意 ISAPI 扩展和筛选器来观察和/或修改流量、在受感染的机器上执行命令或代理命令和控制流量。ISAPI 扩展和筛选器可能有权访问所有 IIS Web 请求和响应。例如，对手可能会滥用这些机制来修改 HTTP 响应，以便将恶意命令/内容分发到先前受感染的主机。(引用: Microsoft ISAPI Filter Overview 2017)(引用: Microsoft ISAPI Extension Overview 2017)(引用: Microsoft ISAPI Extension All Incoming 2017)(引用: Dell TG-3390)(引用: Trustwave IIS Module 2013)(引用: MMPC ISAPI Filter 2012)  对手还可能安装恶意 IIS 模块来观察和/或修改流量。IIS 7.0 引入的模块提供与 ISAPI 扩展和筛选器相同的对 HTTP 请求和响应的不受限制的访问。IIS 模块可以编写为导出 <code>RegisterModule</code> 的 DLL，或作为 .NET 应用程序与 ASP.NET API 交互以访问 IIS HTTP 请求。(引用: Microsoft IIS Modules Overview 2007)(引用: Trustwave IIS Module 2013)(引用: ESET IIS Malware 2021) |
| [T1505.005](../techniques/T1505.005.md) | 终端服务 DLL | 对手可能会滥用终端服务组件，以启用对系统的持久访问。Microsoft 终端服务，在某些 Windows Server 操作系统中自 2022 年起重命名为远程桌面服务，使远程终端连接到主机成为可能。终端服务允许服务器通过 RDP 向客户端传输完整的交互式图形用户界面。(引用: Microsoft Remote Desktop Services)  作为“通用”进程（例如：<code>svchost.exe</code>）运行的[Windows 服务](https://attack.mitre.org/techniques/T1543/003)会加载服务的 DLL 文件，其位置存储在名为 <code>ServiceDll</code> 的注册表项中。(引用: Microsoft System Services Fundamentals) <code>termsrv.dll</code> 文件通常存储在 `%SystemRoot%\System32\` 中，是 `HKLM\System\CurrentControlSet\services\TermService\Parameters\` 中终端服务的默认 <code>ServiceDll</code> 值。  对手可能会修改和/或替换终端服务 DLL，以启用对受害主机的持久访问。(引用: James TermServ DLL) 对此 DLL 的修改可以执行任意有效负载（同时可能保留正常的 <code>termsrv.dll</code> 功能），也可以简单地启用终端服务的可滥用功能。例如，对手可能会通过修补 <code>termsrv.dll</code> 文件或修改 <code>ServiceDll</code> 值以指向提供增强 RDP 功能的 DLL 来启用并发[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)会话等功能。(引用: Windows OS Hub RDP)(引用: RDPWrap Github) 在非服务器 Windows 操作系统上，这种增强功能还可能使对手在创建新 RDP 会话时避免终端服务提示警告/注销用户。 |
| [T1525](../techniques/T1525.md) | 植入内部镜像 | 对手可能会在获得环境访问权限后植入带有恶意代码的云或容器镜像，以建立持久性。Amazon Web Services（AWS）Amazon Machine Images（AMIs）、Google Cloud Platform（GCP）镜像和Azure镜像以及流行的容器运行时（如Docker）可以被植入或后门化。与[上传恶意软件](https://attack.mitre.org/techniques/T1608/001)不同，此技术侧重于对手在受害者环境中的注册表中植入镜像。根据基础设施的配置方式，如果基础设施配置工具被指示始终使用最新镜像，这可能提供持久访问。(引用: Rhino Labs Cloud Image Backdoor Technique Sept 2019)  已经开发了一种工具来促进在云容器镜像中植入后门。(引用: Rhino Labs Cloud Backdoor September 2019) 如果对手访问了受损的AWS实例，并具有列出可用容器镜像的权限，他们可能会植入后门，例如[Web Shell](https://attack.mitre.org/techniques/T1505/003)。(引用: Rhino Labs Cloud Image Backdoor Technique Sept 2019) |
| [T1542](../techniques/T1542.md) | 操作系统启动前 | 对手可能会滥用操作系统启动前的机制，作为在系统上建立持久性的一种方式。在计算机的启动过程中，固件和各种启动服务在操作系统加载之前加载。这些程序在操作系统接管之前控制执行流程。(引用: Wikipedia Booting)  对手可能会覆盖启动驱动程序或固件（如 BIOS（基本输入/输出系统）和统一可扩展固件接口（UEFI））中的数据，以在操作系统下的层面上持久存在于系统上。这可能特别难以检测，因为此级别的恶意软件不会被主机软件防御检测到。 |
| [T1542.001](../techniques/T1542.001.md) | 系统固件 | 对手可能会修改系统固件以在系统上保持持久性。BIOS（基本输入/输出系统）和统一可扩展固件接口（UEFI）或可扩展固件接口（EFI）是系统固件的示例，它们作为计算机操作系统和硬件之间的软件接口。(引用: Wikipedia BIOS)(引用: Wikipedia UEFI)(引用: About UEFI)  系统固件如 BIOS 和 (U)EFI 支持计算机的功能，可能会被对手修改以执行或协助恶意活动。存在覆盖系统固件的能力，这可能为复杂的对手提供一种手段，通过安装恶意固件更新作为在系统上保持持久性的一种手段，这可能难以检测。 |
| [T1542.002](../techniques/T1542.002.md) | 组件固件 | 对手可能会修改组件固件以在系统上持久存在。一些对手可能会采用复杂的方法来破坏计算机组件并安装恶意固件，该固件将在操作系统和主系统固件或 BIOS 之外执行对手代码。这种技术可能类似于[系统固件](https://attack.mitre.org/techniques/T1542/001)，但在其他系统组件/设备上进行，这些组件/设备可能没有相同的能力或完整性检查级别。  恶意组件固件可以在尽管潜在的典型故障无法维持访问和硬盘重新映像的情况下提供对系统的持久访问级别，以及一种绕过主机软件防御和完整性检查的方法。 |
| [T1542.003](../techniques/T1542.003.md) | 引导工具包 | 对手可能会使用引导工具包在系统上保持持久性。引导工具包位于操作系统下方的层，可能使执行完全修复变得困难，除非组织怀疑使用了引导工具包并能相应地采取行动。  引导工具包是一种修改硬盘引导扇区的恶意软件变体，包括主引导记录 (MBR) 和卷引导记录 (VBR)。(引用: Mandiant M Trends 2016) MBR 是在 BIOS 完成硬件初始化后首先加载的磁盘部分。它是引导加载程序的位置。具有对引导驱动器的原始访问权限的对手可能会覆盖此区域，在启动过程中将执行从正常引导加载程序转移到对手代码。(引用: Lau 2011)  MBR 将引导过程的控制权交给 VBR。与 MBR 的情况类似，具有对引导驱动器的原始访问权限的对手可能会覆盖 VBR，在启动过程中将执行转移到对手代码。 |
| [T1542.004](../techniques/T1542.004.md) | ROMMONkit | 对手可能通过加载包含对手代码的未经授权的固件来滥用ROM Monitor（ROMMON），以提供持久访问并操纵设备行为，这很难检测到。(引用: Cisco Synful Knock Evolution)(引用: Cisco Blog Legacy Device Attacks)   ROMMON是Cisco网络设备固件，作为引导加载程序、引导映像或引导助手在平台上电或重置时初始化硬件和软件。类似于[TFTP引导](https://attack.mitre.org/techniques/T1542/005)，对手可能通过本地或远程（例如，通过TFTP）升级ROMMON映像，包含对手代码并重新启动设备，以覆盖现有的ROMMON映像。这为对手提供了一种方式，通过更新ROMMON在系统上获得持久性，这可能很难检测到。 |
| [T1542.005](../techniques/T1542.005.md) | TFTP 启动 | 对手可能会滥用网络启动从简单文件传输协议 (TFTP) 服务器加载未经授权的网络设备操作系统。TFTP 启动（网络启动）通常由网络管理员用于从集中管理服务器加载配置控制的网络设备映像。网络启动是引导顺序中的一个选项，可用于集中管理和控制设备映像。  对手可能会操纵网络设备上的配置，指定使用恶意 TFTP 服务器，这可能与[修改系统映像](https://attack.mitre.org/techniques/T1601)结合使用，以在设备启动或重置时加载修改后的映像。未经授权的映像允许对手修改设备配置，向设备添加恶意功能，并引入后门以保持对网络设备的控制，同时通过使用标准功能最小化检测。这种技术类似于[ROMMONkit](https://attack.mitre.org/techniques/T1542/004)，可能导致网络设备运行修改后的映像。(引用: Cisco Blog Legacy Device Attacks) |
| [T1543](../techniques/T1543.md) | 创建或修改系统进程 | 对手可能会创建或修改系统级进程以重复执行恶意有效负载作为持久性的一部分。当操作系统启动时，它们可以启动执行后台系统功能的进程。在 Windows 和 Linux 上，这些系统进程称为服务。(引用: TechNet Services) 在 macOS 上，称为 [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) 和 [Launch Agent](https://attack.mitre.org/techniques/T1543/001) 的 launchd 进程用于完成系统初始化并加载用户特定参数。(引用: AppleDocs Launch Agent Daemons)  对手可能会安装新的服务、守护进程或代理，这些可以配置为在启动时或在可重复的时间间隔执行，以建立持久性。同样，对手可能会修改现有的服务、守护进程或代理以实现相同的效果。  服务、守护进程或代理可能会以管理员权限创建，但以 root/SYSTEM 权限执行。对手可能会利用此功能创建或修改系统进程以提升权限。(引用: OSX Malware Detection) |
| [T1543.001](../techniques/T1543.001.md) | 启动代理 | 对手可能会创建或修改启动代理，以在持久性的一部分中反复执行恶意负载。当用户登录时，会启动一个每用户的 launchd 进程，该进程从 <code>/System/Library/LaunchAgents</code>、<code>/Library/LaunchAgents</code> 和 <code>~/Library/LaunchAgents</code> 中找到的属性列表 (.plist) 文件中加载每个按需启动的用户代理的参数。(引用: AppleDocs Launch Agent Daemons)(引用: OSX Keydnap malware) (引用: Antiquated Mac Malware) 属性列表文件使用 <code>Label</code>、<code>ProgramArguments</code> 和 <code>RunAtLoad</code> 键来标识启动代理的名称、可执行文件位置和执行时间。(引用: OSX.Dok Malware) 启动代理通常安装以执行程序更新、在登录时启动用户指定的程序或执行其他开发人员任务。   启动代理还可以使用 [Launchctl](https://attack.mitre.org/techniques/T1569/001) 命令执行。   对手可能会通过将 .plist 文件放入适当的文件夹中并将 <code>RunAtLoad</code> 或 <code>KeepAlive</code> 键设置为 <code>true</code> 来安装在登录时执行的新启动代理。(引用: Sofacy Komplex Trojan)(引用: Methods of Mac Malware Persistence) 启动代理的名称可能会通过使用相关操作系统或良性软件的名称来伪装。启动代理是以用户级别权限创建的，并以用户级别权限执行。(引用: OSX Malware Detection)(引用: OceanLotus for OS X)  |
| [T1543.002](../techniques/T1543.002.md) | Systemd服务 | 对手可能会创建或修改systemd服务，以作为持久性的一部分反复执行恶意负载。Systemd是一个系统和服务管理器，通常用于管理后台守护进程（也称为服务）和其他系统资源。(引用: Linux man-pages: systemd January 2014) Systemd是许多Linux发行版上的默认初始化(init)系统，取代了遗留的init系统，包括SysVinit和Upstart，同时保持向后兼容。  Systemd使用扩展名为.service的单元配置文件来编码有关服务进程的信息。默认情况下，系统级单元文件存储在根拥有的目录(/)的/systemd/system目录中。用户级单元文件存储在用户拥有的目录($HOME)的/systemd/user目录中。(引用: lambert systemd 2022)  在.service单元文件中，以下指令用于执行命令：(引用: freedesktop systemd.service)  * ExecStart、ExecStartPre和ExecStartPost指令在服务由systemctl手动启动或在系统启动时执行，如果服务设置为自动启动。 * ExecReload指令在服务重新启动时执行。 * ExecStop、ExecStopPre和ExecStopPost指令在服务停止时执行。  对手已经创建了新的服务文件，更改了.service文件指令执行的命令，并修改了.service文件执行的用户指令，这可能导致权限提升。对手还可能在这些目录中放置符号链接，使systemd能够找到这些负载，无论它们在文件系统中的位置。(引用: Anomali Rocke March 2019)(引用: airwalk backdoor unix systems)(引用: Rapid7 Service Persistence 22JUNE2016)  .service文件的User指令可用于以特定用户身份运行服务，这可能会根据特定用户/组权限导致权限提升。 |
| [T1543.003](../techniques/T1543.003.md) | Windows 服务 | 对手可能会创建或修改 Windows 服务，以便在持久性的一部分中重复执行恶意有效负载。当 Windows 启动时，它会启动称为服务的程序或应用程序，这些程序或应用程序执行后台系统功能。(引用: TechNet Services) Windows 服务配置信息，包括服务可执行文件或恢复程序/命令的文件路径，存储在 Windows 注册表中。  对手可能会安装新服务或修改现有服务，以便在启动时执行以在系统上保持持久性。可以使用系统实用程序（如 sc.exe）设置或修改服务配置，通过直接修改注册表，或通过直接与 Windows API 交互。  对手还可能使用服务安装和执行恶意驱动程序。例如，在将驱动程序文件（例如 .sys）放到磁盘后，可以通过[本机 API](https://attack.mitre.org/techniques/T1106)函数（如 `CreateServiceW()`）加载和注册有效负载（或通过函数如 `ZwLoadDriver()` 和 `ZwSetValueKey()` 手动），通过创建所需的服务注册表值（即[修改注册表](https://attack.mitre.org/techniques/T1112)），或通过使用命令行实用程序如 `PnPUtil.exe`。(引用: Symantec W.32 Stuxnet Dossier)(引用: Crowdstrike DriveSlayer February 2022)(引用: Unit42 AcidBox June 2020) 对手可能利用这些驱动程序作为[Rootkit](https://attack.mitre.org/techniques/T1014)来隐藏系统上的恶意活动。对手还可能将签名但易受攻击的驱动程序加载到受感染的机器上（称为“自带易受攻击的驱动程序” (BYOVD)），作为[特权提升利用](https://attack.mitre.org/techniques/T1068)的一部分。(引用: ESET InvisiMole June 2020)(引用: Unit42 AcidBox June 2020)  服务可能以管理员权限创建，但以 SYSTEM 权限执行，因此对手也可能使用服务来提升权限。对手还可能通过[服务执行](https://attack.mitre.org/techniques/T1569/002)直接启动服务。  为了使检测分析更加困难，恶意服务还可能包含[伪装任务或服务](https://attack.mitre.org/techniques/T1036/004)（例如，使用与合法操作系统或良性软件组件相关的服务和/或有效负载名称）。对手还可能创建“隐藏”服务（即，[隐藏工件](https://attack.mitre.org/techniques/T1564)），例如通过使用 `sc sdset` 命令通过服务描述符定义语言 (SDDL) 设置服务权限。这可能会隐藏 Windows 服务，使其无法通过标准服务枚举方法（如 `Get-Service`、`sc query` 和 `services.exe`）查看。(引用: SANS 1)(引用: SANS 2) |
| [T1543.004](../techniques/T1543.004.md) | 启动守护程序 | 对手可能会创建或修改启动守护程序以执行恶意有效负载作为持久性的一部分。启动守护程序是用于与Launchd交互的plist文件，Launchd是macOS使用的服务管理框架。安装启动守护程序需要提升的权限，它们在系统登录前为每个用户执行，并在后台运行而无需用户交互。在macOS初始化启动期间，launchd进程从<code>/System/Library/LaunchDaemons/</code>和<code>/Library/LaunchDaemons/</code>中的plist文件加载按需启动的系统级守护程序的参数。启动守护程序的必需参数包括用于标识任务的<code>Label</code>，提供可执行文件路径的<code>Program</code>，以及指定任务何时运行的<code>RunAtLoad</code>。启动守护程序通常用于提供对共享资源的访问、软件更新或执行自动化任务。(引用: AppleDocs Launch Agent Daemons)(引用: Methods of Mac Malware Persistence)(引用: launchd Keywords for plists)  对手可能会通过使用<code>RunAtLoad</code>参数设置为<code>true</code>和<code>Program</code>参数设置为恶意可执行文件路径来安装配置为在启动时执行的启动守护程序。守护程序名称可能会通过使用相关操作系统或良性软件的名称进行伪装（即[伪装](https://attack.mitre.org/techniques/T1036)）。当启动守护程序执行时，程序继承管理员权限。(引用: WireLurker)(引用: OSX Malware Detection)  此外，系统配置更改（例如安装第三方包管理软件）可能会导致文件夹如<code>usr/local/bin</code>变得全局可写。因此，配置不当可能允许对手修改当前启动守护程序的plist文件引用的可执行文件。(引用: LaunchDaemon Hijacking)(引用: sentinelone macos persist Jun 2019) |
| [T1543.005](../techniques/T1543.005.md) | 容器服务 | 对手可能会创建或修改在单个主机上作为守护进程、代理或服务运行的容器或容器集群管理工具。这些工具包括用于创建和管理单个容器的软件，如 Docker 和 Podman，以及容器集群节点级代理，如 kubelet。通过修改这些服务，对手可能能够在主机上实现持久性或提升其权限。  例如，通过使用带有 `restart=always` 指令的 `docker run` 或 `podman run` 命令，可以将容器配置为在主机上持久重启。(引用: AquaSec TeamTNT 2023) 具有（root）docker 命令访问权限的用户也可能能够在主机上提升其权限。(引用: GTFOBins Docker)  在 Kubernetes 环境中，DaemonSets 允许对手在所有节点上持久性地[部署容器](https://attack.mitre.org/techniques/T1610)，包括后来添加到集群中的节点。(引用: Aquasec Kubernetes Attack 2023)(引用: Kubernetes DaemonSet) 可以使用 pod 规范中的 `nodeSelector` 或 `nodeName` 字段将 Pod 部署到特定节点。(引用: Kubernetes Assigning Pods to Nodes)(引用: AppSecco Kubernetes Namespace Breakout 2020)  请注意，容器也可以配置为作为[Systemd 服务](https://attack.mitre.org/techniques/T1543/002)运行。(引用: Podman Systemd)(引用: Docker Systemd) |
| [T1546](../techniques/T1546.md) | 事件触发执行 | 对手可能会使用基于特定事件触发执行的系统机制来建立持久性和/或提升权限。各种操作系统都有监视和订阅事件（例如登录或运行特定应用程序/二进制文件等用户活动）的手段。云环境还可能支持各种功能和服务，这些功能和服务可以监视并响应特定的云事件。(引用: Backdooring an AWS account)(引用: Varonis Power Automate Data Exfiltration)(引用: Microsoft DART Case Report 001)  对手可能会滥用这些机制，作为通过重复执行恶意代码来保持对受害者的持久访问的一种手段。在获得受害者系统访问权限后，对手可能会创建/修改事件触发器以指向将在调用事件触发器时执行的恶意内容。(引用: FireEye WMI 2015)(引用: Malware Persistence on OS X)(引用: amnesia malware)  由于执行可以由具有更高权限的账户（例如 SYSTEM 或服务账户）代理，因此对手可能会滥用这些触发的执行机制来提升其权限。 |
| [T1546.001](../techniques/T1546.001.md) | 更改默认文件关联 | 对手可能通过执行由文件类型关联触发的恶意内容来建立持久性。当打开文件时，会检查用于打开文件的默认程序（也称为文件关联或处理程序）。文件关联选择存储在Windows注册表中，可以由用户、管理员或具有注册表访问权限的程序编辑，或者由管理员使用内置的assoc实用程序编辑。(引用: Microsoft Change Default Programs)(引用: Microsoft File Handlers)(引用: Microsoft Assoc Oct 2017) 应用程序可以修改给定文件扩展名的文件关联，以在打开具有给定扩展名的文件时调用任意程序。  系统文件关联列在<code>HKEY_CLASSES_ROOT\.[extension]</code>下，例如<code>HKEY_CLASSES_ROOT\.txt</code>。这些条目指向位于<code>HKEY_CLASSES_ROOT\\[handler]</code>的处理程序。然后，各种命令列为shell键下的子键，位于<code>HKEY_CLASSES_ROOT\\[handler]\shell\\[action]\command</code>。例如：  * <code>HKEY_CLASSES_ROOT\txtfile\shell\open\command</code> * <code>HKEY_CLASSES_ROOT\txtfile\shell\print\command</code> * <code>HKEY_CLASSES_ROOT\txtfile\shell\printto\command</code>  列出的键值是处理程序打开文件扩展名时执行的命令。对手可以修改这些值以持续执行任意命令。(引用: TrendMicro TROJ-FAKEAV OCT 2012) |
| [T1546.002](../techniques/T1546.002.md) | 屏幕保护程序 | 对手可能通过执行由用户不活动触发的恶意内容来建立持久性。屏幕保护程序是在用户不活动的可配置时间后执行的程序，由具有.scr文件扩展名的可移植可执行文件（PE）组成。(引用: Wikipedia Screensaver) Windows屏幕保护程序应用程序scrnsave.scr位于<code>C:\Windows\System32\</code>和64位Windows系统上的<code>C:\Windows\sysWOW64\</code>，以及基本Windows安装中包含的屏幕保护程序。  以下屏幕保护程序设置存储在注册表中（<code>HKCU\Control Panel\Desktop\</code>），可以被操纵以实现持久性：  * <code>SCRNSAVE.exe</code> - 设置为恶意PE路径 * <code>ScreenSaveActive</code> - 设置为'1'以启用屏幕保护程序 * <code>ScreenSaverIsSecure</code> - 设置为'0'以不要求密码解锁 * <code>ScreenSaveTimeout</code> - 设置用户不活动超时以执行屏幕保护程序  对手可以使用屏幕保护程序设置通过在用户不活动的某个时间后运行恶意软件来保持持久性。(引用: ESET Gazer Aug 2017) |
| [T1546.003](../techniques/T1546.003.md) | Windows 管理规范事件订阅 | 对手可能会通过执行由 Windows 管理规范 (WMI) 事件订阅触发的恶意内容来建立持久性和提升权限。WMI 可用于安装事件过滤器、提供程序、消费者和绑定，当定义的事件发生时执行代码。可能订阅的事件示例包括时钟时间、用户登录或计算机的运行时间。(引用: Mandiant M-Trends 2015)  对手可能会利用 WMI 的功能订阅事件，并在事件发生时执行任意代码，从而在系统上提供持久性。(引用: FireEye WMI SANS 2015)(引用: FireEye WMI 2015) 对手还可以使用 `mofcomp.exe` 将 WMI 脚本编译成 Windows 管理对象 (MOF) 文件（.mof 扩展名），这些文件可用于创建恶意订阅。(引用: Dell WMI Persistence)(引用: Microsoft MOF May 2018)  WMI 订阅执行由 WMI 提供程序主机进程 (WmiPrvSe.exe) 代理，因此可能会导致提升的 SYSTEM 权限。 |
| [T1546.004](../techniques/T1546.004.md) | Unix Shell 配置修改 | 对手可能通过执行由用户的 shell 触发的恶意命令来建立持久性。用户[Unix Shell](https://attack.mitre.org/techniques/T1059/004)在会话的不同点执行几个配置脚本，基于事件。例如，当用户打开命令行界面或远程登录（例如通过 SSH）时，会启动登录 shell。登录 shell 从系统 (<code>/etc</code>) 和用户的主目录 (<code>~/</code>) 执行脚本以配置环境。系统上的所有登录 shell 都使用 /etc/profile 启动。这些配置脚本以其目录的权限级别运行，通常用于设置环境变量、创建别名和自定义用户的环境。当 shell 退出或终止时，将执行其他 shell 脚本以确保 shell 正常退出。  对手可能会尝试通过将命令插入到 shell 自动执行的脚本中来建立持久性。以 bash 为例，大多数 GNU/Linux 系统的默认 shell，对手可能会将启动恶意二进制文件的命令添加到 <code>/etc/profile</code> 和 <code>/etc/profile.d</code> 文件中。(引用: intezer-kaiji-malware)(引用: bencane blog bashrc) 这些文件通常需要 root 权限才能修改，并且每次系统上的任何 shell 启动时都会执行。对于用户级权限，对手可以将恶意命令插入 <code>~/.bash_profile</code>、<code>~/.bash_login</code> 或 <code>~/.profile</code>，这些命令在用户打开命令行界面或远程连接时会被调用。(引用: anomali-rocke-tactics)(引用: Linux manual bash invocation) 由于系统仅执行列表顺序中的第一个现有文件，因此对手使用 <code>~/.bash_profile</code> 来确保执行。对手还利用 <code>~/.bashrc</code> 文件，如果连接是远程建立的或打开了额外的交互式 shell（例如命令行界面中的新选项卡），则会额外执行。(引用: Tsunami)(引用: anomali-rocke-tactics)(引用: anomali-linux-rabbit)(引用: Magento) 一些恶意软件在程序终止时触发执行，对手可以使用 <code>~/.bash_logout</code> 文件在会话结束时执行恶意命令。  对于 macOS，此技术的功能类似，但可能利用 zsh，这是 macOS 10.15+ 的默认 shell。当打开 Terminal.app 时，应用程序会启动 zsh 登录 shell 和 zsh 交互式 shell。登录 shell 使用 <code>/etc/profile</code>、<code>/etc/zshenv</code>、<code>/etc/zprofile</code> 和 <code>/etc/zlogin</code> 配置系统环境。(引用: ScriptingOSX zsh)(引用: PersistentJXA_leopitt)(引用: code_persistence_zsh)(引用: macOS MS office sandbox escape) 然后，登录 shell 使用 <code>~/.zprofile</code> 和 <code>~/.zlogin</code> 配置用户环境。交互式 shell 使用 <code>~/.zshrc</code> 配置用户环境。退出时，执行 <code>/etc/zlogout</code> 和 <code>~/.zlogout</code>。对于旧版程序，macOS 在启动时执行 <code>/etc/bashrc</code>。 |
| [T1546.005](../techniques/T1546.005.md) | 陷阱 | 对手可能通过执行由中断信号触发的恶意内容来建立持久性。<code>trap</code> 命令允许程序和 shell 指定在收到中断信号时将执行的命令。一个常见的情况是脚本允许优雅终止和处理常见的键盘中断，如 <code>ctrl+c</code> 和 <code>ctrl+d</code>。  对手可以使用此命令注册代码，以便在 shell 遇到特定中断时执行，作为持久性机制。陷阱命令的格式为 <code>trap '命令列表' 信号</code>，其中“命令列表”将在收到“信号”时执行。（引用：Trap 手册）（引用：Cyberciti Trap 语句） |
| [T1546.006](../techniques/T1546.006.md) | LC_LOAD_DYLIB 添加 | 对手可能通过执行受污染二进制文件触发的恶意内容来建立持久性。Mach-O 二进制文件有一系列头文件，用于在加载二进制文件时执行某些操作。Mach-O 二进制文件中的 LC_LOAD_DYLIB 头告诉 macOS 和 OS X 在执行时加载哪些动态库 (dylibs)。只要对其余字段和依赖项进行调整，这些可以随时添加到已编译的二进制文件中。(引用: Writing Bad Malware for OSX) 有工具可用于执行这些更改。  对手可能会修改 Mach-O 二进制文件头以在每次执行二进制文件时加载和执行恶意 dylibs。虽然任何更改都会使二进制文件上的数字签名失效，因为二进制文件正在被修改，但这可以通过简单地从二进制文件中删除 LC_CODE_SIGNATURE 命令来解决，以便在加载时不检查签名。(引用: Malware Persistence on OS X) |
| [T1546.007](../techniques/T1546.007.md) | Netsh Helper DLL | 对手可能通过执行由Netsh Helper DLL触发的恶意内容来建立持久性。Netsh.exe（也称为Netshell）是一个命令行脚本实用程序，用于与系统的网络配置交互。它包含添加帮助DLL以扩展实用程序功能的功能。(引用: TechNet Netsh) 注册的netsh.exe帮助DLL的路径输入到Windows注册表中的<code>HKLM\SOFTWARE\Microsoft\Netsh</code>。  对手可以使用netsh.exe帮助DLL以持久的方式触发任意代码的执行。此执行将在每次执行netsh.exe时发生，这可能会自动发生，使用另一种持久性技术，或者如果系统上存在其他软件（例如VPN），该软件在其正常功能的一部分中执行netsh.exe。(引用: Github Netsh Helper CS Beacon)(引用: Demaske Netsh Persistence) |
| [T1546.008](../techniques/T1546.008.md) | 辅助功能 | 对手可能会通过执行由辅助功能触发的恶意内容来建立持久性和/或提升权限。Windows 包含辅助功能，可以在用户登录之前通过按键组合启动（例如：当用户在 Windows 登录屏幕上时）。对手可以修改这些程序的启动方式，以在不登录系统的情况下获得命令提示符或后门。  两个常见的辅助程序是<code>C:\Windows\System32\sethc.exe</code>，按下五次 Shift 键时启动，以及<code>C:\Windows\System32\utilman.exe</code>，按下 Windows + U 键组合时启动。sethc.exe 程序通常称为“粘滞键”，对手已使用它通过远程桌面登录屏幕进行未经身份验证的访问。(引用: FireEye Hikit Rootkit)  根据 Windows 的版本，对手可能会以不同方式利用这些功能。对手常用的方法包括替换辅助功能二进制文件或注册表中指向这些二进制文件的指针/引用。在较新的 Windows 版本中，替换的二进制文件需要为 x64 系统进行数字签名，二进制文件必须位于<code>%systemdir%\</code>，并且必须受 Windows 文件或资源保护 (WFP/WRP) 保护。(引用: DEFCON2016 Sticky Keys) 可能发现[图像文件执行选项注入](https://attack.mitre.org/techniques/T1546/012)调试器方法作为一种潜在的解决方法，因为它不需要替换相应的辅助功能二进制文件。  对于 Windows XP 及更高版本以及 Windows Server 2003/R2 及更高版本上的简单二进制替换，例如，可以将程序（例如<code>C:\Windows\System32\utilman.exe</code>）替换为“cmd.exe”（或提供后门访问的其他程序）。随后，在登录屏幕上按下适当的键组合时，无论是坐在键盘前还是通过[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)连接，都将导致以 SYSTEM 权限执行替换的文件。(引用: Tilbury 2014)  还存在其他辅助功能，可能以类似方式被利用：(引用: DEFCON2016 Sticky Keys)(引用: Narrator Accessibility Abuse)  * 屏幕键盘：<code>C:\Windows\System32\osk.exe</code> * 放大镜：<code>C:\Windows\System32\Magnify.exe</code> * 讲述人：<code>C:\Windows\System32\Narrator.exe</code> * 显示切换器：<code>C:\Windows\System32\DisplaySwitch.exe</code> * 应用切换器：<code>C:\Windows\System32\AtBroker.exe</code> |
| [T1546.009](../techniques/T1546.009.md) | AppCert DLLs | 对手可能通过执行由 AppCert DLLs 触发的恶意内容来建立持久性和/或提升权限。在 <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\</code> 下的 <code>AppCertDLLs</code> 注册表项中指定的动态链接库 (DLL) 会加载到每个调用广泛使用的应用程序编程接口 (API) 函数 <code>CreateProcess</code>、<code>CreateProcessAsUser</code>、<code>CreateProcessWithLoginW</code>、<code>CreateProcessWithTokenW</code> 或 <code>WinExec</code> 的进程中。(引用: Elastic Process Injection July 2017)  类似于 [进程注入](https://attack.mitre.org/techniques/T1055)，可以滥用此值通过在计算机上的单独进程上下文中加载和运行恶意 DLL 来获得提升的权限。恶意 AppCert DLLs 还可以通过 API 活动不断触发来提供持久性。 |
| [T1546.010](../techniques/T1546.010.md) | AppInit DLLs | 对手可能通过执行由AppInit DLLs加载到进程中的恶意内容来建立持久性和/或提升权限。指定在注册表键<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</code>或<code>HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows</code>中的<code>AppInit_DLLs</code>值的动态链接库（DLL）由user32.dll加载到每个加载user32.dll的进程中。实际上，这几乎是每个程序，因为user32.dll是一个非常常见的库。(引用: Elastic Process Injection July 2017)  类似于进程注入，这些值可以被滥用，通过导致恶意DLL被加载并在计算机上的单独进程上下文中运行来获得提升的权限。(引用: AppInit Registry) 恶意AppInit DLLs还可以通过API活动的持续触发提供持久性。  在启用安全启动的情况下，AppInit DLL功能在Windows 8及更高版本中被禁用。(引用: AppInit Secure Boot) |
| [T1546.011](../techniques/T1546.011.md) | 应用程序填充 | 对手可能会通过执行由应用程序填充触发的恶意内容来建立持久性和/或提升权限。Microsoft Windows应用程序兼容性基础设施/框架（应用程序填充）是为了允许随着操作系统代码库的变化而保持软件的向后兼容性而创建的。例如，应用程序填充功能允许开发人员应用修复程序（无需重写代码）到为Windows XP创建的应用程序，使其能够在Windows 10上运行。(引用: Elastic Process Injection July 2017)  在框架内，填充被创建为在程序（或更具体地说，导入地址表）和Windows操作系统之间充当缓冲。当程序执行时，填充缓存会被引用，以确定程序是否需要使用填充数据库（.sdb）。如果需要，填充数据库使用挂钩重定向代码，以便与操作系统通信。  默认Windows安装程序（sdbinst.exe）安装的所有填充的列表保存在：  * <code>%WINDIR%\AppPatch\sysmain.sdb</code> 和 * <code>hklm\software\microsoft\windows nt\currentversion\appcompatflags\installedsdb</code>  自定义数据库存储在：  * <code>%WINDIR%\AppPatch\custom & %WINDIR%\AppPatch\AppPatch64\Custom</code> 和 * <code>hklm\software\microsoft\windows nt\currentversion\appcompatflags\custom</code>  为了保持填充的安全性，Windows设计它们在用户模式下运行，因此它们不能修改内核，并且必须具有管理员权限才能安装填充。然而，某些填充可以用于[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)（UAC和RedirectEXE）、注入DLL到进程（InjectDLL）、禁用数据执行保护（DisableNX）和结构异常处理（DisableSEH），以及拦截内存地址（GetProcAddress）。  利用这些填充可能允许对手执行多种恶意行为，例如提升权限、安装后门、禁用防御（如Windows Defender）等。(引用: FireEye Application Shimming) 填充还可以被滥用以通过受影响的程序持续调用来建立持久性。 |
| [T1546.012](../techniques/T1546.012.md) | 图像文件执行选项注入 | 对手可能会通过执行由图像文件执行选项 (IFEO) 调试器触发的恶意内容来建立持久性和/或提升权限。IFEO 使开发人员能够将调试器附加到应用程序。当创建进程时，应用程序的 IFEO 中存在的调试器将被预先添加到应用程序的名称中，有效地在调试器下启动新进程（例如 <code>C:\dbg\ntsd.exe -g notepad.exe</code>）。(引用: Microsoft Dev Blog IFEO Mar 2010)  IFEO 可以直接通过注册表或通过 GFlags 工具在全局标志中设置。(引用: Microsoft GFlags Mar 2017) IFEO 在注册表中表示为 <code>HKLM\SOFTWARE{\Wow6432Node}\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<executable></code> 下的 <code>Debugger</code> 值，其中 <code>&lt;executable&gt;</code> 是附加调试器的二进制文件。(引用: Microsoft Dev Blog IFEO Mar 2010)  IFEO 还可以启用在指定程序静默退出（即由其自身或第二个非内核模式进程过早终止）时启动任意监视程序。(引用: Microsoft Silent Process Exit NOV 2017)(引用: Oddvar Moe IFEO APR 2018) 类似于调试器，可以通过 GFlags 和/或直接修改 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\</code> 中的 IFEO 和静默进程退出注册表值来启用静默退出监视。(引用: Microsoft Silent Process Exit NOV 2017)(引用: Oddvar Moe IFEO APR 2018)  类似于[辅助功能](https://attack.mitre.org/techniques/T1546/008)，在 Windows Vista 及更高版本以及 Windows Server 2008 及更高版本上，可以修改注册表项，将“cmd.exe”或提供后门访问的其他程序配置为辅助程序（例如 utilman.exe）的“调试器”。修改注册表后，在键盘上或通过[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)连接时按下登录屏幕上的适当键组合将导致以 SYSTEM 权限执行“调试器”程序。(引用: Tilbury 2014)  类似于[进程注入](https://attack.mitre.org/techniques/T1055)，这些值也可能被滥用，通过导致在计算机上的单独进程上下文中加载和运行恶意可执行文件来获得权限提升。(引用: Elastic Process Injection July 2017) 安装 IFEO 机制还可以通过持续触发调用提供持久性。  恶意软件还可能使用 IFEO 通过注册无效调试器来[削弱防御](https://attack.mitre.org/techniques/T1562)，这些调试器会重定向并有效地禁用各种系统和安全应用程序。(引用: FSecure Hupigon)(引用: Symantec Ushedix June 2008) |
| [T1546.013](../techniques/T1546.013.md) | PowerShell 配置文件 | 对手可能通过执行由 PowerShell 配置文件触发的恶意内容来获得持久性和提升权限。PowerShell 配置文件 (<code>profile.ps1</code>) 是一个在 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 启动时运行的脚本，可以用作登录脚本来自定义用户环境。  [PowerShell](https://attack.mitre.org/techniques/T1059/001) 支持根据用户或主机程序的不同而有多个配置文件。例如，不同的 PowerShell 主机程序（如 PowerShell 控制台、PowerShell ISE 或 Visual Studio Code）可以有不同的配置文件。管理员还可以配置一个适用于本地计算机上所有用户和主机程序的配置文件。(引用: Microsoft About Profiles)   对手可能会修改这些配置文件以包含任意命令、函数、模块和/或 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 驱动器以获得持久性。每次用户打开 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 会话时，修改后的脚本将被执行，除非在启动时使用 <code>-NoProfile</code> 标志。(引用: ESET Turla PowerShell May 2019)   如果具有更高权限的帐户（如域管理员）加载并执行 PowerShell 配置文件中的脚本，对手还可能能够提升权限。(引用: Wits End and Shady PowerShell Profiles) |
| [T1546.014](../techniques/T1546.014.md) | Emond | 对手可能通过执行由事件监视器守护进程（emond）触发的恶意内容来获得持久性和提升权限。Emond是一个[启动守护程序](https://attack.mitre.org/techniques/T1543/004)，接受来自各种服务的事件，通过简单的规则引擎运行它们，并采取行动。位于<code>/sbin/emond</code>的emond二进制文件将加载<code>/etc/emond.d/rules/</code>目录中的任何规则，并在明确定义的事件发生时采取行动。  规则文件采用plist格式，定义名称、事件类型和采取的行动。一些事件类型的示例包括系统启动和用户认证。操作的示例是运行系统命令或发送电子邮件。如果在<code>/private/var/db/emondClients</code>路径中没有文件存在，则emond服务不会启动，该路径在[启动守护程序](https://attack.mitre.org/techniques/T1543/004)配置文件<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>中指定。(引用: xorrior emond Jan 2018)(引用: magnusviri emond Apr 2016)(引用: sentinelone macos persist Jun 2019)  对手可能通过编写规则在定义的事件发生时执行命令来滥用此服务，例如系统启动或用户认证。(引用: xorrior emond Jan 2018)(引用: magnusviri emond Apr 2016)(引用: sentinelone macos persist Jun 2019) 对手还可能通过emond服务从管理员提升到root权限，因为emond服务由[启动守护程序](https://attack.mitre.org/techniques/T1543/004)服务以root权限执行。 |
| [T1546.015](../techniques/T1546.015.md) | 组件对象模型劫持 | 对手可能通过劫持对组件对象模型 (COM) 对象的引用来执行恶意内容，从而建立持久性。COM 是 Windows 中的一个系统，用于通过操作系统实现软件组件之间的交互。(引用: Microsoft Component Object Model) 各种 COM 对象的引用存储在注册表中。  对手可以使用 COM 系统插入恶意代码，通过劫持 COM 引用和关系来执行恶意软件，以实现持久性。劫持 COM 对象需要更改注册表以替换对合法系统组件的引用，这可能导致该组件在执行时无法正常工作。当通过正常系统操作执行该系统组件时，对手的代码将被执行。(引用: GDATA COM Hijacking) 对手可能会劫持频繁使用但不太可能破坏系统稳定性的对象，以保持一致的持久性水平，同时避免导致检测的系统不稳定。 |
| [T1546.016](../techniques/T1546.016.md) | 安装包 | 对手可能会使用安装程序触发恶意内容的执行来建立持久性和提升权限。安装包是特定于操作系统的，包含操作系统在系统上安装应用程序所需的资源。安装包可以包括在安装前运行的脚本以及安装完成后运行的脚本。安装脚本在执行时可能继承提升的权限。开发人员通常使用这些脚本来准备安装环境、检查要求、下载依赖项和在安装后删除文件。(引用: Installer Package Scripting Rich Trouton)  使用合法应用程序，对手已经分发了带有修改安装脚本的应用程序以执行恶意内容。当用户安装应用程序时，他们可能需要授予管理权限以允许安装。在合法应用程序安装过程结束时，内容如macOS的`postinstall`脚本可以以继承的提升权限执行。对手可以使用这些脚本执行恶意可执行文件或安装其他恶意组件（如[启动守护程序](https://attack.mitre.org/techniques/T1543/004)）以提升权限。(引用: Application Bundle Manipulation Brandon Dalton)(引用: wardle evilquest parti)(引用: Windows AppleJeus GReAT)(引用: Debian Manual Maintainer Scripts)  根据发行版，Linux版本的安装包脚本有时称为维护脚本或安装后脚本。这些脚本可以包括`preinst`、`postinst`、`prerm`、`postrm`脚本，并在执行时以root身份运行。  对于Windows，Microsoft Installer服务使用`.msi`文件管理应用程序的安装、更新和卸载。这些安装例程也可能包括执行额外操作的指令，可能被对手滥用。(引用: Microsoft Installation Procedures) |
| [T1546.017](../techniques/T1546.017.md) | Udev规则 | 对手可能通过使用udev规则执行恶意内容来保持持久性。Udev是Linux内核设备管理器，动态管理设备节点，处理/dev目录中的伪设备文件访问，并响应硬件事件，例如插入或移除外部设备如硬盘或键盘。Udev使用带有“匹配键”的规则文件来指定硬件事件必须满足的条件，并使用“动作键”来定义应执行的操作。创建、修改或删除位于/etc/udev/rules.d/、/run/udev/rules.d/、/usr/lib/udev/rules.d/、/usr/local/lib/udev/rules.d/和/lib/udev/rules.d/中的规则文件需要root权限。规则优先级由目录和规则文件名中的数字前缀决定。(引用: Ignacio Udev research 2024)(引用: Elastic Linux Persistence 2024)  对手可能通过在udev规则文件中添加或修改规则来滥用udev子系统以执行恶意内容。例如，对手可能配置一个规则，每次应用程序访问伪设备文件（如/dev/random）时执行其二进制文件。尽管udev仅限于运行短任务，并受systemd-udevd的沙箱限制（阻止网络和文件系统访问），攻击者可能使用动作键RUN+=下的脚本命令在后台分离并运行恶意内容的进程，以绕过这些控制。(引用: Reichert aon sedexp 2024) |
| [T1547](../techniques/T1547.md) | 启动或登录自动启动执行 | 对手可能会配置系统设置，以在系统启动或登录时自动执行程序，以保持持久性或在受感染系统上获得更高的权限。操作系统可能有机制在系统启动或账户登录时自动运行程序。(引用: Microsoft Run Key)(引用: MSDN Authentication Packages)(引用: Microsoft TimeProvider)(引用: Cylance Reg Persistence Sept 2013)(引用: Linux Kernel Programming) 这些机制可能包括自动执行放置在特别指定目录中的程序，或由存储配置信息的存储库引用的程序，例如Windows注册表。对手可能通过修改或扩展内核功能来实现相同的目标。  由于某些启动或登录自动启动程序以更高的权限运行，对手可能会利用这些来提升权限。 |
| [T1547.001](../techniques/T1547.001.md) | 注册表运行键/启动文件夹 | 对手可能通过将程序添加到启动文件夹或使用注册表运行键引用它来实现持久性。在注册表或启动文件夹中添加条目将导致引用的程序在用户登录时执行。(引用: Microsoft Run Key) 这些程序将在用户的上下文中执行，并具有该账户的相关权限级别。  在Windows系统上默认创建以下运行键：  * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>  运行键可能存在于多个配置单元下。(引用: Microsoft Wow6432Node 2018)(引用: Malwarebytes Wow6432Node 2016) <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code> 也可用，但在Windows Vista及更高版本上默认未创建。注册表运行键条目可以直接引用程序或将其列为依赖项。(引用: Microsoft Run Key) 例如，可以使用RunOnceEx的“Depend”键在登录时加载DLL：<code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "C:\temp\evil[.]dll"</code> (引用: Oddvar Moe RunOnceEx Mar 2018)  将程序放置在启动文件夹中也会导致该程序在用户登录时执行。每个用户账户都有一个启动文件夹位置，以及一个系统范围的启动文件夹，无论哪个用户账户登录都会检查。当前用户的启动文件夹路径是<code>C:\Users\\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>。所有用户的启动文件夹路径是<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>。  以下注册表键可用于设置启动文件夹项以实现持久性：  * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code> * <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code> * <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code>  以下注册表键可以控制启动期间服务的自动启动：  * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</code>  使用策略设置指定启动程序会在以下两个注册表键中创建相应的值：  * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code>  列在注册表键<code>HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows</code>的加载值中的程序会自动为当前登录的用户运行。  默认情况下，注册表键<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager</code>的多字符串<code>BootExecute</code>值设置为<code>autocheck autochk *</code>。此值会导致Windows在启动时检查硬盘的文件系统完整性，如果系统异常关闭。对手可以将其他程序或进程添加到此注册表值中，这些程序或进程将在启动时自动启动。  对手可以使用这些配置位置来执行恶意软件，例如远程访问工具，以在系统重启时保持持久性。对手还可以使用[伪装](https://attack.mitre.org/techniques/T1036)使注册表条目看起来与合法程序相关。 |
| [T1547.002](../techniques/T1547.002.md) | 认证包 | 对手可能会滥用认证包在系统启动时执行DLL。Windows认证包DLL由本地安全机构（LSA）进程在系统启动时加载。它们为操作系统提供对多个登录进程和多个安全协议的支持。(引用: MSDN Authentication Packages)  对手可以使用LSA认证包提供的自动启动机制，通过在Windows注册表位置<code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\</code>中放置一个指向二进制文件的引用，并将键值设置为<code>"Authentication Packages"=&lt;target binary&gt;</code>来实现持久性。然后，当加载认证包时，系统将执行该二进制文件。 |
| [T1547.003](../techniques/T1547.003.md) | 时间提供者 | 对手可能会滥用时间提供者在系统启动时执行 DLL。Windows 时间服务 (W32Time) 使域内和域间的时间同步成为可能。（引用：Microsoft W32Time 2018 年 2 月）W32Time 时间提供者负责从硬件/网络资源检索时间戳并将这些值输出到其他网络客户端。（引用：Microsoft TimeProvider）  时间提供者实现为动态链接库 (DLL)，注册在 `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W32Time\TimeProviders\` 的子键中。（引用：Microsoft TimeProvider）时间提供者管理器由服务控制管理器指挥，在系统启动时和/或参数更改时加载并启动在此键下列出并启用的时间提供者。（引用：Microsoft TimeProvider）  对手可能会滥用此架构来建立持久性，具体方法是创建一个新的任意命名的子键，指向 `DllName` 值中的恶意 DLL。时间提供者注册需要管理员权限，但执行将在本地服务帐户的上下文中运行。（引用：Github W32Time 2017 年 10 月） |
| [T1547.004](../techniques/T1547.004.md) | Winlogon 助手 DLL | 对手可能会滥用 Winlogon 的功能，在用户登录时执行 DLL 和/或可执行文件。Winlogon.exe 是一个 Windows 组件，负责登录/注销时的操作以及由 Ctrl-Alt-Delete 触发的安全注意序列 (SAS)。<code>HKLM\Software[\\Wow6432Node\\]\Microsoft\Windows NT\CurrentVersion\Winlogon\</code> 和 <code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\</code> 中的注册表项用于管理支持 Winlogon 的其他助手程序和功能。(引用: Cylance Reg Persistence Sept 2013)  对这些注册表项的恶意修改可能会导致 Winlogon 加载并执行恶意 DLL 和/或可执行文件。具体来说，以下子键可能容易被滥用：(引用: Cylance Reg Persistence Sept 2013)  * Winlogon\Notify - 指向处理 Winlogon 事件的通知包 DLL * Winlogon\Userinit - 指向 userinit.exe，用户登录时执行的用户初始化程序 * Winlogon\Shell - 指向 explorer.exe，用户登录时执行的系统 shell  对手可能会利用这些功能反复执行恶意代码并建立持久性。 |
| [T1547.005](../techniques/T1547.005.md) | 安全支持提供者 | 对手可能会滥用安全支持提供者 (SSP) 在系统启动时执行 DLL。Windows SSP DLL 在系统启动时加载到本地安全机构 (LSA) 进程中。一旦加载到 LSA 中，SSP DLL 就可以访问存储在 Windows 中的加密和明文密码，例如任何登录用户的域密码或智能卡 PIN。  SSP 配置存储在两个注册表项中：<code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code> 和 <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\Security Packages</code>。对手可能会修改这些注册表项以添加新的 SSP，这些 SSP 将在系统下次启动时加载，或者在调用 AddSecurityPackage Windows API 函数时加载。(引用: Graeber 2014) |
| [T1547.006](../techniques/T1547.006.md) | 内核模块和扩展 | 对手可能会修改内核以在系统启动时自动执行程序。可加载内核模块（LKM）是可以按需加载和卸载到内核中的代码片段。它们扩展了内核的功能，而无需重新启动系统。例如，一种类型的模块是设备驱动程序，它允许内核访问连接到系统的硬件。(引用: Linux Kernel Programming)  恶意使用时，LKM可以是一种内核模式[Rootkit](https://attack.mitre.org/techniques/T1014)，以最高的操作系统权限（Ring 0）运行。(引用: Linux Kernel Module Programming Guide) LKM基于rootkit的常见功能包括：隐藏自身、选择性隐藏文件、进程和网络活动，以及日志篡改、提供认证的后门，并使非特权用户能够获得root访问权限。(引用: iDefense Rootkit Overview)  内核扩展，也称为kext，在macOS中用于加载功能，类似于Linux的LKM。由于内核负责执行安全性，并且内核扩展作为内核的一部分运行，因此kext不受macOS安全策略的约束。kext通过<code>kextload</code>和<code>kextunload</code>命令加载和卸载。kext需要使用开发者ID签名，该ID由Apple授予权限，允许其签名内核扩展。没有这些权限的开发者仍然可以签名kext，但除非禁用SIP，否则它们不会加载。如果启用了SIP，则在将kext添加到AuxKC之前会验证其签名。(引用: System and kernel extensions in macOS)  自macOS Catalina 10.15以来，内核扩展已被弃用，取而代之的是系统扩展。然而，kext仍然被允许作为“遗留系统扩展”，因为没有用于内核编程接口的系统扩展。(引用: Apple Kernel Extension Deprecation)  对手可以使用LKM和kext在系统上进行[持久性](https://attack.mitre.org/tactics/TA0003)和/或[权限提升](https://attack.mitre.org/tactics/TA0004)。在野外已经发现了一些示例，并且也有一些相关的开源项目。(引用: Volatility Phalanx2)(引用: CrowdStrike Linux Rootkit)(引用: GitHub Reptile)(引用: GitHub Diamorphine)(引用: RSAC 2015 San Francisco Patrick Wardle)(引用: Synack Secure Kernel Extension Broken)(引用: Securelist Ventir)(引用: Trend Micro Skidmap) |
| [T1547.007](../techniques/T1547.007.md) | 重新打开的应用程序 | 攻击者可能会修改plist文件以在用户登录时自动运行应用程序。当用户通过macOS图形用户界面（GUI）注销或重启时，系统会向用户提供一个提示，其中包含一个复选框“在重新登录时重新打开窗口”。(引用: Mac重新打开窗口) 当选中时，所有当前打开的应用程序都会添加到<code>~/Library/Preferences/ByHost</code>目录中名为<code>com.apple.loginwindow.[UUID].plist</code>的属性列表文件中。(引用: Mac恶意软件持久性方法)(引用: Wardle持久性章节) 列在此文件中的应用程序将在用户下次登录时自动重新打开。  攻击者可以通过将恶意应用程序路径添加到<code>com.apple.loginwindow.[UUID].plist</code>文件中来建立[持久性](https://attack.mitre.org/tactics/TA0003)，以便在用户登录时执行负载。 |
| [T1547.008](../techniques/T1547.008.md) | LSASS驱动程序 | 攻击者可能修改或添加LSASS驱动程序以在受感染的系统上获得持久性。Windows安全子系统是一组管理和强制执行计算机或域安全策略的组件。本地安全机构（LSA）是负责本地安全策略和用户身份验证的主要组件。LSA包括与各种其他安全功能相关的多个动态链接库（DLL），所有这些都在LSA子系统服务（LSASS）lsass.exe进程的上下文中运行。(Citation: Microsoft Security Subsystem)  攻击者可能针对LSASS驱动程序以获得持久性。通过替换或添加非法驱动程序（例如，[Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)），攻击者可以使用LSA操作持续执行恶意负载。 |
| [T1547.009](../techniques/T1547.009.md) | 快捷方式修改 | 对手可能会创建或修改快捷方式，以便在系统启动或用户登录期间执行程序。快捷方式或符号链接用于引用其他文件或程序，当快捷方式被点击或由系统启动过程执行时，将打开或执行这些文件或程序。  对手可能会滥用启动文件夹中的快捷方式来执行他们的工具并实现持久性。(引用: Shortcut for Persistence) 虽然通常用作感染链中的有效负载（例如[鱼叉式网络钓鱼附件](https://attack.mitre.org/techniques/T1566/001)），对手也可能创建一个新的快捷方式作为间接手段，同时滥用[伪装](https://attack.mitre.org/techniques/T1036)使恶意快捷方式看起来像合法程序。对手还可以编辑目标路径或完全替换现有快捷方式，以便执行他们的恶意软件而不是预期的合法程序。  快捷方式还可以通过实现其他方法来滥用以建立持久性。例如，LNK 浏览器扩展可能会被修改（例如[浏览器扩展](https://attack.mitre.org/techniques/T1176)）以持久地启动恶意软件。 |
| [T1547.010](../techniques/T1547.010.md) | 端口监视器 | 对手可能会使用端口监视器在系统启动期间运行对手提供的DLL，以实现持久性或权限提升。可以通过<code>AddMonitor</code> API调用设置端口监视器，以设置在启动时加载的DLL。(引用: AddMonitor) 该DLL可以位于<code>C:\Windows\System32</code>中，并将在启动时由打印后台处理程序服务`spoolsv.exe`加载并运行，具有SYSTEM级别权限。(引用: Bloxham)  或者，如果权限允许写入DLL的完全限定路径名，则可以加载任意DLL到<code>HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors</code>的现有或新任意命名子键的`Driver`值。注册表项包含以下条目的条目：  * 本地端口 * 标准TCP/IP端口 * USB监视器 * WSD端口  |
| [T1547.012](../techniques/T1547.012.md) | 打印处理器 | 对手可能会滥用打印处理器，在系统启动期间运行恶意 DLL 以实现持久性和/或权限提升。打印处理器是由打印后台处理程序服务 `spoolsv.exe` 在启动期间加载的 DLL。(引用: Microsoft Intro Print Processors)  对手可能通过添加在启动时加载恶意 DLL 的打印处理器来滥用打印后台处理程序服务。可以通过具有 <code>SeLoadDriverPrivilege</code> 权限的帐户使用 <code>AddPrintProcessor</code> API 调用安装打印处理器。或者，可以通过添加指向 DLL 的 <code>HKLM\SYSTEM\\[CurrentControlSet or ControlSet001]\Control\Print\Environments\\[Windows architecture: e.g., Windows x64]\Print Processors\\[user defined]\Driver</code> 注册表项将打印处理器注册到打印后台处理程序服务。  为了正确安装恶意打印处理器，有效负载必须位于专用系统打印处理器目录中，可以通过 <code>GetPrintProcessorDirectory</code> API 调用找到该目录，或通过该目录的相对路径引用。(引用: Microsoft AddPrintProcessor May 2018) 安装打印处理器后，必须重新启动打印后台处理程序服务（在启动时启动），以便它们运行。(引用: ESET PipeMon May 2020)  打印后台处理程序服务在 SYSTEM 级别权限下运行，因此由对手安装的打印处理器可能在提升的权限下运行。 |
| [T1547.013](../techniques/T1547.013.md) | XDG自动启动条目 | 对手可能会添加或修改XDG自动启动条目，以在用户桌面环境加载时执行恶意程序或命令。XDG自动启动条目适用于任何符合XDG的Linux系统。XDG自动启动条目使用桌面条目文件(.desktop)配置用户的桌面环境在用户登录时加载。这些配置文件确定用户登录时启动的应用程序，定义打开特定文件类型的关联应用程序，并定义用于打开可移动媒体的应用程序。(引用: Free Desktop Application Autostart Feb 2006)(引用: Free Desktop Entry Keys)  对手可能会滥用此功能，通过将恶意二进制文件或命令的路径添加到.desktop配置文件中的Exec指令来建立持久性。当用户桌面环境在用户登录时加载时，位于XDG自动启动目录中的.desktop文件会自动执行。系统范围的自动启动条目位于/etc/xdg/autostart目录中，而用户条目位于~/.config/autostart目录中。  对手可能会将此技术与[伪装](https://attack.mitre.org/techniques/T1036)结合使用，以将恶意自动启动条目与合法程序混合。(引用: Red Canary Netwire Linux 2022) |
| [T1547.014](../techniques/T1547.014.md) | 活动设置 | 对手可能通过向本地计算机的活动设置添加注册表项来实现持久性。活动设置是一个Windows机制，用于在用户登录时执行程序。存储在注册表项中的值将在用户登录计算机后执行。(引用: Klein Active Setup 2010) 这些程序将在用户的上下文中执行，并具有账户的相关权限级别。  对手可能通过在<code> HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\</code>下创建一个键并为<code>StubPath</code>设置恶意值来滥用活动设置。此值将作为用户登录计算机时执行的程序。(引用: Mandiant Glyer APT 2010)(引用: Citizenlab Packrat 2015)(引用: FireEye CFR Watering Hole 2012)(引用: SECURELIST Bright Star 2015)(引用: paloalto Tropic Trooper 2016)  对手可以滥用这些组件来执行恶意软件，例如远程访问工具，以通过系统重启保持持久性。对手还可能使用[伪装](https://attack.mitre.org/techniques/T1036)使注册表项看起来像是与合法程序相关联。 |
| [T1547.015](../techniques/T1547.015.md) | 登录项 | 对手可能会添加登录项以在用户登录时执行，以获得持久性或提升权限。登录项是用户登录时自动启动的应用程序、文档、文件夹或服务器连接。(引用: Open Login Items Apple) 登录项可以通过共享文件列表或服务管理框架添加。(引用: Adding Login Items) 共享文件列表登录项可以使用脚本语言（如 [AppleScript](https://attack.mitre.org/techniques/T1059/002)）设置，而服务管理框架使用 API 调用 <code>SMLoginItemSetEnabled</code>。  使用服务管理框架安装的登录项利用 <code>launchd</code>，在系统偏好设置中不可见，并且只能由创建它们的应用程序删除。(引用: Adding Login Items)(引用: SMLoginItemSetEnabled Schroeder 2013) 使用共享文件列表创建的登录项在系统偏好设置中可见，可以在启动时隐藏应用程序，并通过 LaunchServices 而不是 launchd 执行，以打开应用程序、文档或 URL，而无需使用 Finder。(引用: Launch Services Apple Developer) 用户和应用程序使用登录项来配置其用户环境，以启动常用的服务或应用程序，例如电子邮件、聊天和音乐应用程序。  对手可以利用 [AppleScript](https://attack.mitre.org/techniques/T1059/002) 和 [Native API](https://attack.mitre.org/techniques/T1106) 调用创建登录项以生成恶意可执行文件。(引用: ELC Running at startup) 在 macOS 10.5 之前的版本中，对手可以使用 [AppleScript](https://attack.mitre.org/techniques/T1059/002) 向“系统事件”进程发送 Apple 事件来添加登录项，该进程具有用于操作登录项的 AppleScript 字典。(引用: Login Items AE) 对手可以使用命令 <code>tell application “System Events” to make login item at end with properties /path/to/executable</code>。(引用: Startup Items Eclectic)(引用: hexed osx.dok analysis 2019)(引用: Add List Remove Login Items Apple Script) 此命令将恶意可执行文件的路径添加到位于 <code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</code> 的登录项文件列表中。(引用: Startup Items Eclectic) 对手还可以使用登录项启动可用于远程控制受害者系统的可执行文件，或通过提示用户凭据来获得权限提升。(引用: objsee mac malware 2017)(引用: CheckPoint Dok)(引用: objsee netwire backdoor 2019) |
| [T1554](../techniques/T1554.md) | 妥协主机软件二进制文件 | 对手可能会修改主机软件二进制文件以在系统上建立持久访问。软件二进制文件/可执行文件提供了广泛的系统命令或服务、程序和库。常见的软件二进制文件包括SSH客户端、FTP客户端、电子邮件客户端、Web浏览器和许多其他用户或服务器应用程序。  对手可能通过修改主机软件二进制文件来建立持久性。例如，对手可能会替换或感染合法的应用程序二进制文件（或支持文件）以植入后门。由于这些二进制文件可能会被应用程序或用户例行执行，对手可以利用这一点在主机上保持持久访问。对手还可能修改软件二进制文件，如SSH客户端，以在登录期间持久收集凭证（即[修改认证过程](https://attack.mitre.org/techniques/T1556)）。(引用: Google Cloud Mandiant UNC3886 2024)  对手还可能通过在二进制文件的合法执行之前修补恶意功能（例如IAT Hooking/入口点修补）来修改现有二进制文件。(引用: Unit42 Banking Trojans Hooking 2022) 例如，对手可能会修改二进制文件的入口点，以指向对手修补的恶意代码，然后恢复正常的执行流程。(引用: ESET FontOnLake Analysis 2021)  在修改二进制文件后，对手可能会尝试通过阻止其更新（例如，通过Linux系统中使用yum包管理器的`yum-versionlock`命令或`versionlock.list`文件）来[削弱防御](https://attack.mitre.org/techniques/T1562)。(引用: Google Cloud Mandiant UNC3886 2024) |
| [T1556](../techniques/T1556.md) | 修改认证过程 | 对手可能会修改认证机制和过程，以访问用户凭据或启用其他不必要的账户访问。认证过程由负责收集、存储和验证凭据的机制处理，例如Windows上的本地安全认证服务器（LSASS）进程和安全账户管理器（SAM），Unix系统上的可插拔认证模块（PAM），以及MacOS系统上的授权插件。通过修改认证过程，对手可能能够在不使用[有效账户](https://attack.mitre.org/techniques/T1078)的情况下认证到服务或系统。  对手可能会恶意修改此过程的一部分，以揭示凭据或绕过认证机制。被破坏的凭据或访问可能用于绕过网络中系统上各种资源的访问控制，并可能用于对远程系统和外部可用服务（如VPN、Outlook Web Access和远程桌面）的持久访问。 |
| [T1556.001](../techniques/T1556.001.md) | 域控制器认证 | 对手可能会修补域控制器上的认证过程，以绕过典型的认证机制并启用对账户的访问。  恶意软件可能用于在域控制器的认证过程中注入虚假凭据，目的是创建一个后门，用于访问任何用户的账户和/或凭据（例如：[Skeleton Key](https://attack.mitre.org/software/S0007)）。Skeleton Key 通过修补企业域控制器认证过程（LSASS）来工作，对手可以使用这些凭据绕过标准认证系统。一旦修补，对手可以使用注入的密码成功认证为任何域用户账户（直到域控制器重启后 Skeleton Key 从内存中擦除）。认证访问可能在单因素认证环境中启用对主机和/或资源的不受限制的访问。(引用: Dell Skeleton) |
| [T1556.002](../techniques/T1556.002.md) | 密码过滤器 DLL | 对手可能会将恶意密码过滤器动态链接库 (DLL) 注册到身份验证过程中，以在验证用户凭据时获取这些凭据。  Windows 密码过滤器是用于域和本地账户的密码策略实施机制。过滤器实现为包含方法的 DLL，用于根据密码策略验证潜在密码。过滤器 DLL 可以放置在本地计算机上用于本地账户和/或域控制器上用于域账户。在将新密码注册到安全账户管理器 (SAM) 之前，本地安全机构 (LSA) 会请求每个注册过滤器的验证。任何潜在的更改在每个注册过滤器确认验证之前都不会生效。  对手可以注册恶意密码过滤器，从本地计算机和/或整个域中收集凭据。为了进行正确的验证，过滤器必须从 LSA 接收明文凭据。每次发出密码请求时，恶意密码过滤器都会接收这些明文凭据。(引用: Carnal Ownage Password Filters Sept 2013) |
| [T1556.003](../techniques/T1556.003.md) | 可插拔认证模块 | 对手可能会修改可插拔认证模块（PAM）以访问用户凭据或启用其他不必要的帐户访问。PAM是一个模块化的配置文件、库和可执行文件系统，用于指导许多服务的认证。最常见的认证模块是<code>pam_unix.so</code>，它在<code>/etc/passwd</code>和<code>/etc/shadow</code>中检索、设置和验证帐户认证信息。(引用: Apple PAM)(引用: Man Pam_Unix)(引用: Red Hat PAM)  对手可能会修改PAM系统的组件以创建后门。PAM组件（如<code>pam_unix.so</code>）可以被修补以接受对手提供的任意值作为合法凭据。(引用: PAM Backdoor)  对PAM系统的恶意修改也可能被滥用来窃取凭据。对手可能会感染PAM资源以收集用户凭据，因为与PAM组件交换的值可能是明文的，因为PAM不存储密码。(引用: PAM Creds)(引用: Apple PAM) |
| [T1556.004](../techniques/T1556.004.md) | 网络设备认证 | 对手可能使用[修补系统镜像](https://attack.mitre.org/techniques/T1601/001)在操作系统中硬编码密码，从而绕过网络设备本地账户的本机认证机制。  [修改系统镜像](https://attack.mitre.org/techniques/T1601)可能包括在网络设备的操作系统中植入代码，以便对手使用特定密码进行访问。修改包括通过修补在操作系统镜像中植入特定密码。认证尝试时，插入的代码将首先检查用户输入是否为密码。如果是，则授予访问权限。否则，植入的代码将传递凭据以验证可能有效的凭据。(引用: Mandiant - Synful Knock) |
| [T1556.005](../techniques/T1556.005.md) | 可逆加密 | 对手可能会滥用 Active Directory 认证加密属性，以获取 Windows 系统上的凭据。<code>AllowReversiblePasswordEncryption</code> 属性指定是否启用或禁用账户的可逆密码加密。默认情况下，此属性被禁用（而是将用户凭据存储为单向哈希函数的输出），除非需要遗留或其他软件，否则不应启用。(引用: store_pwd_rev_enc)  如果启用此属性和/或用户在启用后更改其密码，对手可能能够获取在启用此属性后创建/更改的密码的明文。要解密密码，对手需要四个组件：  1. 来自 Active Directory 用户结构 <code>userParameters</code> 的加密密码 (<code>G$RADIUSCHAP</code>) 2. 也是来自 <code>userParameters</code> 的 16 字节随机生成值 (<code>G$RADIUSCHAPKEY</code>) 3. 全局 LSA 密钥 (<code>G$MSRADIUSCHAPKEY</code>) 4. 硬编码在远程访问子认证 DLL (<code>RASSFM.DLL</code>) 中的静态密钥  有了这些信息，对手可能能够重现加密密钥，并随后解密加密的密码值。(引用: how_pwd_rev_enc_1)(引用: how_pwd_rev_enc_2)  对手可能通过本地组策略编辑器、用户属性、细粒度密码策略 (FGPP) 或通过 ActiveDirectory [PowerShell](https://attack.mitre.org/techniques/T1059/001) 模块在各种范围内设置此属性。例如，如果域功能级别设置为“Windows Server 2008”或更高，对手可能会实施并应用 FGPP 到用户或组。(引用: dump_pwd_dcsync) 在 PowerShell 中，对手可能使用类似 <code>Set-ADUser -AllowReversiblePasswordEncryption $true</code> 的命令对用户设置进行相关更改。 |
| [T1556.006](../techniques/T1556.006.md) | 多因素认证 | 对手可能会禁用或修改多因素认证 (MFA) 机制，以便对被破坏的账户进行持久访问。  一旦对手通过破坏缺乏 MFA 的账户或使用 MFA 绕过方法（例如[多因素认证请求生成](https://attack.mitre.org/techniques/T1621)）获得对网络的访问权限，对手可能会利用其访问权限修改或完全禁用 MFA 防御。这可以通过滥用合法功能来实现，例如将用户排除在 Azure AD 条件访问策略之外，注册新的但易受攻击/对手控制的 MFA 方法，或通过手动修补 MFA 程序和配置文件以绕过预期功能。(引用: Mandiant APT42)(引用: Azure AD 条件访问排除)  例如，修改 Windows 主机文件 (`C:\windows\system32\drivers\etc\hosts`) 以将 MFA 调用重定向到本地主机而不是 MFA 服务器，可能会导致 MFA 过程失败。如果存在“失败开放”策略，则任何其他成功的身份验证尝试可能会在不强制执行 MFA 的情况下被授予访问权限。(引用: 俄罗斯人利用默认 MFA 协议 - CISA 2022 年 3 月)  根据对手的范围、目标和权限，MFA 防御可能会针对单个账户或与更大组相关的所有账户（例如受害者网络环境中的所有域账户）被禁用。(引用: 俄罗斯人利用默认 MFA 协议 - CISA 2022 年 3 月) |
| [T1556.007](../techniques/T1556.007.md) | 混合身份 | 对手可能会修补、修改或以其他方式后门化与本地用户身份相关联的云身份验证过程，以绕过典型的身份验证机制、访问凭据并启用对账户的持久访问。  许多组织维护在本地和云环境之间共享的混合用户和设备身份。这些身份可以通过多种方式维护。例如，Microsoft Entra ID包括三种同步Active Directory和Entra ID之间身份的选项(引用: Azure AD Hybrid Identity)：  * 密码哈希同步（PHS），其中特权本地账户同步用户密码哈希值，使Entra ID的身份验证完全在云中进行 * 直通身份验证（PTA），其中Entra ID身份验证尝试被转发到本地PTA代理，该代理根据Active Directory验证凭据 * Active Directory联合服务（AD FS），其中在Active Directory和Entra ID之间建立信任关系  AD FS还可以与其他SaaS和云平台（如AWS和GCP）一起使用，这些平台将身份验证过程交给AD FS并接收包含混合用户身份和权限的令牌。  通过修改与混合身份相关的身份验证过程，对手可能能够建立对云资源的持久特权访问。例如，妥协运行PTA代理的本地服务器的对手可能会将恶意DLL注入`AzureADConnectAuthenticationAgentService`进程，该进程授权所有尝试对Entra ID进行身份验证的请求，并记录用户凭据。(引用: Azure AD Connect for Read Teamers)(引用: AADInternals Azure AD On-Prem to Cloud) 在使用AD FS的环境中，对手可能会编辑`Microsoft.IdentityServer.Servicehost`配置文件以加载生成任何用户的身份验证令牌的恶意DLL，从而绕过多因素认证和定义的AD FS策略。(引用: MagicWeb)  在某些情况下，对手可能能够从云端修改混合身份身份验证过程。例如，妥协Entra ID租户中的全局管理员账户的对手可能能够通过Web控制台注册新的PTA代理，从而允许他们收集凭据并以任何用户身份登录Entra ID环境。(引用: Mandiant Azure AD Backdoors) |
| [T1556.008](../techniques/T1556.008.md) | 网络提供程序 DLL | 对手可能会注册恶意的网络提供程序动态链接库 (DLL)，以在身份验证过程中捕获明文用户凭据。网络提供程序 DLL 允许 Windows 与特定网络协议接口，并且还可以支持附加的凭据管理功能。(引用: Network Provider API) 在登录过程中，Winlogon（交互式登录模块）通过 RPC 将凭据发送到本地的 `mpnotify.exe` 进程。`mpnotify.exe` 进程在通知发生登录事件时，将明文凭据与注册的凭据管理器共享。(引用: NPPSPY - Huntress)(引用: NPPSPY Video)(引用: NPLogonNotify)  对手可以配置恶意的网络提供程序 DLL 以从 `mpnotify.exe` 接收凭据。(引用: NPPSPY) 一旦作为凭据管理器安装（通过注册表），恶意 DLL 可以在每次用户登录到 Windows 工作站或域时通过 `NPLogonNotify()` 函数接收并保存凭据。(引用: NPLogonNotify)  对手可能会将恶意的网络提供程序 DLL 植入已知具有较多登录活动和/或管理员登录活动的系统上，例如服务器和域控制器。(引用: NPPSPY - Huntress) |
| [T1556.009](../techniques/T1556.009.md) | 条件访问策略 | 对手可能会禁用或修改条件访问策略，以确保对被破坏账户的持久访问。条件访问策略是身份提供者和身份和访问管理系统用于确定用户是否应被授予资源访问权限的额外验证。  例如，在Entra ID、Okta和JumpCloud中，可以根据用户的IP地址、设备注册状态和多因素认证的使用情况拒绝用户访问应用程序。(引用: Microsoft Conditional Access)(引用: JumpCloud Conditional Access Policies)(引用: Okta Conditional Access Policies) 在某些情况下，身份提供者还可能支持使用基于风险的指标，根据各种指标拒绝登录。在AWS和GCP中，IAM策略可以包含`condition`属性，以验证任意约束，例如源IP、请求日期以及请求的资源或区域的性质。(引用: AWS IAM Conditions)(引用: GCP IAM Conditions) 这些措施有助于防止被破坏的凭据导致未经授权的数据或资源访问，并将用户权限限制在仅所需的权限。  通过修改条件访问策略，例如添加额外的受信任IP范围、删除[多因素认证](https://attack.mitre.org/techniques/T1556/006)要求或允许额外的[未使用/不受支持的云区域](https://attack.mitre.org/techniques/T1535)，对手可能能够确保对账户的持久访问并规避防御措施。 |
| [T1574](../techniques/T1574.md) | 劫持执行流 | 对手可能通过劫持操作系统运行程序的方式来执行他们自己的恶意有效载荷。劫持执行流可以用于持久性，因为这种劫持的执行可能会随着时间的推移而重复发生。对手还可能使用这些机制来提升权限或规避防御，例如应用程序控制或其他执行限制。  对手可能通过多种方式劫持执行流，包括操纵操作系统定位要执行的程序的方式。操作系统定位程序使用的库的方式也可以被拦截。操作系统查找程序/资源的位置，例如文件目录，在Windows中是注册表，也可能被污染以包含恶意有效载荷。 |
| [T1574.001](../techniques/T1574.001.md) | DLL 搜索顺序劫持 | 对手可能通过劫持用于加载 DLL 的搜索顺序来执行他们自己的恶意有效负载。Windows 系统使用一种常见的方法来查找要加载到程序中的所需 DLL。(引用: Microsoft Dynamic Link Library Search Order)(引用: FireEye Hijacking July 2010) 劫持 DLL 加载可能是为了建立持久性以及提升权限和/或规避文件执行限制。  对手可以通过多种方式劫持 DLL 加载。对手可能会在目录中植入特洛伊木马动态链接库文件 (DLL)，该目录将在请求的合法库之前被搜索，从而导致 Windows 在调用受害者程序时加载他们的恶意库。对手还可能通过放置与模糊指定的 DLL 同名的恶意 DLL 在 Windows 搜索合法 DLL 之前的位置来执行 DLL 预加载，也称为二进制植入攻击。(引用: OWASP Binary Planting) 通常这个位置是程序的当前工作目录。(引用: FireEye fxsst June 2011) 远程 DLL 预加载攻击发生在程序将其当前目录设置为远程位置（如 Web 共享）之前加载 DLL。(引用: Microsoft Security Advisory 2269637)  幻影 DLL 劫持是一种特定类型的 DLL 搜索顺序劫持，对手针对对不存在的 DLL 文件的引用。(引用: Hexacorn DLL Hijacking)(引用: Adversaries Hijack DLLs) 他们可能能够通过在缺失模块的位置植入具有正确名称的恶意 DLL 来加载自己的恶意 DLL。  对手还可以通过 DLL 重定向直接修改搜索顺序，启用后（在注册表中并创建重定向文件）可能导致程序加载不同的 DLL。(引用: Microsoft Dynamic-Link Library Redirection)(引用: Microsoft Manifests)(引用: FireEye DLL Search Order Hijacking)  如果配置为以更高权限级别运行的程序易受路径劫持攻击，那么加载的对手控制的 DLL 也将以更高权限级别执行。在这种情况下，该技术可用于从用户到管理员或 SYSTEM 的权限提升，或从管理员到 SYSTEM，具体取决于程序。受路径劫持攻击的程序可能会表现正常，因为恶意 DLL 可能会配置为也加载它们原本要替换的合法 DLL。 |
| [T1574.002](../techniques/T1574.002.md) | DLL侧加载 | 攻击者可能通过侧加载DLL执行其恶意负载。类似于[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)，侧加载涉及劫持程序加载的DLL。但不仅仅是将DLL放置在程序的搜索顺序中然后等待受害者应用程序被调用，攻击者可能通过放置并调用执行其负载的合法应用程序直接侧加载其负载。  侧加载利用加载器使用的DLL搜索顺序，将受害者应用程序和恶意负载并排放置。攻击者可能使用侧加载作为在合法、受信任且可能提升权限的系统或软件进程下掩盖其操作的手段。用于侧加载负载的良性可执行文件在交付和/或执行期间可能不会被标记。攻击者负载在被加载到受信任进程的内存之前也可能被加密/打包或以其他方式混淆。(引用: FireEye DLL侧加载) |
| [T1574.004](../techniques/T1574.004.md) | Dylib劫持 | 对手可能通过在受害者应用程序在运行时搜索的路径中放置具有预期名称的恶意动态库（dylib）来执行其负载。动态加载器将根据搜索路径的顺序尝试查找dylib。dylib的路径可能以<code>@rpath</code>为前缀，这允许开发人员使用相对路径在运行时根据可执行文件的位置指定一组搜索路径。此外，如果使用弱链接，例如<code>LC_LOAD_WEAK_DYLIB</code>函数，即使预期的dylib不存在，应用程序仍将执行。弱链接使开发人员能够在添加新API的多个macOS版本上运行应用程序。  对手可能通过在识别的路径中插入具有缺失dylib名称的恶意dylib来获得执行。(引用: Wardle Dylib Hijack Vulnerable Apps)(引用: Wardle Dylib Hijacking OSX 2015)(引用: Github EmpireProject HijackScanner)(引用: Github EmpireProject CreateHijacker Dylib) dylib被加载到应用程序的地址空间中，允许恶意dylib继承应用程序的权限级别和资源。根据应用程序的不同，这可能导致权限提升和不受限制的网络访问。由于执行被掩盖在合法进程下，此方法还可能逃避安全产品的检测。(引用: Writing Bad Malware for OSX)(引用: wardle artofmalware volume1)(引用: MalwareUnicorn macOS Dylib Injection MachO) |
| [T1574.005](../techniques/T1574.005.md) | 可执行安装文件权限弱点 | 对手可能通过劫持安装程序使用的二进制文件来执行他们自己的恶意负载。这些进程可能会自动执行特定的二进制文件，作为其功能的一部分或执行其他操作。如果包含目标二进制文件的文件系统目录或二进制文件本身的权限设置不正确，则可以使用用户级权限覆盖目标二进制文件，并由原始进程执行。如果原始进程和线程在更高权限级别下运行，则替换的二进制文件也将在更高权限级别下执行，这可能包括 SYSTEM。  此技术的另一种变体可以通过利用可执行自解压安装程序中常见的弱点来执行。在安装过程中，安装程序通常使用<code>%TEMP%</code>目录中的子目录来解压缩 DLL、EXE 或其他负载等二进制文件。当安装程序创建子目录和文件时，它们通常不会设置适当的权限来限制写访问，这允许在子目录中执行不受信任的代码或覆盖安装过程中使用的二进制文件。这种行为与[DLL 搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)有关，并可能利用其优势。  对手可能会使用此技术替换合法的二进制文件，以更高权限级别执行代码。一些安装程序还可能需要提升权限，这将在执行对手控制的代码时导致权限提升。这种行为与[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)有关。已经向软件供应商报告了几个现有常见安装程序中此弱点的示例。(引用: mozilla_sec_adv_2012)(引用: Executable Installers are Vulnerable) 如果执行进程设置为在特定时间或某个事件（例如系统启动）期间运行，则此技术还可用于持久性。 |
| [T1574.006](../techniques/T1574.006.md) | 动态链接器劫持 | 对手可能通过劫持动态链接器用于加载共享库的环境变量来执行他们自己的恶意负载。在程序的执行准备阶段，动态链接器从环境变量和文件（如 Linux 上的 <code>LD_PRELOAD</code> 或 macOS 上的 <code>DYLD_INSERT_LIBRARIES</code>）加载指定的共享库的绝对路径。环境变量中指定的库首先加载，优先于具有相同函数名称的系统库。（引用：Man LD.SO）（引用：TLDP 共享库）（引用：Apple Doco Archive 动态库）这些变量通常由开发人员用于调试二进制文件而无需重新编译、解决映射符号冲突以及在不更改原始库的情况下实现自定义函数。（引用：Baeldung LD_PRELOAD）  在 Linux 和 macOS 上，劫持动态链接器变量可能会授予对受害者进程内存、系统/网络资源的访问权限，并可能提升权限。此方法还可能规避安全产品的检测，因为执行被掩盖在合法进程下。对手可以使用 <code>export</code> 命令、<code>setenv</code> 函数或 <code>putenv</code> 函数通过命令行设置环境变量。对手还可以利用 [动态链接器劫持](https://attack.mitre.org/techniques/T1574/006) 在 shell 中导出变量或使用更高级别的语法（如 Python 的 <code>os.environ</code>）以编程方式设置变量。  在 Linux 上，对手可能会设置 <code>LD_PRELOAD</code> 以指向与受害者程序请求的合法库名称匹配的恶意库，从而导致操作系统在执行受害者程序时加载对手的恶意代码。<code>LD_PRELOAD</code> 可以通过环境变量或 <code>/etc/ld.so.preload</code> 文件设置。（引用：Man LD.SO）（引用：TLDP 共享库）由 <code>LD_PRELOAD</code> 指定的库由 <code>dlopen()</code> 和 <code>mmap()</code> 分别加载和映射到内存中。（引用：Linux 和 macOS 上的代码注入）（引用：Uninformed Needle）（引用：Phrack halfdead 1997）（引用：Brown Exploiting Linkers）  在 macOS 上，此行为在概念上与 Linux 上相同，只是在较低级别上实现 macOS 动态库（dyld）有所不同。对手可以设置 <code>DYLD_INSERT_LIBRARIES</code> 环境变量以指向包含受害者程序请求的合法库或函数名称的恶意库。（引用：TheEvilBit DYLD_INSERT_LIBRARIES）（引用：Timac DYLD_INSERT_LIBRARIES）（引用：Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass） |
| [T1574.007](../techniques/T1574.007.md) | 通过PATH环境变量进行路径拦截 | 对手可能通过劫持用于加载库的环境变量来执行自己的恶意有效负载。PATH环境变量包含一个目录列表（用户和系统），操作系统按顺序搜索这些目录以查找从脚本或命令行调用的二进制文件。  对手可以将恶意程序放置在PATH环境变量列表中较早的条目中，从而导致操作系统在按顺序搜索该PATH列表时执行恶意二进制文件而不是合法二进制文件。  例如，在Windows上，如果对手将名为“net.exe”的恶意程序放置在`C:\example path`中，该路径默认情况下优先于`C:\Windows\system32\net.exe`在PATH环境变量中，当从命令行执行“net”时，将调用`C:\example path`而不是系统的合法可执行文件`C:\Windows\system32\net.exe`。某些执行程序的方法依赖于PATH环境变量来确定在未给出程序路径时要搜索的位置，例如从[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)执行程序。(引用: ExpressVPN PATH env Windows 2021)  对手还可以直接修改指定要搜索目录的$PATH变量。对手可以修改$PATH变量以指向他们有写访问权限的目录。当调用使用$PATH变量的程序时，操作系统将搜索指定目录并执行恶意二进制文件。在macOS上，这也可以通过修改$HOME变量来执行。这些变量可以使用命令行、launchctl、[Unix Shell配置修改](https://attack.mitre.org/techniques/T1546/004)或修改`/etc/paths.d`文件夹内容来修改。(引用: uptycs Fake POC linux malware 2023)(引用: nixCraft macOS PATH variables)(引用: Elastic Rules macOS launchctl 2022) |
| [T1574.008](../techniques/T1574.008.md) | 通过搜索顺序劫持进行路径拦截 | 对手可能通过劫持用于加载其他程序的搜索顺序来执行他们自己的恶意有效负载。由于某些程序在调用其他程序时不使用完整路径，对手可能会将他们自己的文件放置在调用程序所在的目录中，从而导致操作系统在调用程序的请求下启动他们的恶意软件。  搜索顺序劫持发生在对手滥用Windows搜索未指定路径的程序的顺序时。与[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)不同，搜索顺序因执行程序的方法而异。(引用: Microsoft CreateProcess) (引用: Windows NT Command Shell) (引用: Microsoft WinExec) 然而，Windows通常会在搜索Windows系统目录之前搜索启动程序的目录。发现易受搜索顺序劫持（即未指定可执行文件路径）的程序的对手可能会通过在启动程序的目录中创建一个命名为不正确指定程序的程序来利用此漏洞。  例如，“example.exe”运行“cmd.exe”并带有命令行参数<code>net user</code>。对手可能会在example.exe所在的目录中放置一个名为“net.exe”的程序，“net.exe”将被运行而不是Windows系统实用程序net。此外，如果对手在与“net.exe”相同的目录中放置一个名为“net.com”的程序，那么<code>cmd.exe /C net user</code>将执行“net.com”而不是“net.exe”，因为在PATHEXT下定义的可执行文件扩展名顺序。(引用: Microsoft Environment Property)  搜索顺序劫持也是劫持DLL加载的常见做法，并在[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)中进行了介绍。 |
| [T1574.009](../techniques/T1574.009.md) | 通过未加引号的路径进行路径拦截 | 对手可能通过劫持易受攻击的文件路径引用来执行他们自己的恶意有效载荷。对手可以利用缺乏引号的路径，通过在路径中的更高级目录中放置可执行文件，使Windows选择对手的可执行文件来启动。  如果路径中有一个或多个空格且未加引号（例如<code>C:\unsafe path with space\program.exe</code>与<code>"C:\safe path with space\program.exe"</code>），服务路径(引用: Microsoft CurrentControlSet Services)和快捷方式路径也可能容易受到路径拦截的攻击。(引用: Help eliminate unquoted path)（存储在Windows注册表键中）对手可以在路径的更高级目录中放置一个可执行文件，Windows将解析该可执行文件而不是预期的可执行文件。例如，如果快捷方式中的路径是<code>C:\program files\myapp.exe</code>，对手可能会在<code>C:\program.exe</code>创建一个程序，该程序将被运行而不是预期的程序。(引用: Windows Unquoted Services)(引用: Windows Privilege Escalation Guide)  如果可执行文件被定期调用，此技术可以用于持久性，如果被拦截的可执行文件由更高权限的进程启动，则可以用于权限提升。 |
| [T1574.010](../techniques/T1574.010.md) | 服务文件权限弱点 | 对手可能通过劫持服务使用的二进制文件来执行他们自己的恶意有效载荷。对手可能利用Windows服务权限中的漏洞来替换服务启动时执行的二进制文件。这些服务进程可能会自动执行特定的二进制文件，作为其功能的一部分或执行其他操作。如果包含目标二进制文件的文件系统目录或二进制文件本身的权限设置不正确，则可以使用用户级权限覆盖目标二进制文件，并由原始进程执行。如果原始进程和线程在更高权限级别下运行，则替换的二进制文件也将在更高权限级别下执行，这可能包括SYSTEM。  对手可能使用此技术替换合法二进制文件为恶意二进制文件，以便在更高权限级别下执行代码。如果执行进程设置为在特定时间或某个事件（例如系统启动）期间运行，则此技术也可用于持久性。 |
| [T1574.011](../techniques/T1574.011.md) | 服务注册表权限弱点 | 对手可能通过劫持服务使用的注册表项来执行他们自己的恶意有效负载。对手可能会利用服务注册表项权限中的漏洞，将原本指定的可执行文件重定向到他们控制的文件，以便在服务启动时启动他们自己的代码。Windows 在 <code>HKLM\SYSTEM\CurrentControlSet\Services</code> 下的注册表中存储本地服务配置信息。可以通过服务控制器、sc.exe、[PowerShell](https://attack.mitre.org/techniques/T1059/001) 或 [Reg](https://attack.mitre.org/software/S0075) 等工具操作存储在服务注册表项下的信息。对注册表项的访问通过访问控制列表和用户权限进行控制。(引用: Registry Key Security)(引用: malware_hides_service)  如果用户和组的权限设置不正确，并允许访问服务的注册表项，对手可能会更改服务的 binPath/ImagePath 以指向他们控制的不同可执行文件。当服务启动或重新启动时，对手控制的程序将执行，允许对手在服务设置为执行的帐户上下文（本地/域帐户、SYSTEM、LocalService 或 NetworkService）中建立持久性和/或提升权限。  对手还可能更改服务注册表树中的其他注册表项。例如，可以更改 <code>FailureCommand</code> 键，以便在服务失败或故意损坏时在提升的上下文中执行服务。(引用: Kansa Service related collectors)(引用: Tweet Registry Perms Weakness)  <code>Performance</code> 键包含驱动程序服务性能 DLL 的名称和 DLL 中几个导出函数的名称。(引用: microsoft_services_registry_tree) 如果 <code>Performance</code> 键尚不存在，并且对手控制的用户具有 <code>Create Subkey</code> 权限，对手可能会在服务的注册表树中创建 <code>Performance</code> 键以指向恶意 DLL。(引用: insecure_reg_perms)  对手还可能添加 <code>Parameters</code> 键，该键存储驱动程序特定数据，或其他自定义子键以建立持久性或启用其他恶意活动。(引用: microsoft_services_registry_tree)(引用: troj_zegost) 此外，如果对手使用 svchost.exe 启动他们的恶意服务，可以使用 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\servicename\Parameters\ServiceDll</code> 标识服务的文件。(引用: malware_hides_service) |
| [T1574.012](../techniques/T1574.012.md) | COR_PROFILER | 对手可能利用COR_PROFILER环境变量劫持加载.NET CLR的程序的执行流。COR_PROFILER是一个.NET框架功能，允许开发人员指定一个非托管（或.NET外部）分析DLL加载到每个加载公共语言运行时（CLR）的.NET进程中。这些分析器旨在监视、排除故障和调试由.NET CLR执行的托管代码。(引用: Microsoft Profiling Mar 2017)(引用: Microsoft COR_PROFILER Feb 2013)  COR_PROFILER环境变量可以在各种范围内设置（系统、用户或进程），导致不同级别的影响。系统和用户范围的环境变量范围在注册表中指定，其中可以将[组件对象模型](https://attack.mitre.org/techniques/T1559/001)（COM）对象注册为分析DLL。还可以在内存中创建进程范围的COR_PROFILER，而无需修改注册表。从.NET框架4开始，只要在COR_PROFILER_PATH环境变量中指定DLL的位置，就不需要注册分析DLL。(引用: Microsoft COR_PROFILER Feb 2013)  对手可能滥用COR_PROFILER建立持久性，每次调用CLR时在所有.NET进程的上下文中执行恶意DLL。如果受害者.NET进程以更高权限级别执行，COR_PROFILER还可以用于提升权限（例如[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)），以及挂钩和[削弱防御](https://attack.mitre.org/techniques/T1562)由.NET进程提供。(引用: RedCanary Mockingbird May 2020)(引用: Red Canary COR_PROFILER May 2020)(引用: Almond COR_PROFILER Apr 2019)(引用: GitHub OmerYa Invisi-Shell)(引用: subTee .NET Profilers May 2017) |
| [T1574.013](../techniques/T1574.013.md) | KernelCallbackTable | 对手可能滥用进程的<code>KernelCallbackTable</code>来劫持其执行流以运行自己的有效载荷。(引用: Lazarus APT January 2022)(引用: FinFisher exposed) <code>KernelCallbackTable</code>可以在进程环境块（PEB）中找到，并在加载<code>user32.dll</code>后初始化为GUI进程可用的图形函数数组。(引用: Windows Process Injection KernelCallbackTable)  对手可能通过替换原始回调函数为恶意有效载荷来劫持进程的执行流。修改回调函数可以通过涉及相关行为的各种方式实现，例如[反射代码加载](https://attack.mitre.org/techniques/T1620)或[进程注入](https://attack.mitre.org/techniques/T1055)到另一个进程中。  可以通过定位PEB（例如，通过调用<code>NtQueryInformationProcess()</code> [本机API](https://attack.mitre.org/techniques/T1106)函数）获得指向<code>KernelCallbackTable</code>内存地址的指针。(引用: NtQueryInformationProcess) 一旦找到指针，可以复制<code>KernelCallbackTable</code>，并将表中的函数（例如<code>fnCOPYDATA</code>）设置为恶意有效载荷的地址（例如通过<code>WriteProcessMemory()</code>）。然后更新PEB以包含新表的地址。一旦调用篡改的函数，恶意有效载荷将被触发。(引用: Lazarus APT January 2022)  篡改的函数通常使用Windows消息调用。在劫持进程并执行恶意代码后，<code>KernelCallbackTable</code>也可能由恶意有效载荷的其余部分恢复到其原始状态。(引用: Lazarus APT January 2022) 使用<code>KernelCallbackTable</code>劫持执行流可能会规避安全产品的检测，因为执行可以掩盖在合法进程下。 |
| [T1574.014](../techniques/T1574.014.md) | AppDomainManager | 对手可能通过劫持 .NET `AppDomainManager` 加载程序集的方式来执行他们自己的恶意有效负载。 .NET 框架使用 `AppDomainManager` 类在进程内创建和管理一个或多个隔离的运行时环境（称为应用程序域）以托管 .NET 应用程序的执行。程序集（编译为运行 .NET 代码的 `.exe` 或 `.dll` 二进制文件）可以作为可执行代码加载到应用程序域中。(引用: Microsoft App Domains)  称为“AppDomainManager 注入”，对手可能通过劫持 .NET 应用程序加载程序集的方式来执行任意代码。例如，恶意软件可能在目标进程内创建一个自定义应用程序域以加载和执行任意程序集。或者，可以篡改定义 .NET 运行时设置的配置文件（`.config`）或进程环境变量，以指示原本无害的 .NET 应用程序将恶意程序集（按名称标识）加载到目标进程中。(引用: PenTestLabs AppDomainManagerInject)(引用: PwC Yellow Liderc)(引用: Rapid7 AppDomain Manager Injection) |
| [T1586.003](../techniques/T1586.003.md) | 云账户 | 云环境中的有效账户可能允许对手执行操作以实现初始访问、持久性、权限提升或防御规避。云账户是由组织创建和配置的账户，供用户、远程支持、服务或管理云服务提供商或SaaS应用程序中的资源使用。云账户可以仅存在于云中；或者，它们可能通过与其他身份源（例如Windows Active Directory）的同步或联合在本地系统和云之间混合连接。(引用: AWS Identity Federation)(引用: Google Federating GC)(引用: Microsoft Deploying AD Federation)  服务或用户账户可能通过[暴力破解](https://attack.mitre.org/techniques/T1110)、[网络钓鱼](https://attack.mitre.org/techniques/T1566)或各种其他手段成为对手的目标，以获得对环境的访问权限。联合或同步账户可能是对手影响本地系统和云环境的途径——例如，通过利用共享凭据登录到[远程服务](https://attack.mitre.org/techniques/T1021)。高权限云账户，无论是联合、同步还是仅云账户，也可能允许通过SaaS [软件部署工具](https://attack.mitre.org/techniques/T1072)在混合连接设备上运行命令，从而转移到本地环境。  对手可能会在被破坏的云账户上创建长期的[附加云凭据](https://attack.mitre.org/techniques/T1098/001)，以在环境中保持持久性。这些凭据还可以用于绕过多因素身份验证等安全控制。  云账户还可能能够通过环境中的各种手段获得[临时提升的云访问权限](https://attack.mitre.org/techniques/T1548/005)或其他权限。角色分配或角色假设策略中的配置错误可能允许对手使用这些机制来利用超出账户预期范围的权限。这些超权限账户可能用于通过[云API](https://attack.mitre.org/techniques/T1059/009)或其他方法从在线存储账户和数据库中收集敏感数据。  |
| [T1653](../techniques/T1653.md) | 电源设置 | 攻击者可能会削弱系统的休眠、重启或关闭能力，以延长对受感染机器的访问。当计算机进入休眠状态时，部分或所有软件和硬件可能会停止运行，这可能会中断恶意活动。(引用: 睡眠、关闭、休眠)  攻击者可能滥用系统实用程序和配置设置，通过防止机器进入可以终止恶意活动的状态（如待机）来保持访问。(引用: Microsoft: Powercfg命令行选项)(引用: systemdsleep Linux)  例如，`powercfg`控制Windows系统上所有可配置的电源系统设置，并可能被滥用以防止受感染的主机锁定或关闭。(引用: 两种新的Monero恶意软件攻击针对Windows和Android用户) 攻击者还可能延长系统锁屏超时设置。(引用: BATLOADER: 规避的下载器恶意软件) 其他相关设置（如磁盘和休眠超时）也可能被滥用以保持受感染的机器运行，即使没有用户活动。(引用: CoinLoader: 复杂的恶意软件加载器活动)  意识到某些恶意软件无法在系统重启后存活，攻击者可能会完全删除用于调用系统关闭或重启的文件。(引用: Condi-Botnet-binaries) |
