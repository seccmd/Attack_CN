---
hide:
  - toc
---

# 权限提升

攻击者试图获得更高的权限。

### 技术： 109

| 编号 | 名字 | 描述 |
| --- | --- | --- |
| [T1037](../techniques/T1037.md) | 启动或登录初始化脚本 | 对手可能会使用在启动或登录初始化时自动执行的脚本来建立持久性。(引用: Mandiant APT29 Eye Spy Email Nov 22)(引用: Anomali Rocke March 2019) 初始化脚本可用于执行管理功能，通常可以执行其他程序或将信息发送到内部日志服务器。这些脚本可能因操作系统和本地或远程应用而异。  对手可能会使用这些脚本在单个系统上保持持久性。根据登录脚本的访问配置，可能需要本地凭据或管理员帐户。  对手还可能能够提升其权限，因为某些启动或登录初始化脚本以更高的权限运行。 |
| [T1037.001](../techniques/T1037.001.md) | 登录脚本（Windows） | 攻击者可能使用在登录初始化时自动执行的Windows登录脚本来建立持久性。Windows允许在特定用户或用户组登录系统时运行登录脚本。(引用: TechNet登录脚本) 这是通过将脚本路径添加到<code>HKCU\Environment\UserInitMprLogonScript</code>注册表项来完成的。(引用: Hexacorn登录脚本)  攻击者可能使用这些脚本在单个系统上保持持久性。根据登录脚本的访问配置，可能需要本地凭据或管理员帐户。 |
| [T1037.002](../techniques/T1037.002.md) | 登录钩子 | 对手可能会使用登录钩子在用户登录时执行以建立持久性。登录钩子是一个plist文件，指向一个特定的脚本，在用户登录时以root权限执行。plist文件位于<code>/Library/Preferences/com.apple.loginwindow.plist</code>文件中，可以使用<code>defaults</code>命令行实用程序进行修改。注销钩子的行为相同，其中脚本可以在用户注销时执行。所有钩子都需要管理员权限才能修改或创建钩子。(引用: Login Scripts Apple Dev)(引用: LoginWindowScripts Apple Dev)  对手可以在<code>com.apple.loginwindow.plist</code>文件中添加或插入指向恶意脚本的路径，使用<code>LoginHook</code>或<code>LogoutHook</code>键值对。恶意脚本将在下次用户登录时执行。如果已经存在登录钩子，对手可以向现有登录钩子添加额外的命令。系统一次只能有一个登录和注销钩子。(引用: S1 macOs Persistence)(引用: Wardle Persistence Chapter)  **注意：** 登录钩子在macOS 10.11版本中被弃用，取而代之的是[启动守护程序](https://attack.mitre.org/techniques/T1543/004)和[启动代理](https://attack.mitre.org/techniques/T1543/001) |
| [T1037.003](../techniques/T1037.003.md) | 网络登录脚本 | 对手可能会使用在登录初始化时自动执行的网络登录脚本来建立持久性。网络登录脚本可以使用Active Directory或组策略对象分配。(引用: Petri Logon Script AD) 这些登录脚本以分配给它们的用户的权限运行。根据网络中的系统，初始化这些脚本可能适用于一个或多个甚至所有系统。  对手可能会使用这些脚本在网络上保持持久性。根据登录脚本的访问配置，可能需要本地凭据或管理员账户。 |
| [T1037.004](../techniques/T1037.004.md) | RC脚本 | 对手可能通过修改在类Unix系统启动期间执行的RC脚本来建立持久性。这些文件允许系统管理员在不同运行级别启动自定义服务。修改RC脚本需要root权限。  对手可以通过将恶意二进制路径或shell命令添加到<code>rc.local</code>、<code>rc.common</code>和其他特定于类Unix发行版的RC脚本来建立持久性。(引用: IranThreats Kittens Dec 2017)(引用: Intezer HiddenWasp Map 2019) 重启后，系统以root身份执行脚本的内容，从而实现持久性。  对手滥用RC脚本在默认使用root用户的轻量级类Unix发行版（如IoT或嵌入式系统）中特别有效。(引用: intezer-kaiji-malware)  一些类Unix系统已经迁移到Systemd并弃用了RC脚本。在macOS中，这是一种弃用的机制，取而代之的是[Launchd](https://attack.mitre.org/techniques/T1053/004)。(引用: Apple Developer Doco Archive Launchd)(引用: Startup Items) 此技术可用于Mac OS X Panther v10.3及更早版本，这些版本仍然执行RC脚本。(引用: Methods of Mac Malware Persistence) 为了保持向后兼容性，一些系统（如Ubuntu）将在存在正确文件权限的情况下执行RC脚本。(引用: Ubuntu Manpage systemd rc) |
| [T1037.005](../techniques/T1037.005.md) | 启动项 | 对手可能会使用在启动初始化时自动执行的启动项来建立持久性。启动项在启动过程的最后阶段执行，包含shell脚本或其他可执行文件以及系统用于确定所有启动项执行顺序的配置信息。(引用: Startup Items)  这在技术上是一种已弃用的技术（被[启动守护程序](https://attack.mitre.org/techniques/T1543/004)取代），因此适当的文件夹<code>/Library/StartupItems</code>默认情况下可能不存在于系统上，但在macOS Sierra上默认存在。启动项是一个目录，其可执行文件和配置属性列表（plist），<code>StartupParameters.plist</code>，位于顶级目录中。  对手可以在StartupItems目录中创建适当的文件夹/文件来注册他们自己的持久性机制。(引用: Methods of Mac Malware Persistence) 此外，由于启动项在macOS的启动阶段运行，它们将以提升的root用户身份运行。 |
| [T1053](../techniques/T1053.md) | 计划任务/作业 | 对手可能会滥用任务调度功能来促进恶意代码的初始或定期执行。所有主要操作系统中都存在用于在指定日期和时间执行程序或脚本的实用程序。只要满足适当的身份验证要求（例如：Windows 环境中的 RPC 和文件及打印机共享），也可以在远程系统上调度任务。在远程系统上调度任务通常可能需要成为远程系统上管理员或其他特权组的成员。(引用: TechNet Task Scheduler Security)  对手可能会使用任务调度在系统启动时或定期执行程序以实现持久性。这些机制也可以被滥用以在指定账户（例如具有提升权限/特权的账户）的上下文中运行进程。类似于[系统二进制代理执行](https://attack.mitre.org/techniques/T1218)，对手还滥用任务调度来潜在地掩盖受信任系统进程下的一次性执行。(引用: ProofPoint Serpent) |
| [T1053.002](../techniques/T1053.002.md) | At | 攻击者可能滥用[at](https://attack.mitre.org/software/S0110)实用程序来执行任务调度，以初始或重复执行恶意代码。[at](https://attack.mitre.org/software/S0110)实用程序作为Windows、Linux和macOS中的可执行文件存在，用于在指定的时间和日期调度任务。尽管在Windows环境中已弃用，转而使用[计划任务](https://attack.mitre.org/techniques/T1053/005)的[schtasks](https://attack.mitre.org/software/S0111)，但使用[at](https://attack.mitre.org/software/S0110)需要任务调度程序服务正在运行，并且用户必须以本地管理员组成员的身份登录。除了显式运行`at`命令外，攻击者还可以通过直接利用[Windows管理工具](https://attack.mitre.org/techniques/T1047) `Win32_ScheduledJob` WMI类来调度任务。(Citation: Malicious Life by Cybereason)  在Linux和macOS上，超级用户以及添加到<code>at.allow</code>文件中的任何用户都可以调用[at](https://attack.mitre.org/software/S0110)。如果<code>at.allow</code>文件不存在，则检查<code>at.deny</code>文件。未列在<code>at.deny</code>中的每个用户名都允许调用[at](https://attack.mitre.org/software/S0110)。如果<code>at.deny</code>存在且为空，则允许全局使用[at](https://attack.mitre.org/software/S0110)。如果两个文件都不存在（通常是基线情况），则只有超级用户可以使用[at](https://attack.mitre.org/software/S0110)。(Citation: Linux at)  攻击者可能使用[at](https://attack.mitre.org/software/S0110)在系统启动时或按计划执行程序以实现[持久性](https://attack.mitre.org/tactics/TA0003)。[at](https://attack.mitre.org/software/S0110)还可用于在[横向移动](https://attack.mitre.org/tactics/TA0008)期间进行远程[执行](https://attack.mitre.org/tactics/TA0002)或在指定账户（如SYSTEM）的上下文中运行进程。  在Linux环境中，攻击者还可能滥用[at](https://attack.mitre.org/software/S0110)通过任务生成交互式系统shell或运行系统命令来突破受限环境。同样，如果二进制文件允许通过<code>sudo</code>以超级用户身份运行，[at](https://attack.mitre.org/software/S0110)也可用于[权限提升](https://attack.mitre.org/tactics/TA0004)。(Citation: GTFObins at) |
| [T1053.003](../techniques/T1053.003.md) | Cron | 对手可能会滥用<code>cron</code>实用程序来执行任务调度，以初始或定期执行恶意代码。(引用: 20 macOS Common Tools and Techniques) <code>cron</code>实用程序是类Unix操作系统的基于时间的作业调度程序。<code>crontab</code>文件包含要运行的cron条目和指定的执行时间。任何<code>crontab</code>文件都存储在特定于操作系统的文件路径中。  对手可能会在Linux或Unix环境中使用<code>cron</code>在系统启动时或定期执行程序以实现[持久性](https://attack.mitre.org/tactics/TA0003)。 |
| [T1053.005](../techniques/T1053.005.md) | 计划任务 | 对手可能会滥用Windows任务计划程序来执行任务调度，以初始或定期执行恶意代码。有多种方法可以访问Windows中的任务计划程序。可以直接在命令行上运行[schtasks](https://attack.mitre.org/software/S0111)实用程序，或者可以通过控制面板中的管理工具部分打开任务计划程序的GUI。(引用: Stack Overflow) 在某些情况下，对手使用了Windows任务计划程序的.NET包装器，或者使用了Windows netapi32库和[Windows管理工具](https://attack.mitre.org/techniques/T1047) (WMI)来创建计划任务。对手还可以利用Powershell Cmdlet `Invoke-CimMethod`，该Cmdlet利用WMI类`PS_ScheduledTask`通过XML路径创建计划任务。(引用: Red Canary - Atomic Red Team)  对手可能会使用Windows任务计划程序在系统启动时或定期执行程序以保持持久性。Windows任务计划程序还可以被滥用以进行远程执行作为横向移动的一部分，或在指定帐户（如SYSTEM）的上下文中运行进程。类似于[系统二进制代理执行](https://attack.mitre.org/techniques/T1218)，对手还滥用了Windows任务计划程序，以便在签名/受信任的系统进程下掩盖一次性执行。(引用: ProofPoint Serpent)  对手还可能创建“隐藏”计划任务（即[隐藏工件](https://attack.mitre.org/techniques/T1564)），这些任务可能对防御工具和用于枚举任务的手动查询不可见。具体来说，对手可能通过删除关联的安全描述符（SD）注册表值（删除此值必须使用SYSTEM权限完成）来隐藏任务。(引用: SigmaHQ)(引用: Tarrask scheduled task) 对手还可能采用其他方法隐藏任务，例如更改关联注册表项中的元数据（例如`Index`值）。(引用: Defending Against Scheduled Task Attacks in Windows Environments) |
| [T1053.006](../techniques/T1053.006.md) | Systemd计时器 | 对手可能滥用systemd计时器来执行任务调度，以初始或定期执行恶意代码。Systemd计时器是文件扩展名为<code>.timer</code>的单元文件，用于控制服务。计时器可以设置为在日历事件或相对于起点的时间跨度后运行。它们可以作为Linux环境中[Cron](https://attack.mitre.org/techniques/T1053/003)的替代品。(引用: archlinux Systemd Timers Aug 2020) Systemd计时器可以通过<code>systemctl</code>命令行实用程序远程激活，该实用程序通过[SSH](https://attack.mitre.org/techniques/T1021/004)操作。(引用: Systemd Remote Control)  每个<code>.timer</code>文件必须有一个对应的<code>.service</code>文件，名称相同，例如<code>example.timer</code>和<code>example.service</code>。<code>.service</code>文件是[Systemd服务](https://attack.mitre.org/techniques/T1543/002)单元文件，由systemd系统和服务管理器管理。(引用: Linux man-pages: systemd January 2014) 特权计时器写入<code>/etc/systemd/system/</code>和<code>/usr/lib/systemd/system</code>，而用户级别的写入<code>~/.config/systemd/user/</code>。  对手可能使用systemd计时器在系统启动时或定期执行恶意代码以实现持久性。(引用: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(引用: gist Arch package compromise 10JUL2018)(引用: acroread package compromised Arch Linux Mail 8JUL2018) 使用特权路径安装的计时器可能用于保持root级别的持久性。对手也可能安装用户级别的计时器以实现用户级别的持久性。(引用: Falcon Sandbox smp: 28553b3a9d) |
| [T1053.007](../techniques/T1053.007.md) | 容器编排任务 | 对手可能会滥用容器编排工具（如 Kubernetes）提供的任务调度功能，来调度部署配置为执行恶意代码的容器。容器编排任务会在特定日期和时间运行这些自动化任务，类似于 Linux 系统上的 cron 任务。这种类型的部署还可以配置为随着时间的推移维护一定数量的容器，从而自动化在集群中保持持久性的过程。  在 Kubernetes 中，可以使用 CronJob 来调度运行一个或多个容器以执行特定任务的 Job。(引用: Kubernetes Jobs)(引用: Kubernetes CronJob) 因此，对手可能会利用 CronJob 来调度部署在集群内各个节点上执行恶意代码的 Job。(引用: Threat Matrix for Kubernetes) |
| [T1055](../techniques/T1055.md) | 进程注入 | 对手可能会将代码注入进程，以规避基于进程的防御措施，并可能提升权限。进程注入是一种在单独的活动进程的地址空间中执行任意代码的方法。在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过进程注入进行的执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。  有许多不同的方法可以将代码注入进程，其中许多滥用合法功能。这些实现存在于每个主要操作系统中，但通常是特定于平台的。  更复杂的样本可能会执行多个进程注入以分段模块并进一步规避检测，利用命名管道或其他进程间通信（IPC）机制作为通信通道。 |
| [T1055.001](../techniques/T1055.001.md) | 动态链接库注入 | 对手可能会注入动态链接库（DLL）到进程中，以规避基于进程的防御并可能提升权限。DLL注入是一种在独立活动进程的地址空间中执行任意代码的方法。  DLL注入通常通过在目标进程的虚拟地址空间中写入DLL路径，然后通过调用新线程加载DLL来执行。写入可以通过本机Windows API调用如<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>来执行，然后通过<code>CreateRemoteThread</code>（调用负责加载DLL的<code>LoadLibrary</code> API）来调用。(引用: Elastic Process Injection July 2017)  这种方法的变体如反射DLL注入（将自映射DLL写入进程）和内存模块（在写入进程时映射DLL）克服了地址重定位问题以及调用执行的额外API（因为这些方法通过手动执行<code>LoadLibrary</code>的功能来加载和执行文件）。(引用: Elastic HuntingNMemory June 2017)(引用: Elastic Process Injection July 2017)  这种方法的另一种变体，通常称为模块踩踏/重载或DLL空洞，可能被用来在进程中隐藏注入的代码。这种方法涉及将合法DLL加载到远程进程中，然后在目标进程中启动新线程之前手动覆盖模块的<code>AddressOfEntryPoint</code>。(引用: Module Stomping for Shellcode Injection) 这种变体允许攻击者通过在磁盘上可能备份其执行的合法DLL文件来隐藏恶意注入代码。(引用: Hiding Malicious Code with Module Stomping)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过DLL注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.002](../techniques/T1055.002.md) | 可移植可执行文件注入 | 对手可能会将可移植可执行文件 (PE) 注入进程中，以规避基于进程的防御并可能提升权限。PE 注入是一种在单独的活动进程的地址空间中执行任意代码的方法。  PE 注入通常通过将代码（可能没有磁盘上的文件）复制到目标进程的虚拟地址空间中，然后通过新线程调用它来执行。可以使用本机 Windows API 调用（例如<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>）执行写入，然后使用<code>CreateRemoteThread</code>或其他代码（例如 shellcode）调用。注入代码的位移引入了重新映射内存引用的附加要求。(引用: Elastic Process Injection July 2017)  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过 PE 注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.003](../techniques/T1055.003.md) | 线程执行劫持 | 对手可能会将恶意代码注入劫持的进程中，以规避基于进程的防御措施，并可能提升权限。线程执行劫持是一种在单独的活动进程的地址空间中执行任意代码的方法。  线程执行劫持通常通过挂起现有进程然后取消/空洞化其内存来执行，然后可以用恶意代码或DLL路径替换。首先使用本机Windows API调用（如<code>OpenThread</code>）创建现有受害进程的句柄。此时，可以挂起进程，然后写入、重新对齐到注入的代码，并通过分别调用<code>SuspendThread</code>、<code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code>和<code>ResumeThread</code>恢复。(引用: Elastic Process Injection July 2017)  这与[进程空洞](https://attack.mitre.org/techniques/T1055/012)非常相似，但目标是现有进程，而不是在挂起状态下创建进程。  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过线程执行劫持进行的执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.004](../techniques/T1055.004.md) | 异步过程调用 | 对手可能会通过异步过程调用（APC）队列将恶意代码注入进程，以规避基于进程的防御并可能提升权限。APC注入是一种在单独的活动进程的地址空间中执行任意代码的方法。  APC注入通常通过将恶意代码附加到进程线程的APC队列（引用: Microsoft APC）来执行。排队的APC函数在线程进入可变状态时执行。(引用: Microsoft APC) 首先使用本机Windows API调用（如<code>OpenThread</code>）创建现有受害进程的句柄。此时可以使用<code>QueueUserAPC</code>调用函数（如指向恶意DLL的<code>LoadLibrayA</code>）。  一种称为“早鸟注入”的APC注入变体涉及创建一个挂起的进程，在进程入口点（以及可能的后续反恶意软件钩子）之前通过APC写入和执行恶意代码。(引用: CyberBit Early Bird Apr 2018) AtomBombing (引用: ENSIL AtomBombing Oct 2016) 是另一种变体，利用APC调用先前写入全局原子表的恶意代码。(引用: Microsoft Atom Table)  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过APC注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.005](../techniques/T1055.005.md) | 线程本地存储 | 攻击者可能通过线程本地存储（TLS）回调将恶意代码注入进程中，以规避基于进程的防御并可能提升权限。TLS回调注入是一种在独立活动进程的地址空间中执行任意代码的方法。  TLS回调注入涉及操纵可移植可执行文件（PE）内的指针，以在到达代码的合法入口点之前将进程重定向到恶意代码。TLS回调通常由操作系统用于设置和/或清理线程使用的数据。操纵TLS回调可能通过使用其他[进程注入](https://attack.mitre.org/techniques/T1055)技术（如[进程挖空](https://attack.mitre.org/techniques/T1055/012)）分配和写入进程内存空间中的特定偏移量来执行。(引用: FireEye TLS 2017年11月)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过TLS回调注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.008](../techniques/T1055.008.md) | Ptrace系统调用 | 攻击者可能通过ptrace（进程跟踪）系统调用将恶意代码注入进程，以规避基于进程的防御并可能提升权限。Ptrace系统调用注入是一种在独立活动进程的地址空间中执行任意代码的方法。  Ptrace系统调用注入涉及附加并修改正在运行的进程。Ptrace系统调用使调试进程能够观察和控制另一个进程（以及每个单独的线程），包括更改内存和寄存器值。(引用: PTRACE手册) Ptrace系统调用注入通常通过将任意代码写入正在运行的进程（例如<code>malloc</code>）然后使用<code>PTRACE_SETREGS</code>调用该内存来设置包含下一条指令的寄存器来执行。Ptrace系统调用注入也可以使用<code>PTRACE_POKETEXT</code>/<code>PTRACE_POKEDATA</code>完成，这些操作将数据复制到目标进程内存中的特定地址（例如下一条指令的当前地址）。(引用: PTRACE手册)(引用: Medium Ptrace 2018年7月)  Ptrace系统调用注入可能无法针对非子进程和/或具有更高权限的进程。(引用: BH Linux注入)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过ptrace系统调用注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.009](../techniques/T1055.009.md) | 进程内存 | 对手可能会通过 /proc 文件系统将恶意代码注入进程中，以规避基于进程的防御，并可能提升权限。进程内存注入是一种在单独的活动进程地址空间中执行任意代码的方法。  进程内存注入涉及通过 /proc 文件系统 (<code>/proc/[pid]</code>) 枚举进程的内存，然后使用可用的小工具/指令制作返回导向编程 (ROP) 负载。每个运行的进程都有自己的目录，其中包括内存映射。进程内存注入通常通过使用 /proc 文件系统提供的内存映射覆盖目标进程的堆栈来执行。这些信息可用于枚举偏移量（包括堆栈）和小工具（或程序中可用于构建恶意负载的指令），这些偏移量和小工具通常被进程内存保护（如地址空间布局随机化 (ASLR)）隐藏。一旦枚举完毕，可以使用 dd 覆盖 <code>/proc/[pid]/maps</code> 中的目标进程内存映射。(引用: Uninformed Needle)(引用: GDS Linux Injection)(引用: DD Man)  其他技术（如 [动态链接器劫持](https://attack.mitre.org/techniques/T1574/006)）可用于填充目标进程以提供更多可用的小工具。类似于 [进程空洞化](https://attack.mitre.org/techniques/T1055/012)，进程内存注入可能会针对子进程（如后台的 sleep 副本）。(引用: GDS Linux Injection)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过进程内存注入执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.011](../techniques/T1055.011.md) | 额外窗口内存注入 | 对手可能通过额外窗口内存（EWM）注入恶意代码，以规避基于进程的防御措施并可能提升权限。EWM注入是一种在单独的活动进程的地址空间中执行任意代码的方法。  在创建窗口之前，基于图形的Windows进程必须遵循或注册一个窗口类，该类规定了外观和行为（通过窗口过程，这些过程是处理数据输入/输出的函数）。(引用: Microsoft Window Classes) 新窗口类的注册可以包括请求将最多40字节的EWM附加到该类每个实例的分配内存中。这个EWM旨在存储特定于该窗口的数据，并具有特定的应用程序编程接口（API）函数来设置和获取其值。(引用: Microsoft GetWindowLong function) (引用: Microsoft SetWindowLong function)  尽管很小，但EWM足够存储一个32位指针，通常用于指向一个窗口过程。恶意软件可能会利用这个内存位置作为攻击链的一部分，包括将代码写入进程内存的共享部分，将指针放置在EWM中，然后通过将执行控制返回到进程的EWM中的地址来调用执行。  通过EWM注入授予的执行可能允许访问目标进程的内存并可能提升权限。将有效负载写入共享部分还可以避免使用高度监控的API调用，如<code>WriteProcessMemory</code>和<code>CreateRemoteThread</code>。(引用: Elastic Process Injection July 2017) 更复杂的恶意软件样本还可能通过触发一系列窗口过程和其他系统函数，将恶意负载重写到目标进程的可执行部分，从而绕过数据执行保护（DEP）等保护机制。(引用: MalwareTech Power Loader Aug 2013) (引用: WeLiveSecurity Gapz and Redyms Mar 2013)  在另一个进程的上下文中运行代码可能允许访问该进程的内存、系统/网络资源，并可能提升权限。通过EWM注入的执行还可以规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.012](../techniques/T1055.012.md) | 进程空洞化 | 对手可能会将恶意代码注入挂起和空洞化的进程中，以规避基于进程的防御。进程空洞化是一种在单独的活动进程地址空间中执行任意代码的方法。  进程空洞化通常通过在挂起状态下创建进程，然后取消映射/空洞化其内存来执行，随后可以用恶意代码替换。可以使用本机 Windows API 调用（如 <code>CreateProcess</code>）创建受害进程，其中包括一个标志以挂起进程的主线程。此时，可以使用 API 调用（如 <code>ZwUnmapViewOfSection</code> 或 <code>NtUnmapViewOfSection</code>）取消映射进程，然后通过 <code>VirtualAllocEx</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code> 和 <code>ResumeThread</code> 分别写入、重新对齐到注入的代码并恢复。(引用: Leitch Hollowing)(引用: Elastic Process Injection July 2017)  这与[线程本地存储](https://attack.mitre.org/techniques/T1055/005)非常相似，但创建的是新进程，而不是针对现有进程。由于注入的进程是从（并因此继承了安全上下文）注入进程生成的，因此这种行为可能不会导致权限提升。然而，通过进程空洞化执行可能会规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.013](../techniques/T1055.013.md) | 进程双重映射 | 对手可能会通过进程双重映射将恶意代码注入进程，以规避基于进程的防御并可能提升权限。进程双重映射是一种在单独的活动进程的地址空间中执行任意代码的方法。  Windows Transactional NTFS (TxF) 在 Vista 中引入，作为执行安全文件操作的方法。(引用: Microsoft TxF) 为确保数据完整性，TxF 仅允许一个事务句柄在给定时间写入文件。在写入句柄事务终止之前，所有其他句柄都与写入者隔离，并且只能读取在打开句柄时存在的已提交版本的文件。(引用: Microsoft Basic TxF Concepts) 为避免损坏，如果系统或应用程序在写入事务期间失败，TxF 会自动回滚。(引用: Microsoft Where to use TxF)  尽管已弃用，但截至 Windows 10，TxF 应用程序编程接口 (API) 仍然启用。(引用: BlackHat Process Doppelgänging Dec 2017)  对手可能会滥用 TxF 执行无文件的[进程注入](https://attack.mitre.org/techniques/T1055)变体。类似于[进程空洞](https://attack.mitre.org/techniques/T1055/012)，进程双重映射涉及替换合法进程的内存，从而使恶意代码的隐蔽执行可能规避防御和检测。进程双重映射使用 TxF 还避免了使用高度监控的 API 函数，如<code>NtUnmapViewOfSection</code>、<code>VirtualProtectEx</code>和<code>SetThreadContext</code>。(引用: BlackHat Process Doppelgänging Dec 2017)  进程双重映射分为 4 个步骤(引用: BlackHat Process Doppelgänging Dec 2017)：  * 事务 – 使用合法可执行文件创建 TxF 事务，然后用恶意代码覆盖文件。这些更改将被隔离，并且仅在事务上下文中可见。 * 加载 – 创建共享内存段并加载恶意可执行文件。 * 回滚 – 撤销对原始可执行文件的更改，有效地从文件系统中删除恶意代码。 * 动画 – 从污染的内存段创建进程并启动执行。  由于注入的进程是从注入进程生成的（因此继承了注入进程的安全上下文），这种行为可能不会导致权限提升。然而，通过进程双重映射执行可能会规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.014](../techniques/T1055.014.md) | VDSO劫持 | 对手可能通过VDSO劫持将恶意代码注入进程，以规避基于进程的防御并可能提升权限。虚拟动态共享对象（vdso）劫持是一种在单独的活动进程地址空间中执行任意代码的方法。  VDSO劫持涉及重定向对动态链接共享库的调用。内存保护可能会阻止通过[Ptrace系统调用](https://attack.mitre.org/techniques/T1055/008)向进程写入可执行代码。然而，对手可能会劫持从vdso共享对象映射到进程的syscall接口代码存根，以执行syscall来打开和映射恶意共享对象。然后可以通过修补存储在进程全局偏移表中的内存地址引用来调用此代码（这些表存储映射库函数的绝对地址）。(引用: ELF Injection May 2009)(引用: Backtrace VDSO)(引用: VDSO Aug 2005)(引用: Syscall 2014)  在另一个进程的上下文中运行代码可能允许访问进程的内存、系统/网络资源，并可能提升权限。通过VDSO劫持执行还可能规避安全产品的检测，因为执行被掩盖在合法进程下。 |
| [T1055.015](../techniques/T1055.015.md) | 列表植入 | 攻击者可能滥用列表视图控件将恶意代码注入到被劫持的进程中，以规避基于进程的防御并可能提升权限。列表植入是一种在独立活动进程的地址空间中执行任意代码的方法。(引用: Hexacorn列表植入) 通过列表植入执行的代码还可能规避安全产品的检测，因为执行被掩盖在合法进程下。  列表视图控件是用于显示项目集合的用户界面窗口。(引用: Microsoft列表视图控件) 有关应用程序列表视图设置的信息存储在进程内存中的<code>SysListView32</code>控件中。  列表植入（一种消息传递“碎片攻击”）可以通过将代码复制到使用列表视图控件的进程的虚拟地址空间，然后使用该代码作为自定义回调来对列出的项目进行排序来执行。(引用: Modexp Windows进程注入) 攻击者必须首先将代码复制到目标进程的内存空间中，这可以通过直接获取受害者进程窗口的<code>SysListView32</code>子句柄（通过Windows API调用，如<code>FindWindow</code>和/或<code>EnumWindows</code>）或其他[进程注入](https://attack.mitre.org/techniques/T1055)方法来完成。  某些列表植入的变体可能会在目标进程中分配内存，但随后使用窗口消息复制有效负载，以避免使用高度监控的<code>WriteProcessMemory</code>函数。例如，攻击者可以使用<code>PostMessage</code>和/或<code>SendMessage</code> API函数发送<code>LVM_SETITEMPOSITION</code>和<code>LVM_GETITEMPOSITION</code>消息，有效地将有效负载每次2字节复制到分配的内存中。(引用: ESET InvisiMole 2020年6月)  最后，通过向进程窗口的<code>SysListView32</code>子句发送<code>LVM_SORTITEMS</code>消息来触发有效负载，并将新分配的缓冲区中的有效负载作为<code>ListView_SortItems</code>回调传递并执行。 |
| [T1068](../techniques/T1068.md) | 利用权限提升 | 对手可能会利用软件漏洞尝试提升权限。利用软件漏洞是指对手利用程序、服务或操作系统软件或内核本身中的编程错误来执行对手控制的代码。安全构造（如权限级别）通常会阻碍对信息的访问和某些技术的使用，因此对手可能需要执行权限提升，包括使用软件漏洞利用来规避这些限制。  在最初获得系统访问权限时，对手可能在较低权限的进程中操作，这将阻止他们访问系统上的某些资源。可能存在漏洞，通常在操作系统组件和常见的高权限运行的软件中，可以利用这些漏洞在系统上获得更高的访问权限。这可能使某人能够从无特权或用户级权限移动到 SYSTEM 或 root 权限，具体取决于易受攻击的组件。这也可能使对手能够从虚拟化环境（如虚拟机或容器内）移动到底层主机。这可能是对手妥协已正确配置并限制其他权限提升方法的端点系统的必要步骤。  对手可能会将签名的易受攻击驱动程序带到被破坏的机器上，以便他们可以利用漏洞在内核模式下执行代码。这个过程有时被称为带上你自己的易受攻击驱动程序（BYOVD）。(引用: ESET InvisiMole June 2020)(引用: Unit42 AcidBox June 2020) 对手可能会在初始访问期间包含易受攻击的驱动程序文件，或通过[入口工具传输](https://attack.mitre.org/techniques/T1105)或[横向工具传输](https://attack.mitre.org/techniques/T1570)下载到被破坏的系统。 |
| [T1078](../techniques/T1078.md) | 有效账户 | 对手可能会获取和滥用现有账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的一种手段。被破坏的凭据可能用于绕过系统内各种资源上的访问控制，甚至可能用于对远程系统和外部可用服务（如 VPN、Outlook Web Access、网络设备和远程桌面）的持久访问。(引用: volexity_0day_sophos_FW) 被破坏的凭据还可能授予对手对特定系统的更高权限或对网络中受限区域的访问权限。对手可能选择不使用恶意软件或工具，而是利用这些凭据提供的合法访问权限，使其存在更难被检测到。  在某些情况下，对手可能会滥用不活跃的账户：例如，那些属于不再是组织成员的个人的账户。使用这些账户可能使对手能够规避检测，因为原账户用户不会在场，无法识别其账户上发生的任何异常活动。(引用: CISA MFA PrintNightmare)  由于本地、域和云账户在系统网络中的权限重叠，对手可能能够跨账户和系统进行横向移动，以达到高水平的访问（即域或企业管理员），从而绕过企业内部设置的访问控制。(引用: TechNet Credential Theft) |
| [T1078.001](../techniques/T1078.001.md) | 默认帐户 | 对手可能会获取和滥用默认帐户的凭据，作为获得初始访问、持久性、权限提升或防御规避的一种手段。默认帐户是内置于操作系统中的帐户，例如 Windows 系统上的来宾或管理员帐户。默认帐户还包括其他类型系统、软件或设备上的默认工厂/提供商设置帐户，包括 AWS 中的 root 用户帐户和 Kubernetes 中的默认服务帐户。（引用：Microsoft 本地帐户 2019 年 2 月）（引用：AWS Root 用户）（引用：Kubernetes 威胁矩阵）  默认帐户不仅限于客户端机器，还包括为设备（如网络设备和计算机应用程序）预设的帐户，无论它们是内部的、开源的还是商业的。安装后未更改的预设用户名和密码组合的设备对组织构成严重威胁，因为它们是对手的容易目标。同样，对手还可能利用公开披露或被盗的 [私钥](https://attack.mitre.org/techniques/T1552/004) 或凭据材料，通过 [远程服务](https://attack.mitre.org/techniques/T1021) 合法连接到远程环境。（引用：Metasploit SSH 模块） |
| [T1078.002](../techniques/T1078.002.md) | 域账户 | 对手可能会获取和滥用域账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的一种手段。(引用: TechNet Credential Theft) 域账户是由Active Directory域服务管理的账户，访问和权限配置在属于该域的系统和服务中。域账户可以覆盖用户、管理员和服务。(引用: Microsoft AD Accounts)  对手可能通过各种手段（如[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)或密码重用）来妥协域账户，其中一些具有高权限，从而访问域的特权资源。 |
| [T1078.003](../techniques/T1078.003.md) | 本地账户 | 对手可能获取和滥用本地账户的凭据，作为获得初始访问、持久性、权限提升或规避防御的手段。本地账户是组织为用户、远程支持、服务或单个系统或服务的管理配置的账户。  本地账户也可能被滥用以提升权限并通过[操作系统凭据转储](https://attack.mitre.org/techniques/T1003)收集凭据。密码重用可能允许在网络上的一组机器上滥用本地账户，以实现权限提升和横向移动。 |
| [T1098](../techniques/T1098.md) | 账户操纵 | 对手可能会操纵账户以保持和/或提升对受害者系统的访问权限。账户操纵可能包括任何保持或修改对手访问被破坏账户的操作，例如修改凭据或权限组。(引用: FireEye SMOKEDHAM June 2021) 这些操作还可能包括旨在颠覆安全策略的账户活动，例如执行迭代密码更新以绕过密码持续时间策略并保持被破坏凭据的寿命。  为了创建或操纵账户，对手必须已经在系统或域上具有足够的权限。然而，账户操纵也可能导致权限提升，其中修改授予对其他角色、权限或更高权限的[有效账户](https://attack.mitre.org/techniques/T1078)的访问权限。 |
| [T1098.001](../techniques/T1098.001.md) | 额外的云凭据 | 对手可能会向云账户添加对手控制的凭据，以保持对受害者账户和环境中实例的持续访问。  例如，对手可能会向 Azure / Entra ID 中的服务主体和应用程序添加凭据，除了现有的合法凭据之外。(引用: Microsoft SolarWinds Customer Guidance)(引用: Blue Cloud of Death)(引用: Blue Cloud of Death Video) 这些凭据包括 x509 密钥和密码。(引用: Microsoft SolarWinds Customer Guidance) 在具有足够权限的情况下，有多种方法可以添加凭据，包括 Azure Portal、Azure 命令行界面和 Azure 或 Az PowerShell 模块。(引用: Demystifying Azure AD Service Principals)  在基础设施即服务 (IaaS) 环境中，在通过[云账户](https://attack.mitre.org/techniques/T1078/004)获得访问权限后，对手可能会使用 AWS 中的 <code>CreateKeyPair</code> 或 <code>ImportKeyPair</code> API 或 GCP 中的 <code>gcloud compute os-login ssh-keys add</code> 命令生成或导入自己的 SSH 密钥。这允许在不进一步使用被妥协的云账户的情况下持续访问环境中的实例。(引用: Expel IO Evil in AWS)(引用: Expel Behind the Scenes)  对手还可能使用 AWS 中的 <code>CreateAccessKey</code> API 或 GCP 中的 <code>gcloud iam service-accounts keys create</code> 命令向账户添加访问密钥。或者，他们可能使用 AWS 中的 <code>CreateLoginProfile</code> API 添加一个密码，该密码可用于登录 AWS 管理控制台以进行[云服务仪表板](https://attack.mitre.org/techniques/T1538)。(引用: Permiso Scattered Spider 2023)(引用: Lacework AI Resource Hijacking 2024) 如果目标账户的权限与请求账户不同，对手也可能能够在环境中提升其权限（即[云账户](https://attack.mitre.org/techniques/T1078/004)）。(引用: Rhino Security Labs AWS Privilege Escalation)(引用: Sysdig ScarletEel 2.0) 例如，在 Entra ID 环境中，具有应用程序管理员角色的对手可以向其应用程序的服务主体添加一组新的凭据。通过这样做，对手将能够访问服务主体的角色和权限，这些角色和权限可能与应用程序管理员的不同。(引用: SpecterOps Azure Privilege Escalation)  在 AWS 环境中，具有适当权限的对手还可以使用 `sts:GetFederationToken` API 调用创建一组临时凭据，以[伪造 Web 凭据](https://attack.mitre.org/techniques/T1606)，这些凭据与原始用户账户的权限相关联。这些临时凭据可能在其生命周期内保持有效，即使原始账户的 API 凭据被停用。 (引用: Crowdstrike AWS User Federation Persistence)  在启用了应用程序密码功能的 Entra ID 环境中，对手可能能够向用户账户添加应用程序密码。(引用: Mandiant APT42 Operations 2024) 由于应用程序密码旨在用于不支持多因素身份验证 (MFA) 的旧设备，添加应用程序密码可以允许对手绕过 MFA 要求。此外，即使用户的主密码被重置，应用程序密码也可能保持有效。(引用: Microsoft Entra ID App Passwords) |
| [T1098.002](../techniques/T1098.002.md) | 额外的电子邮件委托权限 | 攻击者可能会授予额外的权限级别，以保持对攻击者控制的电子邮件帐户的持久访问。  例如，<code>Add-MailboxPermission</code> [PowerShell](https://attack.mitre.org/techniques/T1059/001) cmdlet（在本地Exchange和基于云的服务Office 365中可用）向邮箱添加权限。(引用: Microsoft - Add-MailboxPermission)(引用: FireEye APT35 2018)(引用: Crowdstrike Hiding in Plain Sight 2018) 在Google Workspace中，可以通过Google Admin控制台启用委托，用户可以通过其Gmail设置委托帐户。(引用: Gmail委托)(引用: Google确保您的信息安全)  攻击者还可以通过单独的文件夹权限或角色分配邮箱文件夹权限。在Office 365环境中，攻击者可能会为“信息存储顶部”（根目录）、收件箱或其他邮箱文件夹分配默认或匿名用户权限或角色。通过为一个文件夹分配一个或两个用户权限，攻击者可以利用租户中的任何其他帐户来保持对目标用户邮件文件夹的持久访问。(引用: Mandiant Defend UNC2452白皮书)  这可能用于持久威胁事件以及BEC（商业电子邮件入侵）事件，其中攻击者可以向他们希望入侵的帐户添加[额外的云角色](https://attack.mitre.org/techniques/T1098/003)。这可能进一步启用其他技术以获取系统访问权限。例如，受入侵的业务帐户通常用于向目标业务网络中的其他帐户发送消息，同时创建收件箱规则（例如：[内部鱼叉式钓鱼](https://attack.mitre.org/techniques/T1534)），以便消息规避垃圾邮件/钓鱼检测机制。(引用: Bienstock, D. - 防御O365 - 2019) |
| [T1098.003](../techniques/T1098.003.md) | 附加云角色 | 对手可能会向对手控制的云帐户添加附加角色或权限，以保持对租户的持久访问。例如，对手可能会在基于云的环境中更新 IAM 策略，或在 Office 365 环境中添加新的全局管理员。(引用: AWS IAM Policies and Permissions)(引用: Google Cloud IAM Policies)(引用: Microsoft Support O365 Add Another Admin, October 2019)(引用: Microsoft O365 Admin Roles) 具有足够权限的情况下，受损帐户可以获得几乎无限的访问数据和设置的权限（包括重置其他管理员密码的能力）。(引用: Expel AWS Attacker) (引用: Microsoft O365 Admin Roles)   此帐户修改可能紧随[创建帐户](https://attack.mitre.org/techniques/T1136)或其他恶意帐户活动之后。对手还可能修改他们已破坏的现有[有效帐户](https://attack.mitre.org/techniques/T1078)。这可能导致权限提升，特别是如果添加的角色允许横向移动到其他帐户。  例如，在 AWS 环境中，具有适当权限的对手可能能够使用 <code>CreatePolicyVersion</code> API 定义 IAM 策略的新版本，或使用 <code>AttachUserPolicy</code> API 将具有附加或不同权限的 IAM 策略附加到受损用户帐户。(引用: Rhino Security Labs AWS Privilege Escalation)  在某些情况下，对手可能会向受害者云租户之外的对手控制的帐户添加角色。这允许这些外部帐户在受害者租户内执行操作，而无需对手[创建帐户](https://attack.mitre.org/techniques/T1136)或修改受害者拥有的帐户。(引用: Invictus IR DangerDev 2024) |
| [T1098.004](../techniques/T1098.004.md) | SSH 授权密钥 | 对手可能会修改 SSH <code>authorized_keys</code> 文件以在受害者主机上保持持久性。Linux 发行版和 macOS 通常使用基于密钥的身份验证来保护 SSH 会话的身份验证过程以进行远程管理。SSH 中的 <code>authorized_keys</code> 文件指定可用于登录配置该文件的用户帐户的 SSH 密钥。此文件通常位于用户主目录下的 <code>&lt;user-home&gt;/.ssh/authorized_keys</code>。(引用: SSH Authorized Keys) 用户可以编辑系统的 SSH 配置文件，将指令 PubkeyAuthentication 和 RSAAuthentication 修改为值“yes”以确保启用公钥和 RSA 身份验证。SSH 配置文件通常位于 <code>/etc/ssh/sshd_config</code> 下。  对手可能会直接使用脚本或 shell 命令修改 SSH <code>authorized_keys</code> 文件以添加他们自己提供的公钥。在云环境中，对手可能能够通过命令行界面或 REST API 修改特定虚拟机的 SSH authorized_keys 文件。例如，通过使用 Google Cloud CLI 的“add-metadata”命令，对手可以向用户帐户添加 SSH 密钥。(引用: Google Cloud Add Metadata)(引用: Google Cloud Privilege Escalation) 类似地，在 Azure 中，对手可以通过向 API 发送 PATCH 请求来更新虚拟机的 authorized_keys 文件。(引用: Azure Update Virtual Machines) 这确保了拥有相应私钥的对手可以通过 SSH 以现有用户身份登录。(引用: Venafi SSH Key Abuse)(引用: Cybereason Linux Exim Worm) 这也可能导致权限提升，其中虚拟机或实例具有与请求用户不同的权限。  如果通过云 API 或命令行界面修改 authorized_keys 文件，对手可能会在目标虚拟机上实现权限提升，如果他们向更高权限的用户添加密钥。  SSH 密钥也可以添加到网络设备上的帐户，例如使用 `ip ssh pubkey-chain` [网络设备 CLI](https://attack.mitre.org/techniques/T1059/008) 命令。(引用: cisco_ip_ssh_pubkey_ch_cmd) |
| [T1098.005](../techniques/T1098.005.md) | 设备注册 | 对手可能会将设备注册到对手控制的帐户。设备可以注册到多因素身份验证 (MFA) 系统，该系统处理对网络的身份验证，或注册到设备管理系统，该系统处理设备访问和合规性。  MFA 系统（例如 Duo 或 Okta）允许用户将设备与其帐户关联，以完成 MFA 要求。对手如果破坏了用户的凭据，可能会注册新设备以绕过初始 MFA 要求并获得对网络的持续访问。(引用: CISA MFA PrintNightmare)(引用: DarkReading FireEye SolarWinds) 在某些情况下，MFA 自助注册过程可能只需要用户名和密码即可注册帐户的第一个设备或注册到不活跃的帐户。(引用: Mandiant APT29 Microsoft 365 2022)  同样，具有现有网络访问权限的对手可能会将设备注册到 Entra ID 和/或其设备管理系统 Microsoft Intune，以便在绕过条件访问策略的情况下访问敏感数据或资源。(引用: AADInternals - Device Registration)(引用: AADInternals - Conditional Access Bypass)(引用: Microsoft DEV-0537)   注册到 Entra ID 的设备可能能够通过组织内部电子邮件进行 [内部鱼叉式网络钓鱼](https://attack.mitre.org/techniques/T1534) 活动，这些电子邮件不太可能被电子邮件客户端视为可疑。(引用: Microsoft - Device Registration) 此外，对手可能能够通过注册大量设备对 Entra ID 租户执行 [服务耗尽泛洪](https://attack.mitre.org/techniques/T1499/002)。(引用: AADInternals - BPRT) |
| [T1098.006](../techniques/T1098.006.md) | 附加容器集群角色 | 对手可能会向对手控制的用户或服务账户添加附加角色或权限，以保持对容器编排系统的持久访问。例如，具有足够权限的对手可能会创建 RoleBinding 或 ClusterRoleBinding，将角色或集群角色绑定到 Kubernetes 账户。(引用: Kubernetes RBAC)(引用: Aquasec Kubernetes Attack 2023) 在使用基于属性的访问控制 (ABAC) 的情况下，具有足够权限的对手可能会修改 Kubernetes ABAC 策略，以赋予目标账户额外的权限。(引用: Kuberentes ABAC)  此账户修改可能紧随[创建账户](https://attack.mitre.org/techniques/T1136)或其他恶意账户活动之后。对手还可能修改他们已破坏的现有[有效账户](https://attack.mitre.org/techniques/T1078)。  请注意，在云环境中部署的容器编排系统（如 Google Kubernetes Engine、Amazon Elastic Kubernetes Service 和 Azure Kubernetes Service）中，云角色基于访问控制 (RBAC) 分配或 ABAC 策略通常可以替代或补充本地权限分配。(引用: Google Cloud Kubernetes IAM)(引用: AWS EKS IAM Roles for Service Accounts)(引用: Microsoft Azure Kubernetes Service Service Accounts) 在这些情况下，此技术可能与[附加云角色](https://attack.mitre.org/techniques/T1098/003)结合使用。 |
| [T1098.007](../techniques/T1098.007.md) | 附加本地或域组 | 对手可能会向对手控制的账户添加附加本地或域组，以在系统或域中保持持久访问。  在Windows上，账户可以使用`net localgroup`和`net group`命令将现有用户添加到本地和域组。(引用: Microsoft Net Localgroup)(引用: Microsoft Net Group) 在Linux上，对手可能会使用`usermod`命令实现相同的目的。(引用: Linux Usermod)  例如，账户可能会被添加到Windows设备上的本地管理员组，以保持提升的权限。它们还可能被添加到远程桌面用户组，这允许它们利用[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)将来登录到终端。(引用: Microsoft RDP Logons) 在Linux上，账户可能会被添加到sudoers组，允许它们持久地利用[使用Sudo和Sudo缓存](https://attack.mitre.org/techniques/T1548/003)获得提升的权限。  在Windows环境中，机器账户也可能被添加到域组。这允许本地SYSTEM账户在域上获得权限。(引用: RootDSE AD Detection 2022) |
| [T1134](../techniques/T1134.md) | 访问令牌操纵 | 对手可能会修改访问令牌以在不同用户或系统安全上下文下操作以执行操作并绕过访问控制。Windows使用访问令牌来确定正在运行的进程的所有权。用户可以操纵访问令牌，使正在运行的进程看起来像是属于不同进程的子进程或属于启动进程的用户以外的其他人。当发生这种情况时，进程还会采用与新令牌关联的安全上下文。  对手可以使用内置的Windows API函数从现有进程中复制访问令牌；这称为令牌窃取。这些令牌可以应用于现有进程（即[令牌冒充/窃取](https://attack.mitre.org/techniques/T1134/001)）或用于生成新进程（即[使用令牌创建进程](https://attack.mitre.org/techniques/T1134/002)）。对手必须已经处于特权用户上下文（即管理员）才能窃取令牌。然而，对手通常使用令牌窃取将其安全上下文从管理员级别提升到SYSTEM级别。如果账户在远程系统上具有适当权限，对手可以使用令牌作为该账户进行身份验证。(引用: Pentestlab Token Manipulation)  任何标准用户都可以使用<code>runas</code>命令和Windows API函数创建冒充令牌；这不需要访问管理员账户。还有其他机制，如Active Directory字段，可以用来修改访问令牌。 |
| [T1134.001](../techniques/T1134.001.md) | 令牌模拟/盗用 | 对手可能会复制然后模拟其他用户的现有令牌以提升权限并绕过访问控制。例如，对手可以使用 `DuplicateToken` 或 `DuplicateTokenEx` 复制现有令牌。(引用: DuplicateToken function) 然后可以使用 `ImpersonateLoggedOnUser` 允许调用线程模拟已登录用户的安全上下文，或使用 `SetThreadToken` 将模拟的令牌分配给线程。  当对手有特定的现有进程要分配复制的令牌时，可能会执行[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)。例如，当目标用户在系统上有非网络登录会话时，这可能很有用。  当对手使用复制的令牌创建新进程而不是附加到现有进程时，他们还可以使用 `CreateProcessWithTokenW` 或 `CreateProcessAsUserW` [使用令牌创建进程](https://attack.mitre.org/techniques/T1134/002)。[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001) 也与[创建和模拟令牌](https://attack.mitre.org/techniques/T1134/003)不同，因为它指的是复制现有令牌，而不是创建新令牌。 |
| [T1134.002](../techniques/T1134.002.md) | 使用令牌创建进程 | 对手可能会使用现有令牌创建新进程，以提升权限并绕过访问控制。可以使用 <code>CreateProcessWithTokenW</code> 和 <code>runas</code> 等功能创建具有另一个用户令牌和结果安全上下文的进程。(引用: Microsoft RunAs)  使用与当前用户不关联的令牌创建进程可能需要目标用户的凭据、模拟该用户的特定权限或访问要使用的令牌。例如，可以通过[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)复制令牌或通过[创建和模拟令牌](https://attack.mitre.org/techniques/T1134/003)创建令牌，然后使用它来创建进程。  虽然此技术与[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)不同，但可以结合使用这些技术，其中令牌被复制，然后用于创建新进程。 |
| [T1134.003](../techniques/T1134.003.md) | 创建和模拟令牌 | 对手可能会创建新令牌并模拟用户以提升权限并绕过访问控制。例如，如果对手有用户名和密码，但用户未登录系统，对手可以使用`LogonUser`函数为用户创建一个登录会话。(引用: LogonUserW function) 该函数将返回新会话的访问令牌副本，对手可以使用`SetThreadToken`将令牌分配给线程。  这种行为与[令牌模拟/盗用](https://attack.mitre.org/techniques/T1134/001)不同，因为这指的是创建新用户令牌，而不是窃取或复制现有的令牌。 |
| [T1134.004](../techniques/T1134.004.md) | 父PID欺骗 | 对手可能会伪造新进程的父进程标识符（PPID），以规避进程监控防御或提升权限。新进程通常直接从其父进程或调用进程生成，除非明确指定。通过<code>CreateProcess</code> API调用显式分配新进程的PPID是一种方法，该调用支持定义要使用的PPID的参数。(引用: DidierStevens SelectMyParent Nov 2009) 此功能由Windows功能（如用户帐户控制（UAC））使用，以在请求的提升进程由SYSTEM（通常通过<code>svchost.exe</code>或<code>consent.exe</code>）生成而不是当前用户上下文时正确设置PPID。(引用: Microsoft UAC Nov 2018)  对手可能会滥用这些机制来规避防御，例如阻止直接从Office文档生成进程的防御，以及针对异常/潜在恶意的父子进程关系的分析，例如将[PowerShell](https://attack.mitre.org/techniques/T1059/001)/[Rundll32](https://attack.mitre.org/techniques/T1218/011)的PPID伪装为<code>explorer.exe</code>而不是作为[鱼叉式网络钓鱼附件](https://attack.mitre.org/techniques/T1566/001)的一部分交付的Office文档。(引用: CounterCept PPID Spoofing Dec 2018) 这种欺骗可以通过恶意Office文档中的[Visual Basic](https://attack.mitre.org/techniques/T1059/005)或任何可以执行[本机API](https://attack.mitre.org/techniques/T1106)的代码来执行。(引用: CTD PPID Spoofing Macro Mar 2019)(引用: CounterCept PPID Spoofing Dec 2018)  显式分配PPID还可能在具有适当访问权限的父进程的情况下启用提升的权限。例如，具有特权用户上下文（即管理员）的对手可能会生成一个新进程，并将父进程分配为以SYSTEM身份运行的进程（如<code>lsass.exe</code>），从而通过继承的访问令牌提升新进程的权限。(引用: XPNSec PPID Nov 2017) |
| [T1134.005](../techniques/T1134.005.md) | SID 历史注入 | 对手可能使用 SID 历史注入来提升权限并绕过访问控制。Windows 安全标识符 (SID) 是标识用户或组账户的唯一值。SID 由 Windows 安全性在安全描述符和访问令牌中使用。(引用: Microsoft SID) 账户可以在 SID-History Active Directory 属性中保存其他 SID 值(引用: Microsoft SID-History Attribute)，允许域之间的互操作账户迁移（例如，SID-History 中的所有值都包含在访问令牌中）。  通过域管理员（或等效）权限，可以插入收集到的或众所周知的 SID 值(引用: Microsoft Well Known SIDs Jun 2017) 到 SID-History 中，以便模拟任意用户/组，例如企业管理员。这种操作可能导致对本地资源的提升访问权限和/或通过横向移动技术（如[远程服务](https://attack.mitre.org/techniques/T1021)、[SMB/Windows 管理共享](https://attack.mitre.org/techniques/T1021/002) 或 [Windows 远程管理](https://attack.mitre.org/techniques/T1021/006)）访问其他无法访问的域。 |
| [T1484](../techniques/T1484.md) | 域或租户策略修改 | 攻击者可能会修改域或身份租户的配置设置，以在集中管理环境中规避防御和/或提升权限。此类服务提供了集中管理身份资源（如设备和账户）的手段，通常包括适用于域或租户之间的配置设置，如信任关系、身份同步或身份联合。  对域或租户设置的修改可能包括更改Microsoft Active Directory (AD)中的域组策略对象（GPO）或更改域的信任设置，包括域或租户之间的联合信任关系。  拥有足够权限的攻击者可以修改域或租户策略设置。由于这些服务的配置设置适用于大量身份资源，因此滥用此功能可能导致大量潜在的攻击和恶意后果。此类滥用的示例包括：  * 修改GPO以将恶意[计划任务](https://attack.mitre.org/techniques/T1053/005)推送到整个域环境中的计算机（引用：ADSecurity GPO Persistence 2016）（引用：Wald0 Guide to GPOs）（引用：Harmj0y Abusing GPO Permissions） * 修改域信任以包含攻击者控制的域，允许攻击者伪造访问令牌，随后被受害域资源接受（引用：Microsoft - Customer Guidance on Recent Nation-State Cyber Attacks） * 更改AD环境中的配置设置以实施[恶意域控制器](https://attack.mitre.org/techniques/T1207)。 * 向身份租户添加新的攻击者控制的联合身份提供者，允许攻击者以受害租户管理的任何用户身份进行身份验证（引用：Okta Cross-Tenant Impersonation 2023）  攻击者可能会临时修改域或租户策略，执行恶意操作，然后恢复更改以删除可疑迹象。 |
| [T1484.001](../techniques/T1484.001.md) | 组策略修改 | 对手可能会修改组策略对象 (GPO) 以颠覆域的预期自由访问控制，通常是为了在域上提升权限。组策略允许在 Active Directory (AD) 中集中管理用户和计算机设置。GPO 是包含组策略设置的容器，由存储在可预测网络路径 `\<DOMAIN>\SYSVOL\<DOMAIN>\Policies\` 中的文件组成。(引用: TechNet Group Policy Basics)(引用: ADSecurity GPO Persistence 2016)  与 AD 中的其他对象一样，GPO 具有与之关联的访问控制。默认情况下，域中的所有用户帐户都有读取 GPO 的权限。可以将 GPO 访问控制权限（例如写入访问权限）委派给域中的特定用户或组。  恶意 GPO 修改可用于实现许多其他恶意行为，例如[计划任务/作业](https://attack.mitre.org/techniques/T1053)、[禁用或修改工具](https://attack.mitre.org/techniques/T1562/001)、[入口工具传输](https://attack.mitre.org/techniques/T1105)、[创建账户](https://attack.mitre.org/techniques/T1136)、[服务执行](https://attack.mitre.org/techniques/T1569/002)等。(引用: ADSecurity GPO Persistence 2016)(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions)(引用: Mandiant M Trends 2016)(引用: Microsoft Hacking Team Breach) 由于 GPO 可以控制 AD 环境中的许多用户和计算机设置，因此可能会出现大量潜在攻击。(引用: Wald0 Guide to GPOs)  例如，可以利用公开可用的脚本（如 <code>New-GPOImmediateTask</code>）通过修改 GPO 设置自动创建恶意[计划任务/作业](https://attack.mitre.org/techniques/T1053)，在这种情况下，修改 <code>&lt;GPO_PATH&gt;\Machine\Preferences\ScheduledTasks\ScheduledTasks.xml</code>。(引用: Wald0 Guide to GPOs)(引用: Harmj0y Abusing GPO Permissions) 在某些情况下，对手可能会修改特定用户权限，如 SeEnableDelegationPrivilege，设置在 <code>&lt;GPO_PATH&gt;\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code> 中，以实现对域的完全控制，因为对手控制的用户帐户将能够修改 GPO。(引用: Harmj0y SeEnableDelegationPrivilege Right) |
| [T1484.002](../techniques/T1484.002.md) | 信任修改 | 对手可能会添加新的域信任，修改现有域信任的属性，或以其他方式更改域和租户之间的信任关系配置，以规避防御和/或提升权限。信任详细信息，例如用户身份是否联合，允许身份验证和授权属性在域或租户之间应用，以访问共享资源。(引用: Microsoft - Azure AD Federation) 这些信任对象可能包括应用于服务器、令牌和域的帐户、凭据和其他身份验证材料。  操纵这些信任可能允许对手通过修改设置以添加他们控制的对象来提升权限和/或规避防御。例如，在 Microsoft Active Directory (AD) 环境中，这可以用来伪造[SAML 令牌](https://attack.mitre.org/techniques/T1606/002)，而无需破坏签名证书来伪造新凭据。相反，对手可以操纵域信任以添加自己的签名证书。对手还可以使用 Active Directory 联合服务 (AD FS) 将 AD 域转换为联合域，这可能使恶意信任修改成为可能，例如更改声明发布规则，以指定用户身份登录任何有效的凭据集。(引用: AADInternals zure AD Federated Domain)  对手还可以向身份租户（如 Okta 或 AWS IAM 身份中心）添加新的联合身份提供者，这可能使对手能够以租户的任何用户身份进行身份验证。(引用: Okta Cross-Tenant Impersonation 2023) 这可能使威胁行为者能够广泛访问利用身份租户的各种基于云的服务。例如，在 AWS 环境中，创建新身份提供者的对手将能够联合到所有 AWS 组织成员帐户，而无需为每个成员帐户创建身份。(引用: AWS RE:Inforce Threat Detection 2024) |
| [T1543](../techniques/T1543.md) | 创建或修改系统进程 | 对手可能会创建或修改系统级进程以重复执行恶意有效负载作为持久性的一部分。当操作系统启动时，它们可以启动执行后台系统功能的进程。在 Windows 和 Linux 上，这些系统进程称为服务。(引用: TechNet Services) 在 macOS 上，称为 [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) 和 [Launch Agent](https://attack.mitre.org/techniques/T1543/001) 的 launchd 进程用于完成系统初始化并加载用户特定参数。(引用: AppleDocs Launch Agent Daemons)  对手可能会安装新的服务、守护进程或代理，这些可以配置为在启动时或在可重复的时间间隔执行，以建立持久性。同样，对手可能会修改现有的服务、守护进程或代理以实现相同的效果。  服务、守护进程或代理可能会以管理员权限创建，但以 root/SYSTEM 权限执行。对手可能会利用此功能创建或修改系统进程以提升权限。(引用: OSX Malware Detection) |
| [T1543.001](../techniques/T1543.001.md) | 启动代理 | 对手可能会创建或修改启动代理，以在持久性的一部分中反复执行恶意负载。当用户登录时，会启动一个每用户的 launchd 进程，该进程从 <code>/System/Library/LaunchAgents</code>、<code>/Library/LaunchAgents</code> 和 <code>~/Library/LaunchAgents</code> 中找到的属性列表 (.plist) 文件中加载每个按需启动的用户代理的参数。(引用: AppleDocs Launch Agent Daemons)(引用: OSX Keydnap malware) (引用: Antiquated Mac Malware) 属性列表文件使用 <code>Label</code>、<code>ProgramArguments</code> 和 <code>RunAtLoad</code> 键来标识启动代理的名称、可执行文件位置和执行时间。(引用: OSX.Dok Malware) 启动代理通常安装以执行程序更新、在登录时启动用户指定的程序或执行其他开发人员任务。   启动代理还可以使用 [Launchctl](https://attack.mitre.org/techniques/T1569/001) 命令执行。   对手可能会通过将 .plist 文件放入适当的文件夹中并将 <code>RunAtLoad</code> 或 <code>KeepAlive</code> 键设置为 <code>true</code> 来安装在登录时执行的新启动代理。(引用: Sofacy Komplex Trojan)(引用: Methods of Mac Malware Persistence) 启动代理的名称可能会通过使用相关操作系统或良性软件的名称来伪装。启动代理是以用户级别权限创建的，并以用户级别权限执行。(引用: OSX Malware Detection)(引用: OceanLotus for OS X)  |
| [T1543.002](../techniques/T1543.002.md) | Systemd服务 | 对手可能会创建或修改systemd服务，以作为持久性的一部分反复执行恶意负载。Systemd是一个系统和服务管理器，通常用于管理后台守护进程（也称为服务）和其他系统资源。(引用: Linux man-pages: systemd January 2014) Systemd是许多Linux发行版上的默认初始化(init)系统，取代了遗留的init系统，包括SysVinit和Upstart，同时保持向后兼容。  Systemd使用扩展名为.service的单元配置文件来编码有关服务进程的信息。默认情况下，系统级单元文件存储在根拥有的目录(/)的/systemd/system目录中。用户级单元文件存储在用户拥有的目录($HOME)的/systemd/user目录中。(引用: lambert systemd 2022)  在.service单元文件中，以下指令用于执行命令：(引用: freedesktop systemd.service)  * ExecStart、ExecStartPre和ExecStartPost指令在服务由systemctl手动启动或在系统启动时执行，如果服务设置为自动启动。 * ExecReload指令在服务重新启动时执行。 * ExecStop、ExecStopPre和ExecStopPost指令在服务停止时执行。  对手已经创建了新的服务文件，更改了.service文件指令执行的命令，并修改了.service文件执行的用户指令，这可能导致权限提升。对手还可能在这些目录中放置符号链接，使systemd能够找到这些负载，无论它们在文件系统中的位置。(引用: Anomali Rocke March 2019)(引用: airwalk backdoor unix systems)(引用: Rapid7 Service Persistence 22JUNE2016)  .service文件的User指令可用于以特定用户身份运行服务，这可能会根据特定用户/组权限导致权限提升。 |
| [T1543.003](../techniques/T1543.003.md) | Windows 服务 | 对手可能会创建或修改 Windows 服务，以便在持久性的一部分中重复执行恶意有效负载。当 Windows 启动时，它会启动称为服务的程序或应用程序，这些程序或应用程序执行后台系统功能。(引用: TechNet Services) Windows 服务配置信息，包括服务可执行文件或恢复程序/命令的文件路径，存储在 Windows 注册表中。  对手可能会安装新服务或修改现有服务，以便在启动时执行以在系统上保持持久性。可以使用系统实用程序（如 sc.exe）设置或修改服务配置，通过直接修改注册表，或通过直接与 Windows API 交互。  对手还可能使用服务安装和执行恶意驱动程序。例如，在将驱动程序文件（例如 .sys）放到磁盘后，可以通过[本机 API](https://attack.mitre.org/techniques/T1106)函数（如 `CreateServiceW()`）加载和注册有效负载（或通过函数如 `ZwLoadDriver()` 和 `ZwSetValueKey()` 手动），通过创建所需的服务注册表值（即[修改注册表](https://attack.mitre.org/techniques/T1112)），或通过使用命令行实用程序如 `PnPUtil.exe`。(引用: Symantec W.32 Stuxnet Dossier)(引用: Crowdstrike DriveSlayer February 2022)(引用: Unit42 AcidBox June 2020) 对手可能利用这些驱动程序作为[Rootkit](https://attack.mitre.org/techniques/T1014)来隐藏系统上的恶意活动。对手还可能将签名但易受攻击的驱动程序加载到受感染的机器上（称为“自带易受攻击的驱动程序” (BYOVD)），作为[特权提升利用](https://attack.mitre.org/techniques/T1068)的一部分。(引用: ESET InvisiMole June 2020)(引用: Unit42 AcidBox June 2020)  服务可能以管理员权限创建，但以 SYSTEM 权限执行，因此对手也可能使用服务来提升权限。对手还可能通过[服务执行](https://attack.mitre.org/techniques/T1569/002)直接启动服务。  为了使检测分析更加困难，恶意服务还可能包含[伪装任务或服务](https://attack.mitre.org/techniques/T1036/004)（例如，使用与合法操作系统或良性软件组件相关的服务和/或有效负载名称）。对手还可能创建“隐藏”服务（即，[隐藏工件](https://attack.mitre.org/techniques/T1564)），例如通过使用 `sc sdset` 命令通过服务描述符定义语言 (SDDL) 设置服务权限。这可能会隐藏 Windows 服务，使其无法通过标准服务枚举方法（如 `Get-Service`、`sc query` 和 `services.exe`）查看。(引用: SANS 1)(引用: SANS 2) |
| [T1543.004](../techniques/T1543.004.md) | 启动守护程序 | 对手可能会创建或修改启动守护程序以执行恶意有效负载作为持久性的一部分。启动守护程序是用于与Launchd交互的plist文件，Launchd是macOS使用的服务管理框架。安装启动守护程序需要提升的权限，它们在系统登录前为每个用户执行，并在后台运行而无需用户交互。在macOS初始化启动期间，launchd进程从<code>/System/Library/LaunchDaemons/</code>和<code>/Library/LaunchDaemons/</code>中的plist文件加载按需启动的系统级守护程序的参数。启动守护程序的必需参数包括用于标识任务的<code>Label</code>，提供可执行文件路径的<code>Program</code>，以及指定任务何时运行的<code>RunAtLoad</code>。启动守护程序通常用于提供对共享资源的访问、软件更新或执行自动化任务。(引用: AppleDocs Launch Agent Daemons)(引用: Methods of Mac Malware Persistence)(引用: launchd Keywords for plists)  对手可能会通过使用<code>RunAtLoad</code>参数设置为<code>true</code>和<code>Program</code>参数设置为恶意可执行文件路径来安装配置为在启动时执行的启动守护程序。守护程序名称可能会通过使用相关操作系统或良性软件的名称进行伪装（即[伪装](https://attack.mitre.org/techniques/T1036)）。当启动守护程序执行时，程序继承管理员权限。(引用: WireLurker)(引用: OSX Malware Detection)  此外，系统配置更改（例如安装第三方包管理软件）可能会导致文件夹如<code>usr/local/bin</code>变得全局可写。因此，配置不当可能允许对手修改当前启动守护程序的plist文件引用的可执行文件。(引用: LaunchDaemon Hijacking)(引用: sentinelone macos persist Jun 2019) |
| [T1543.005](../techniques/T1543.005.md) | 容器服务 | 对手可能会创建或修改在单个主机上作为守护进程、代理或服务运行的容器或容器集群管理工具。这些工具包括用于创建和管理单个容器的软件，如 Docker 和 Podman，以及容器集群节点级代理，如 kubelet。通过修改这些服务，对手可能能够在主机上实现持久性或提升其权限。  例如，通过使用带有 `restart=always` 指令的 `docker run` 或 `podman run` 命令，可以将容器配置为在主机上持久重启。(引用: AquaSec TeamTNT 2023) 具有（root）docker 命令访问权限的用户也可能能够在主机上提升其权限。(引用: GTFOBins Docker)  在 Kubernetes 环境中，DaemonSets 允许对手在所有节点上持久性地[部署容器](https://attack.mitre.org/techniques/T1610)，包括后来添加到集群中的节点。(引用: Aquasec Kubernetes Attack 2023)(引用: Kubernetes DaemonSet) 可以使用 pod 规范中的 `nodeSelector` 或 `nodeName` 字段将 Pod 部署到特定节点。(引用: Kubernetes Assigning Pods to Nodes)(引用: AppSecco Kubernetes Namespace Breakout 2020)  请注意，容器也可以配置为作为[Systemd 服务](https://attack.mitre.org/techniques/T1543/002)运行。(引用: Podman Systemd)(引用: Docker Systemd) |
| [T1546](../techniques/T1546.md) | 事件触发执行 | 对手可能会使用基于特定事件触发执行的系统机制来建立持久性和/或提升权限。各种操作系统都有监视和订阅事件（例如登录或运行特定应用程序/二进制文件等用户活动）的手段。云环境还可能支持各种功能和服务，这些功能和服务可以监视并响应特定的云事件。(引用: Backdooring an AWS account)(引用: Varonis Power Automate Data Exfiltration)(引用: Microsoft DART Case Report 001)  对手可能会滥用这些机制，作为通过重复执行恶意代码来保持对受害者的持久访问的一种手段。在获得受害者系统访问权限后，对手可能会创建/修改事件触发器以指向将在调用事件触发器时执行的恶意内容。(引用: FireEye WMI 2015)(引用: Malware Persistence on OS X)(引用: amnesia malware)  由于执行可以由具有更高权限的账户（例如 SYSTEM 或服务账户）代理，因此对手可能会滥用这些触发的执行机制来提升其权限。 |
| [T1546.001](../techniques/T1546.001.md) | 更改默认文件关联 | 对手可能通过执行由文件类型关联触发的恶意内容来建立持久性。当打开文件时，会检查用于打开文件的默认程序（也称为文件关联或处理程序）。文件关联选择存储在Windows注册表中，可以由用户、管理员或具有注册表访问权限的程序编辑，或者由管理员使用内置的assoc实用程序编辑。(引用: Microsoft Change Default Programs)(引用: Microsoft File Handlers)(引用: Microsoft Assoc Oct 2017) 应用程序可以修改给定文件扩展名的文件关联，以在打开具有给定扩展名的文件时调用任意程序。  系统文件关联列在<code>HKEY_CLASSES_ROOT\.[extension]</code>下，例如<code>HKEY_CLASSES_ROOT\.txt</code>。这些条目指向位于<code>HKEY_CLASSES_ROOT\\[handler]</code>的处理程序。然后，各种命令列为shell键下的子键，位于<code>HKEY_CLASSES_ROOT\\[handler]\shell\\[action]\command</code>。例如：  * <code>HKEY_CLASSES_ROOT\txtfile\shell\open\command</code> * <code>HKEY_CLASSES_ROOT\txtfile\shell\print\command</code> * <code>HKEY_CLASSES_ROOT\txtfile\shell\printto\command</code>  列出的键值是处理程序打开文件扩展名时执行的命令。对手可以修改这些值以持续执行任意命令。(引用: TrendMicro TROJ-FAKEAV OCT 2012) |
| [T1546.002](../techniques/T1546.002.md) | 屏幕保护程序 | 对手可能通过执行由用户不活动触发的恶意内容来建立持久性。屏幕保护程序是在用户不活动的可配置时间后执行的程序，由具有.scr文件扩展名的可移植可执行文件（PE）组成。(引用: Wikipedia Screensaver) Windows屏幕保护程序应用程序scrnsave.scr位于<code>C:\Windows\System32\</code>和64位Windows系统上的<code>C:\Windows\sysWOW64\</code>，以及基本Windows安装中包含的屏幕保护程序。  以下屏幕保护程序设置存储在注册表中（<code>HKCU\Control Panel\Desktop\</code>），可以被操纵以实现持久性：  * <code>SCRNSAVE.exe</code> - 设置为恶意PE路径 * <code>ScreenSaveActive</code> - 设置为'1'以启用屏幕保护程序 * <code>ScreenSaverIsSecure</code> - 设置为'0'以不要求密码解锁 * <code>ScreenSaveTimeout</code> - 设置用户不活动超时以执行屏幕保护程序  对手可以使用屏幕保护程序设置通过在用户不活动的某个时间后运行恶意软件来保持持久性。(引用: ESET Gazer Aug 2017) |
| [T1546.003](../techniques/T1546.003.md) | Windows 管理规范事件订阅 | 对手可能会通过执行由 Windows 管理规范 (WMI) 事件订阅触发的恶意内容来建立持久性和提升权限。WMI 可用于安装事件过滤器、提供程序、消费者和绑定，当定义的事件发生时执行代码。可能订阅的事件示例包括时钟时间、用户登录或计算机的运行时间。(引用: Mandiant M-Trends 2015)  对手可能会利用 WMI 的功能订阅事件，并在事件发生时执行任意代码，从而在系统上提供持久性。(引用: FireEye WMI SANS 2015)(引用: FireEye WMI 2015) 对手还可以使用 `mofcomp.exe` 将 WMI 脚本编译成 Windows 管理对象 (MOF) 文件（.mof 扩展名），这些文件可用于创建恶意订阅。(引用: Dell WMI Persistence)(引用: Microsoft MOF May 2018)  WMI 订阅执行由 WMI 提供程序主机进程 (WmiPrvSe.exe) 代理，因此可能会导致提升的 SYSTEM 权限。 |
| [T1546.004](../techniques/T1546.004.md) | Unix Shell 配置修改 | 对手可能通过执行由用户的 shell 触发的恶意命令来建立持久性。用户[Unix Shell](https://attack.mitre.org/techniques/T1059/004)在会话的不同点执行几个配置脚本，基于事件。例如，当用户打开命令行界面或远程登录（例如通过 SSH）时，会启动登录 shell。登录 shell 从系统 (<code>/etc</code>) 和用户的主目录 (<code>~/</code>) 执行脚本以配置环境。系统上的所有登录 shell 都使用 /etc/profile 启动。这些配置脚本以其目录的权限级别运行，通常用于设置环境变量、创建别名和自定义用户的环境。当 shell 退出或终止时，将执行其他 shell 脚本以确保 shell 正常退出。  对手可能会尝试通过将命令插入到 shell 自动执行的脚本中来建立持久性。以 bash 为例，大多数 GNU/Linux 系统的默认 shell，对手可能会将启动恶意二进制文件的命令添加到 <code>/etc/profile</code> 和 <code>/etc/profile.d</code> 文件中。(引用: intezer-kaiji-malware)(引用: bencane blog bashrc) 这些文件通常需要 root 权限才能修改，并且每次系统上的任何 shell 启动时都会执行。对于用户级权限，对手可以将恶意命令插入 <code>~/.bash_profile</code>、<code>~/.bash_login</code> 或 <code>~/.profile</code>，这些命令在用户打开命令行界面或远程连接时会被调用。(引用: anomali-rocke-tactics)(引用: Linux manual bash invocation) 由于系统仅执行列表顺序中的第一个现有文件，因此对手使用 <code>~/.bash_profile</code> 来确保执行。对手还利用 <code>~/.bashrc</code> 文件，如果连接是远程建立的或打开了额外的交互式 shell（例如命令行界面中的新选项卡），则会额外执行。(引用: Tsunami)(引用: anomali-rocke-tactics)(引用: anomali-linux-rabbit)(引用: Magento) 一些恶意软件在程序终止时触发执行，对手可以使用 <code>~/.bash_logout</code> 文件在会话结束时执行恶意命令。  对于 macOS，此技术的功能类似，但可能利用 zsh，这是 macOS 10.15+ 的默认 shell。当打开 Terminal.app 时，应用程序会启动 zsh 登录 shell 和 zsh 交互式 shell。登录 shell 使用 <code>/etc/profile</code>、<code>/etc/zshenv</code>、<code>/etc/zprofile</code> 和 <code>/etc/zlogin</code> 配置系统环境。(引用: ScriptingOSX zsh)(引用: PersistentJXA_leopitt)(引用: code_persistence_zsh)(引用: macOS MS office sandbox escape) 然后，登录 shell 使用 <code>~/.zprofile</code> 和 <code>~/.zlogin</code> 配置用户环境。交互式 shell 使用 <code>~/.zshrc</code> 配置用户环境。退出时，执行 <code>/etc/zlogout</code> 和 <code>~/.zlogout</code>。对于旧版程序，macOS 在启动时执行 <code>/etc/bashrc</code>。 |
| [T1546.005](../techniques/T1546.005.md) | 陷阱 | 对手可能通过执行由中断信号触发的恶意内容来建立持久性。<code>trap</code> 命令允许程序和 shell 指定在收到中断信号时将执行的命令。一个常见的情况是脚本允许优雅终止和处理常见的键盘中断，如 <code>ctrl+c</code> 和 <code>ctrl+d</code>。  对手可以使用此命令注册代码，以便在 shell 遇到特定中断时执行，作为持久性机制。陷阱命令的格式为 <code>trap '命令列表' 信号</code>，其中“命令列表”将在收到“信号”时执行。（引用：Trap 手册）（引用：Cyberciti Trap 语句） |
| [T1546.006](../techniques/T1546.006.md) | LC_LOAD_DYLIB 添加 | 对手可能通过执行受污染二进制文件触发的恶意内容来建立持久性。Mach-O 二进制文件有一系列头文件，用于在加载二进制文件时执行某些操作。Mach-O 二进制文件中的 LC_LOAD_DYLIB 头告诉 macOS 和 OS X 在执行时加载哪些动态库 (dylibs)。只要对其余字段和依赖项进行调整，这些可以随时添加到已编译的二进制文件中。(引用: Writing Bad Malware for OSX) 有工具可用于执行这些更改。  对手可能会修改 Mach-O 二进制文件头以在每次执行二进制文件时加载和执行恶意 dylibs。虽然任何更改都会使二进制文件上的数字签名失效，因为二进制文件正在被修改，但这可以通过简单地从二进制文件中删除 LC_CODE_SIGNATURE 命令来解决，以便在加载时不检查签名。(引用: Malware Persistence on OS X) |
| [T1546.007](../techniques/T1546.007.md) | Netsh Helper DLL | 对手可能通过执行由Netsh Helper DLL触发的恶意内容来建立持久性。Netsh.exe（也称为Netshell）是一个命令行脚本实用程序，用于与系统的网络配置交互。它包含添加帮助DLL以扩展实用程序功能的功能。(引用: TechNet Netsh) 注册的netsh.exe帮助DLL的路径输入到Windows注册表中的<code>HKLM\SOFTWARE\Microsoft\Netsh</code>。  对手可以使用netsh.exe帮助DLL以持久的方式触发任意代码的执行。此执行将在每次执行netsh.exe时发生，这可能会自动发生，使用另一种持久性技术，或者如果系统上存在其他软件（例如VPN），该软件在其正常功能的一部分中执行netsh.exe。(引用: Github Netsh Helper CS Beacon)(引用: Demaske Netsh Persistence) |
| [T1546.008](../techniques/T1546.008.md) | 辅助功能 | 对手可能会通过执行由辅助功能触发的恶意内容来建立持久性和/或提升权限。Windows 包含辅助功能，可以在用户登录之前通过按键组合启动（例如：当用户在 Windows 登录屏幕上时）。对手可以修改这些程序的启动方式，以在不登录系统的情况下获得命令提示符或后门。  两个常见的辅助程序是<code>C:\Windows\System32\sethc.exe</code>，按下五次 Shift 键时启动，以及<code>C:\Windows\System32\utilman.exe</code>，按下 Windows + U 键组合时启动。sethc.exe 程序通常称为“粘滞键”，对手已使用它通过远程桌面登录屏幕进行未经身份验证的访问。(引用: FireEye Hikit Rootkit)  根据 Windows 的版本，对手可能会以不同方式利用这些功能。对手常用的方法包括替换辅助功能二进制文件或注册表中指向这些二进制文件的指针/引用。在较新的 Windows 版本中，替换的二进制文件需要为 x64 系统进行数字签名，二进制文件必须位于<code>%systemdir%\</code>，并且必须受 Windows 文件或资源保护 (WFP/WRP) 保护。(引用: DEFCON2016 Sticky Keys) 可能发现[图像文件执行选项注入](https://attack.mitre.org/techniques/T1546/012)调试器方法作为一种潜在的解决方法，因为它不需要替换相应的辅助功能二进制文件。  对于 Windows XP 及更高版本以及 Windows Server 2003/R2 及更高版本上的简单二进制替换，例如，可以将程序（例如<code>C:\Windows\System32\utilman.exe</code>）替换为“cmd.exe”（或提供后门访问的其他程序）。随后，在登录屏幕上按下适当的键组合时，无论是坐在键盘前还是通过[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)连接，都将导致以 SYSTEM 权限执行替换的文件。(引用: Tilbury 2014)  还存在其他辅助功能，可能以类似方式被利用：(引用: DEFCON2016 Sticky Keys)(引用: Narrator Accessibility Abuse)  * 屏幕键盘：<code>C:\Windows\System32\osk.exe</code> * 放大镜：<code>C:\Windows\System32\Magnify.exe</code> * 讲述人：<code>C:\Windows\System32\Narrator.exe</code> * 显示切换器：<code>C:\Windows\System32\DisplaySwitch.exe</code> * 应用切换器：<code>C:\Windows\System32\AtBroker.exe</code> |
| [T1546.009](../techniques/T1546.009.md) | AppCert DLLs | 对手可能通过执行由 AppCert DLLs 触发的恶意内容来建立持久性和/或提升权限。在 <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\</code> 下的 <code>AppCertDLLs</code> 注册表项中指定的动态链接库 (DLL) 会加载到每个调用广泛使用的应用程序编程接口 (API) 函数 <code>CreateProcess</code>、<code>CreateProcessAsUser</code>、<code>CreateProcessWithLoginW</code>、<code>CreateProcessWithTokenW</code> 或 <code>WinExec</code> 的进程中。(引用: Elastic Process Injection July 2017)  类似于 [进程注入](https://attack.mitre.org/techniques/T1055)，可以滥用此值通过在计算机上的单独进程上下文中加载和运行恶意 DLL 来获得提升的权限。恶意 AppCert DLLs 还可以通过 API 活动不断触发来提供持久性。 |
| [T1546.010](../techniques/T1546.010.md) | AppInit DLLs | 对手可能通过执行由AppInit DLLs加载到进程中的恶意内容来建立持久性和/或提升权限。指定在注册表键<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</code>或<code>HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows</code>中的<code>AppInit_DLLs</code>值的动态链接库（DLL）由user32.dll加载到每个加载user32.dll的进程中。实际上，这几乎是每个程序，因为user32.dll是一个非常常见的库。(引用: Elastic Process Injection July 2017)  类似于进程注入，这些值可以被滥用，通过导致恶意DLL被加载并在计算机上的单独进程上下文中运行来获得提升的权限。(引用: AppInit Registry) 恶意AppInit DLLs还可以通过API活动的持续触发提供持久性。  在启用安全启动的情况下，AppInit DLL功能在Windows 8及更高版本中被禁用。(引用: AppInit Secure Boot) |
| [T1546.011](../techniques/T1546.011.md) | 应用程序填充 | 对手可能会通过执行由应用程序填充触发的恶意内容来建立持久性和/或提升权限。Microsoft Windows应用程序兼容性基础设施/框架（应用程序填充）是为了允许随着操作系统代码库的变化而保持软件的向后兼容性而创建的。例如，应用程序填充功能允许开发人员应用修复程序（无需重写代码）到为Windows XP创建的应用程序，使其能够在Windows 10上运行。(引用: Elastic Process Injection July 2017)  在框架内，填充被创建为在程序（或更具体地说，导入地址表）和Windows操作系统之间充当缓冲。当程序执行时，填充缓存会被引用，以确定程序是否需要使用填充数据库（.sdb）。如果需要，填充数据库使用挂钩重定向代码，以便与操作系统通信。  默认Windows安装程序（sdbinst.exe）安装的所有填充的列表保存在：  * <code>%WINDIR%\AppPatch\sysmain.sdb</code> 和 * <code>hklm\software\microsoft\windows nt\currentversion\appcompatflags\installedsdb</code>  自定义数据库存储在：  * <code>%WINDIR%\AppPatch\custom & %WINDIR%\AppPatch\AppPatch64\Custom</code> 和 * <code>hklm\software\microsoft\windows nt\currentversion\appcompatflags\custom</code>  为了保持填充的安全性，Windows设计它们在用户模式下运行，因此它们不能修改内核，并且必须具有管理员权限才能安装填充。然而，某些填充可以用于[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)（UAC和RedirectEXE）、注入DLL到进程（InjectDLL）、禁用数据执行保护（DisableNX）和结构异常处理（DisableSEH），以及拦截内存地址（GetProcAddress）。  利用这些填充可能允许对手执行多种恶意行为，例如提升权限、安装后门、禁用防御（如Windows Defender）等。(引用: FireEye Application Shimming) 填充还可以被滥用以通过受影响的程序持续调用来建立持久性。 |
| [T1546.012](../techniques/T1546.012.md) | 图像文件执行选项注入 | 对手可能会通过执行由图像文件执行选项 (IFEO) 调试器触发的恶意内容来建立持久性和/或提升权限。IFEO 使开发人员能够将调试器附加到应用程序。当创建进程时，应用程序的 IFEO 中存在的调试器将被预先添加到应用程序的名称中，有效地在调试器下启动新进程（例如 <code>C:\dbg\ntsd.exe -g notepad.exe</code>）。(引用: Microsoft Dev Blog IFEO Mar 2010)  IFEO 可以直接通过注册表或通过 GFlags 工具在全局标志中设置。(引用: Microsoft GFlags Mar 2017) IFEO 在注册表中表示为 <code>HKLM\SOFTWARE{\Wow6432Node}\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<executable></code> 下的 <code>Debugger</code> 值，其中 <code>&lt;executable&gt;</code> 是附加调试器的二进制文件。(引用: Microsoft Dev Blog IFEO Mar 2010)  IFEO 还可以启用在指定程序静默退出（即由其自身或第二个非内核模式进程过早终止）时启动任意监视程序。(引用: Microsoft Silent Process Exit NOV 2017)(引用: Oddvar Moe IFEO APR 2018) 类似于调试器，可以通过 GFlags 和/或直接修改 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\</code> 中的 IFEO 和静默进程退出注册表值来启用静默退出监视。(引用: Microsoft Silent Process Exit NOV 2017)(引用: Oddvar Moe IFEO APR 2018)  类似于[辅助功能](https://attack.mitre.org/techniques/T1546/008)，在 Windows Vista 及更高版本以及 Windows Server 2008 及更高版本上，可以修改注册表项，将“cmd.exe”或提供后门访问的其他程序配置为辅助程序（例如 utilman.exe）的“调试器”。修改注册表后，在键盘上或通过[远程桌面协议](https://attack.mitre.org/techniques/T1021/001)连接时按下登录屏幕上的适当键组合将导致以 SYSTEM 权限执行“调试器”程序。(引用: Tilbury 2014)  类似于[进程注入](https://attack.mitre.org/techniques/T1055)，这些值也可能被滥用，通过导致在计算机上的单独进程上下文中加载和运行恶意可执行文件来获得权限提升。(引用: Elastic Process Injection July 2017) 安装 IFEO 机制还可以通过持续触发调用提供持久性。  恶意软件还可能使用 IFEO 通过注册无效调试器来[削弱防御](https://attack.mitre.org/techniques/T1562)，这些调试器会重定向并有效地禁用各种系统和安全应用程序。(引用: FSecure Hupigon)(引用: Symantec Ushedix June 2008) |
| [T1546.013](../techniques/T1546.013.md) | PowerShell 配置文件 | 对手可能通过执行由 PowerShell 配置文件触发的恶意内容来获得持久性和提升权限。PowerShell 配置文件 (<code>profile.ps1</code>) 是一个在 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 启动时运行的脚本，可以用作登录脚本来自定义用户环境。  [PowerShell](https://attack.mitre.org/techniques/T1059/001) 支持根据用户或主机程序的不同而有多个配置文件。例如，不同的 PowerShell 主机程序（如 PowerShell 控制台、PowerShell ISE 或 Visual Studio Code）可以有不同的配置文件。管理员还可以配置一个适用于本地计算机上所有用户和主机程序的配置文件。(引用: Microsoft About Profiles)   对手可能会修改这些配置文件以包含任意命令、函数、模块和/或 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 驱动器以获得持久性。每次用户打开 [PowerShell](https://attack.mitre.org/techniques/T1059/001) 会话时，修改后的脚本将被执行，除非在启动时使用 <code>-NoProfile</code> 标志。(引用: ESET Turla PowerShell May 2019)   如果具有更高权限的帐户（如域管理员）加载并执行 PowerShell 配置文件中的脚本，对手还可能能够提升权限。(引用: Wits End and Shady PowerShell Profiles) |
| [T1546.014](../techniques/T1546.014.md) | Emond | 对手可能通过执行由事件监视器守护进程（emond）触发的恶意内容来获得持久性和提升权限。Emond是一个[启动守护程序](https://attack.mitre.org/techniques/T1543/004)，接受来自各种服务的事件，通过简单的规则引擎运行它们，并采取行动。位于<code>/sbin/emond</code>的emond二进制文件将加载<code>/etc/emond.d/rules/</code>目录中的任何规则，并在明确定义的事件发生时采取行动。  规则文件采用plist格式，定义名称、事件类型和采取的行动。一些事件类型的示例包括系统启动和用户认证。操作的示例是运行系统命令或发送电子邮件。如果在<code>/private/var/db/emondClients</code>路径中没有文件存在，则emond服务不会启动，该路径在[启动守护程序](https://attack.mitre.org/techniques/T1543/004)配置文件<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>中指定。(引用: xorrior emond Jan 2018)(引用: magnusviri emond Apr 2016)(引用: sentinelone macos persist Jun 2019)  对手可能通过编写规则在定义的事件发生时执行命令来滥用此服务，例如系统启动或用户认证。(引用: xorrior emond Jan 2018)(引用: magnusviri emond Apr 2016)(引用: sentinelone macos persist Jun 2019) 对手还可能通过emond服务从管理员提升到root权限，因为emond服务由[启动守护程序](https://attack.mitre.org/techniques/T1543/004)服务以root权限执行。 |
| [T1546.015](../techniques/T1546.015.md) | 组件对象模型劫持 | 对手可能通过劫持对组件对象模型 (COM) 对象的引用来执行恶意内容，从而建立持久性。COM 是 Windows 中的一个系统，用于通过操作系统实现软件组件之间的交互。(引用: Microsoft Component Object Model) 各种 COM 对象的引用存储在注册表中。  对手可以使用 COM 系统插入恶意代码，通过劫持 COM 引用和关系来执行恶意软件，以实现持久性。劫持 COM 对象需要更改注册表以替换对合法系统组件的引用，这可能导致该组件在执行时无法正常工作。当通过正常系统操作执行该系统组件时，对手的代码将被执行。(引用: GDATA COM Hijacking) 对手可能会劫持频繁使用但不太可能破坏系统稳定性的对象，以保持一致的持久性水平，同时避免导致检测的系统不稳定。 |
| [T1546.016](../techniques/T1546.016.md) | 安装包 | 对手可能会使用安装程序触发恶意内容的执行来建立持久性和提升权限。安装包是特定于操作系统的，包含操作系统在系统上安装应用程序所需的资源。安装包可以包括在安装前运行的脚本以及安装完成后运行的脚本。安装脚本在执行时可能继承提升的权限。开发人员通常使用这些脚本来准备安装环境、检查要求、下载依赖项和在安装后删除文件。(引用: Installer Package Scripting Rich Trouton)  使用合法应用程序，对手已经分发了带有修改安装脚本的应用程序以执行恶意内容。当用户安装应用程序时，他们可能需要授予管理权限以允许安装。在合法应用程序安装过程结束时，内容如macOS的`postinstall`脚本可以以继承的提升权限执行。对手可以使用这些脚本执行恶意可执行文件或安装其他恶意组件（如[启动守护程序](https://attack.mitre.org/techniques/T1543/004)）以提升权限。(引用: Application Bundle Manipulation Brandon Dalton)(引用: wardle evilquest parti)(引用: Windows AppleJeus GReAT)(引用: Debian Manual Maintainer Scripts)  根据发行版，Linux版本的安装包脚本有时称为维护脚本或安装后脚本。这些脚本可以包括`preinst`、`postinst`、`prerm`、`postrm`脚本，并在执行时以root身份运行。  对于Windows，Microsoft Installer服务使用`.msi`文件管理应用程序的安装、更新和卸载。这些安装例程也可能包括执行额外操作的指令，可能被对手滥用。(引用: Microsoft Installation Procedures) |
| [T1546.017](../techniques/T1546.017.md) | Udev规则 | 对手可能通过使用udev规则执行恶意内容来保持持久性。Udev是Linux内核设备管理器，动态管理设备节点，处理/dev目录中的伪设备文件访问，并响应硬件事件，例如插入或移除外部设备如硬盘或键盘。Udev使用带有“匹配键”的规则文件来指定硬件事件必须满足的条件，并使用“动作键”来定义应执行的操作。创建、修改或删除位于/etc/udev/rules.d/、/run/udev/rules.d/、/usr/lib/udev/rules.d/、/usr/local/lib/udev/rules.d/和/lib/udev/rules.d/中的规则文件需要root权限。规则优先级由目录和规则文件名中的数字前缀决定。(引用: Ignacio Udev research 2024)(引用: Elastic Linux Persistence 2024)  对手可能通过在udev规则文件中添加或修改规则来滥用udev子系统以执行恶意内容。例如，对手可能配置一个规则，每次应用程序访问伪设备文件（如/dev/random）时执行其二进制文件。尽管udev仅限于运行短任务，并受systemd-udevd的沙箱限制（阻止网络和文件系统访问），攻击者可能使用动作键RUN+=下的脚本命令在后台分离并运行恶意内容的进程，以绕过这些控制。(引用: Reichert aon sedexp 2024) |
| [T1547](../techniques/T1547.md) | 启动或登录自动启动执行 | 对手可能会配置系统设置，以在系统启动或登录时自动执行程序，以保持持久性或在受感染系统上获得更高的权限。操作系统可能有机制在系统启动或账户登录时自动运行程序。(引用: Microsoft Run Key)(引用: MSDN Authentication Packages)(引用: Microsoft TimeProvider)(引用: Cylance Reg Persistence Sept 2013)(引用: Linux Kernel Programming) 这些机制可能包括自动执行放置在特别指定目录中的程序，或由存储配置信息的存储库引用的程序，例如Windows注册表。对手可能通过修改或扩展内核功能来实现相同的目标。  由于某些启动或登录自动启动程序以更高的权限运行，对手可能会利用这些来提升权限。 |
| [T1547.001](../techniques/T1547.001.md) | 注册表运行键/启动文件夹 | 对手可能通过将程序添加到启动文件夹或使用注册表运行键引用它来实现持久性。在注册表或启动文件夹中添加条目将导致引用的程序在用户登录时执行。(引用: Microsoft Run Key) 这些程序将在用户的上下文中执行，并具有该账户的相关权限级别。  在Windows系统上默认创建以下运行键：  * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>  运行键可能存在于多个配置单元下。(引用: Microsoft Wow6432Node 2018)(引用: Malwarebytes Wow6432Node 2016) <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code> 也可用，但在Windows Vista及更高版本上默认未创建。注册表运行键条目可以直接引用程序或将其列为依赖项。(引用: Microsoft Run Key) 例如，可以使用RunOnceEx的“Depend”键在登录时加载DLL：<code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "C:\temp\evil[.]dll"</code> (引用: Oddvar Moe RunOnceEx Mar 2018)  将程序放置在启动文件夹中也会导致该程序在用户登录时执行。每个用户账户都有一个启动文件夹位置，以及一个系统范围的启动文件夹，无论哪个用户账户登录都会检查。当前用户的启动文件夹路径是<code>C:\Users\\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>。所有用户的启动文件夹路径是<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>。  以下注册表键可用于设置启动文件夹项以实现持久性：  * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code> * <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code> * <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code>  以下注册表键可以控制启动期间服务的自动启动：  * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code> * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</code>  使用策略设置指定启动程序会在以下两个注册表键中创建相应的值：  * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code> * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code>  列在注册表键<code>HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows</code>的加载值中的程序会自动为当前登录的用户运行。  默认情况下，注册表键<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager</code>的多字符串<code>BootExecute</code>值设置为<code>autocheck autochk *</code>。此值会导致Windows在启动时检查硬盘的文件系统完整性，如果系统异常关闭。对手可以将其他程序或进程添加到此注册表值中，这些程序或进程将在启动时自动启动。  对手可以使用这些配置位置来执行恶意软件，例如远程访问工具，以在系统重启时保持持久性。对手还可以使用[伪装](https://attack.mitre.org/techniques/T1036)使注册表条目看起来与合法程序相关。 |
| [T1547.002](../techniques/T1547.002.md) | 认证包 | 对手可能会滥用认证包在系统启动时执行DLL。Windows认证包DLL由本地安全机构（LSA）进程在系统启动时加载。它们为操作系统提供对多个登录进程和多个安全协议的支持。(引用: MSDN Authentication Packages)  对手可以使用LSA认证包提供的自动启动机制，通过在Windows注册表位置<code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\</code>中放置一个指向二进制文件的引用，并将键值设置为<code>"Authentication Packages"=&lt;target binary&gt;</code>来实现持久性。然后，当加载认证包时，系统将执行该二进制文件。 |
| [T1547.003](../techniques/T1547.003.md) | 时间提供者 | 对手可能会滥用时间提供者在系统启动时执行 DLL。Windows 时间服务 (W32Time) 使域内和域间的时间同步成为可能。（引用：Microsoft W32Time 2018 年 2 月）W32Time 时间提供者负责从硬件/网络资源检索时间戳并将这些值输出到其他网络客户端。（引用：Microsoft TimeProvider）  时间提供者实现为动态链接库 (DLL)，注册在 `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W32Time\TimeProviders\` 的子键中。（引用：Microsoft TimeProvider）时间提供者管理器由服务控制管理器指挥，在系统启动时和/或参数更改时加载并启动在此键下列出并启用的时间提供者。（引用：Microsoft TimeProvider）  对手可能会滥用此架构来建立持久性，具体方法是创建一个新的任意命名的子键，指向 `DllName` 值中的恶意 DLL。时间提供者注册需要管理员权限，但执行将在本地服务帐户的上下文中运行。（引用：Github W32Time 2017 年 10 月） |
| [T1547.004](../techniques/T1547.004.md) | Winlogon 助手 DLL | 对手可能会滥用 Winlogon 的功能，在用户登录时执行 DLL 和/或可执行文件。Winlogon.exe 是一个 Windows 组件，负责登录/注销时的操作以及由 Ctrl-Alt-Delete 触发的安全注意序列 (SAS)。<code>HKLM\Software[\\Wow6432Node\\]\Microsoft\Windows NT\CurrentVersion\Winlogon\</code> 和 <code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\</code> 中的注册表项用于管理支持 Winlogon 的其他助手程序和功能。(引用: Cylance Reg Persistence Sept 2013)  对这些注册表项的恶意修改可能会导致 Winlogon 加载并执行恶意 DLL 和/或可执行文件。具体来说，以下子键可能容易被滥用：(引用: Cylance Reg Persistence Sept 2013)  * Winlogon\Notify - 指向处理 Winlogon 事件的通知包 DLL * Winlogon\Userinit - 指向 userinit.exe，用户登录时执行的用户初始化程序 * Winlogon\Shell - 指向 explorer.exe，用户登录时执行的系统 shell  对手可能会利用这些功能反复执行恶意代码并建立持久性。 |
| [T1547.005](../techniques/T1547.005.md) | 安全支持提供者 | 对手可能会滥用安全支持提供者 (SSP) 在系统启动时执行 DLL。Windows SSP DLL 在系统启动时加载到本地安全机构 (LSA) 进程中。一旦加载到 LSA 中，SSP DLL 就可以访问存储在 Windows 中的加密和明文密码，例如任何登录用户的域密码或智能卡 PIN。  SSP 配置存储在两个注册表项中：<code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code> 和 <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\Security Packages</code>。对手可能会修改这些注册表项以添加新的 SSP，这些 SSP 将在系统下次启动时加载，或者在调用 AddSecurityPackage Windows API 函数时加载。(引用: Graeber 2014) |
| [T1547.006](../techniques/T1547.006.md) | 内核模块和扩展 | 对手可能会修改内核以在系统启动时自动执行程序。可加载内核模块（LKM）是可以按需加载和卸载到内核中的代码片段。它们扩展了内核的功能，而无需重新启动系统。例如，一种类型的模块是设备驱动程序，它允许内核访问连接到系统的硬件。(引用: Linux Kernel Programming)  恶意使用时，LKM可以是一种内核模式[Rootkit](https://attack.mitre.org/techniques/T1014)，以最高的操作系统权限（Ring 0）运行。(引用: Linux Kernel Module Programming Guide) LKM基于rootkit的常见功能包括：隐藏自身、选择性隐藏文件、进程和网络活动，以及日志篡改、提供认证的后门，并使非特权用户能够获得root访问权限。(引用: iDefense Rootkit Overview)  内核扩展，也称为kext，在macOS中用于加载功能，类似于Linux的LKM。由于内核负责执行安全性，并且内核扩展作为内核的一部分运行，因此kext不受macOS安全策略的约束。kext通过<code>kextload</code>和<code>kextunload</code>命令加载和卸载。kext需要使用开发者ID签名，该ID由Apple授予权限，允许其签名内核扩展。没有这些权限的开发者仍然可以签名kext，但除非禁用SIP，否则它们不会加载。如果启用了SIP，则在将kext添加到AuxKC之前会验证其签名。(引用: System and kernel extensions in macOS)  自macOS Catalina 10.15以来，内核扩展已被弃用，取而代之的是系统扩展。然而，kext仍然被允许作为“遗留系统扩展”，因为没有用于内核编程接口的系统扩展。(引用: Apple Kernel Extension Deprecation)  对手可以使用LKM和kext在系统上进行[持久性](https://attack.mitre.org/tactics/TA0003)和/或[权限提升](https://attack.mitre.org/tactics/TA0004)。在野外已经发现了一些示例，并且也有一些相关的开源项目。(引用: Volatility Phalanx2)(引用: CrowdStrike Linux Rootkit)(引用: GitHub Reptile)(引用: GitHub Diamorphine)(引用: RSAC 2015 San Francisco Patrick Wardle)(引用: Synack Secure Kernel Extension Broken)(引用: Securelist Ventir)(引用: Trend Micro Skidmap) |
| [T1547.007](../techniques/T1547.007.md) | 重新打开的应用程序 | 攻击者可能会修改plist文件以在用户登录时自动运行应用程序。当用户通过macOS图形用户界面（GUI）注销或重启时，系统会向用户提供一个提示，其中包含一个复选框“在重新登录时重新打开窗口”。(引用: Mac重新打开窗口) 当选中时，所有当前打开的应用程序都会添加到<code>~/Library/Preferences/ByHost</code>目录中名为<code>com.apple.loginwindow.[UUID].plist</code>的属性列表文件中。(引用: Mac恶意软件持久性方法)(引用: Wardle持久性章节) 列在此文件中的应用程序将在用户下次登录时自动重新打开。  攻击者可以通过将恶意应用程序路径添加到<code>com.apple.loginwindow.[UUID].plist</code>文件中来建立[持久性](https://attack.mitre.org/tactics/TA0003)，以便在用户登录时执行负载。 |
| [T1547.008](../techniques/T1547.008.md) | LSASS驱动程序 | 攻击者可能修改或添加LSASS驱动程序以在受感染的系统上获得持久性。Windows安全子系统是一组管理和强制执行计算机或域安全策略的组件。本地安全机构（LSA）是负责本地安全策略和用户身份验证的主要组件。LSA包括与各种其他安全功能相关的多个动态链接库（DLL），所有这些都在LSA子系统服务（LSASS）lsass.exe进程的上下文中运行。(Citation: Microsoft Security Subsystem)  攻击者可能针对LSASS驱动程序以获得持久性。通过替换或添加非法驱动程序（例如，[Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)），攻击者可以使用LSA操作持续执行恶意负载。 |
| [T1547.009](../techniques/T1547.009.md) | 快捷方式修改 | 对手可能会创建或修改快捷方式，以便在系统启动或用户登录期间执行程序。快捷方式或符号链接用于引用其他文件或程序，当快捷方式被点击或由系统启动过程执行时，将打开或执行这些文件或程序。  对手可能会滥用启动文件夹中的快捷方式来执行他们的工具并实现持久性。(引用: Shortcut for Persistence) 虽然通常用作感染链中的有效负载（例如[鱼叉式网络钓鱼附件](https://attack.mitre.org/techniques/T1566/001)），对手也可能创建一个新的快捷方式作为间接手段，同时滥用[伪装](https://attack.mitre.org/techniques/T1036)使恶意快捷方式看起来像合法程序。对手还可以编辑目标路径或完全替换现有快捷方式，以便执行他们的恶意软件而不是预期的合法程序。  快捷方式还可以通过实现其他方法来滥用以建立持久性。例如，LNK 浏览器扩展可能会被修改（例如[浏览器扩展](https://attack.mitre.org/techniques/T1176)）以持久地启动恶意软件。 |
| [T1547.010](../techniques/T1547.010.md) | 端口监视器 | 对手可能会使用端口监视器在系统启动期间运行对手提供的DLL，以实现持久性或权限提升。可以通过<code>AddMonitor</code> API调用设置端口监视器，以设置在启动时加载的DLL。(引用: AddMonitor) 该DLL可以位于<code>C:\Windows\System32</code>中，并将在启动时由打印后台处理程序服务`spoolsv.exe`加载并运行，具有SYSTEM级别权限。(引用: Bloxham)  或者，如果权限允许写入DLL的完全限定路径名，则可以加载任意DLL到<code>HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors</code>的现有或新任意命名子键的`Driver`值。注册表项包含以下条目的条目：  * 本地端口 * 标准TCP/IP端口 * USB监视器 * WSD端口  |
| [T1547.012](../techniques/T1547.012.md) | 打印处理器 | 对手可能会滥用打印处理器，在系统启动期间运行恶意 DLL 以实现持久性和/或权限提升。打印处理器是由打印后台处理程序服务 `spoolsv.exe` 在启动期间加载的 DLL。(引用: Microsoft Intro Print Processors)  对手可能通过添加在启动时加载恶意 DLL 的打印处理器来滥用打印后台处理程序服务。可以通过具有 <code>SeLoadDriverPrivilege</code> 权限的帐户使用 <code>AddPrintProcessor</code> API 调用安装打印处理器。或者，可以通过添加指向 DLL 的 <code>HKLM\SYSTEM\\[CurrentControlSet or ControlSet001]\Control\Print\Environments\\[Windows architecture: e.g., Windows x64]\Print Processors\\[user defined]\Driver</code> 注册表项将打印处理器注册到打印后台处理程序服务。  为了正确安装恶意打印处理器，有效负载必须位于专用系统打印处理器目录中，可以通过 <code>GetPrintProcessorDirectory</code> API 调用找到该目录，或通过该目录的相对路径引用。(引用: Microsoft AddPrintProcessor May 2018) 安装打印处理器后，必须重新启动打印后台处理程序服务（在启动时启动），以便它们运行。(引用: ESET PipeMon May 2020)  打印后台处理程序服务在 SYSTEM 级别权限下运行，因此由对手安装的打印处理器可能在提升的权限下运行。 |
| [T1547.013](../techniques/T1547.013.md) | XDG自动启动条目 | 对手可能会添加或修改XDG自动启动条目，以在用户桌面环境加载时执行恶意程序或命令。XDG自动启动条目适用于任何符合XDG的Linux系统。XDG自动启动条目使用桌面条目文件(.desktop)配置用户的桌面环境在用户登录时加载。这些配置文件确定用户登录时启动的应用程序，定义打开特定文件类型的关联应用程序，并定义用于打开可移动媒体的应用程序。(引用: Free Desktop Application Autostart Feb 2006)(引用: Free Desktop Entry Keys)  对手可能会滥用此功能，通过将恶意二进制文件或命令的路径添加到.desktop配置文件中的Exec指令来建立持久性。当用户桌面环境在用户登录时加载时，位于XDG自动启动目录中的.desktop文件会自动执行。系统范围的自动启动条目位于/etc/xdg/autostart目录中，而用户条目位于~/.config/autostart目录中。  对手可能会将此技术与[伪装](https://attack.mitre.org/techniques/T1036)结合使用，以将恶意自动启动条目与合法程序混合。(引用: Red Canary Netwire Linux 2022) |
| [T1547.014](../techniques/T1547.014.md) | 活动设置 | 对手可能通过向本地计算机的活动设置添加注册表项来实现持久性。活动设置是一个Windows机制，用于在用户登录时执行程序。存储在注册表项中的值将在用户登录计算机后执行。(引用: Klein Active Setup 2010) 这些程序将在用户的上下文中执行，并具有账户的相关权限级别。  对手可能通过在<code> HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\</code>下创建一个键并为<code>StubPath</code>设置恶意值来滥用活动设置。此值将作为用户登录计算机时执行的程序。(引用: Mandiant Glyer APT 2010)(引用: Citizenlab Packrat 2015)(引用: FireEye CFR Watering Hole 2012)(引用: SECURELIST Bright Star 2015)(引用: paloalto Tropic Trooper 2016)  对手可以滥用这些组件来执行恶意软件，例如远程访问工具，以通过系统重启保持持久性。对手还可能使用[伪装](https://attack.mitre.org/techniques/T1036)使注册表项看起来像是与合法程序相关联。 |
| [T1547.015](../techniques/T1547.015.md) | 登录项 | 对手可能会添加登录项以在用户登录时执行，以获得持久性或提升权限。登录项是用户登录时自动启动的应用程序、文档、文件夹或服务器连接。(引用: Open Login Items Apple) 登录项可以通过共享文件列表或服务管理框架添加。(引用: Adding Login Items) 共享文件列表登录项可以使用脚本语言（如 [AppleScript](https://attack.mitre.org/techniques/T1059/002)）设置，而服务管理框架使用 API 调用 <code>SMLoginItemSetEnabled</code>。  使用服务管理框架安装的登录项利用 <code>launchd</code>，在系统偏好设置中不可见，并且只能由创建它们的应用程序删除。(引用: Adding Login Items)(引用: SMLoginItemSetEnabled Schroeder 2013) 使用共享文件列表创建的登录项在系统偏好设置中可见，可以在启动时隐藏应用程序，并通过 LaunchServices 而不是 launchd 执行，以打开应用程序、文档或 URL，而无需使用 Finder。(引用: Launch Services Apple Developer) 用户和应用程序使用登录项来配置其用户环境，以启动常用的服务或应用程序，例如电子邮件、聊天和音乐应用程序。  对手可以利用 [AppleScript](https://attack.mitre.org/techniques/T1059/002) 和 [Native API](https://attack.mitre.org/techniques/T1106) 调用创建登录项以生成恶意可执行文件。(引用: ELC Running at startup) 在 macOS 10.5 之前的版本中，对手可以使用 [AppleScript](https://attack.mitre.org/techniques/T1059/002) 向“系统事件”进程发送 Apple 事件来添加登录项，该进程具有用于操作登录项的 AppleScript 字典。(引用: Login Items AE) 对手可以使用命令 <code>tell application “System Events” to make login item at end with properties /path/to/executable</code>。(引用: Startup Items Eclectic)(引用: hexed osx.dok analysis 2019)(引用: Add List Remove Login Items Apple Script) 此命令将恶意可执行文件的路径添加到位于 <code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent/backgrounditems.btm</code> 的登录项文件列表中。(引用: Startup Items Eclectic) 对手还可以使用登录项启动可用于远程控制受害者系统的可执行文件，或通过提示用户凭据来获得权限提升。(引用: objsee mac malware 2017)(引用: CheckPoint Dok)(引用: objsee netwire backdoor 2019) |
| [T1548](../techniques/T1548.md) | 滥用提升控制机制 | 对手可能会绕过旨在控制提升权限的机制，以获得更高级别的权限。大多数现代系统包含本机提升控制机制，旨在限制用户在计算机上执行的权限。必须授权特定用户才能执行被认为具有较高风险的任务。(引用: TechNet How UAC Works)(引用: sudo man page 2018) 对手可以通过多种方法利用内置控制机制，以在系统上提升权限。(引用: OSX Keydnap malware)(引用: Fortinet Fareit) |
| [T1548.001](../techniques/T1548.001.md) | Setuid 和 Setgid | 对手可能会滥用配置，其中应用程序设置了 setuid 或 setgid 位，以便在不同（可能更高级别）用户的上下文中运行代码。在 Linux 或 macOS 上，当为应用程序二进制文件设置 setuid 或 setgid 位时，应用程序将以拥有用户或组的权限运行。(引用: setuid man page) 通常，应用程序在当前用户的上下文中运行，无论哪个用户或组拥有应用程序。然而，在某些情况下，程序需要在提升的上下文中执行才能正常运行，但运行它们的用户可能没有特定的所需权限。  与在 sudoers 文件中创建条目不同，这必须由 root 完成，任何用户都可以指定为自己的应用程序设置 setuid 或 setgid 标志（即[Linux 和 Mac 文件和目录权限修改](https://attack.mitre.org/techniques/T1222/002)）。可以使用位掩码通过 <code>chmod</code> 命令设置这些位，<code>chmod 4777 [file]</code> 或通过简写命名，<code>chmod u+s [file]</code>。这将启用 setuid 位。要启用 setgid 位，可以使用 <code>chmod 2775</code> 和 <code>chmod g+s</code>。  对手可以在自己的恶意软件上使用此机制，以确保他们能够在未来的提升上下文中执行。(引用: OSX Keydnap malware) 这种滥用通常是“shell 逃逸”或其他绕过具有受限权限的执行环境的操作的一部分。  或者，对手可能会选择查找和目标具有已启用 setuid 或 setgid 位的易受攻击的二进制文件（即[文件和目录发现](https://attack.mitre.org/techniques/T1083)）。通过 <code>ls -l</code> 查看文件属性时，setuid 和 setgid 位用“s”而不是“x”表示。<code>find</code> 命令也可以用于搜索此类文件。例如，<code>find / -perm +4000 2>/dev/null</code> 可用于查找设置了 setuid 的文件，<code>find / -perm +2000 2>/dev/null</code> 可用于查找设置了 setgid 的文件。然后，对手可能会滥用这些位已设置的二进制文件。(引用: GTFOBins Suid) |
| [T1548.002](../techniques/T1548.002.md) | 绕过用户帐户控制 | 对手可能会绕过 UAC 机制以提升系统上的进程权限。Windows 用户帐户控制（UAC）允许程序提升其权限（跟踪为从低到高的完整性级别）以在管理员级别权限下执行任务，可能会提示用户确认。对用户的影响范围从在高强度执行下拒绝操作，到如果用户在本地管理员组中并点击提示或输入管理员密码以完成操作，则允许用户执行操作。(引用: TechNet How UAC Works)  如果计算机的 UAC 保护级别设置为最高级别以外的任何级别，某些 Windows 程序可以提升权限或执行某些提升的[组件对象模型](https://attack.mitre.org/techniques/T1559/001)对象而无需通过 UAC 通知框提示用户。(引用: TechNet Inside UAC)(引用: MSDN COM Elevation) 例如，使用 [Rundll32](https://attack.mitre.org/techniques/T1218/011) 加载特定设计的 DLL，该 DLL 加载自动提升的[组件对象模型](https://attack.mitre.org/techniques/T1559/001)对象并在受保护目录中执行通常需要提升访问权限的文件操作。恶意软件还可能注入到受信任的进程中以获得提升的权限而无需提示用户。(引用: Davidson Windows)  已经发现了许多绕过 UAC 的方法。Github 上的 UACME 说明页面包含了已发现和实现的方法的广泛列表(引用: Github UACMe)，但可能不是绕过方法的全面列表。定期发现其他绕过方法，并且一些方法在野外使用，例如：  * <code>eventvwr.exe</code> 可以自动提升并执行指定的二进制文件或脚本。(引用: enigma0x3 Fileless UAC Bypass)(引用: Fortinet Fareit)  如果已知具有管理员权限的帐户的凭据，则通过某些横向移动技术也可以绕过，因为 UAC 是单一系统安全机制，并且一个系统上运行的进程的权限或完整性在远程系统上未知，默认情况下为高完整性。(引用: SANS UAC Bypass) |
| [T1548.003](../techniques/T1548.003.md) | Sudo 和 Sudo 缓存 | 对手可能会执行 sudo 缓存和/或使用 sudoers 文件来提升权限。对手可能这样做是为了以其他用户身份执行命令或生成具有更高权限的进程。  在 Linux 和 MacOS 系统中，sudo（有时称为“超级用户执行”）允许用户从终端以提升的权限执行命令，并控制谁可以在系统上执行这些命令。<code>sudo</code> 命令“允许系统管理员委派权限，授予某些用户（或用户组）以 root 或其他用户身份运行某些（或所有）命令的能力，同时提供命令及其参数的审计跟踪。”(引用: sudo man page 2018) 由于 sudo 是为系统管理员设计的，因此它具有一些有用的配置功能，例如 <code>timestamp_timeout</code>，这是 <code>sudo</code> 之间的时间间隔，以分钟为单位，然后它会重新提示输入密码。这是因为 <code>sudo</code> 具有缓存凭据的能力。Sudo 会在 <code>/var/db/sudo</code> 处创建（或触摸）一个文件，其中包含上次运行 sudo 的时间戳，以确定此超时。此外，还有一个 <code>tty_tickets</code> 变量，它将每个新的 tty（终端会话）视为隔离的。这意味着，例如，一个 tty 的 sudo 超时不会影响另一个 tty（您将不得不再次输入密码）。  sudoers 文件 <code>/etc/sudoers</code> 描述了哪些用户可以从哪些终端运行哪些命令。这还描述了用户可以以其他用户或组身份运行哪些命令。这提供了最低权限原则，使用户在大多数时间内以最低可能的权限运行，并且仅在需要时通过提示输入密码提升到其他用户或权限。然而，sudoers 文件还可以通过类似 <code>user1 ALL=(ALL) NOPASSWD: ALL</code> 的行指定何时不提示用户输入密码。(引用: OSX.Dok Malware) 但是，编辑此文件需要提升的权限。  对手还可以滥用这些机制的配置不当来提升权限而无需用户的密码。例如，可以监视 <code>/var/db/sudo</code> 的时间戳以查看它是否在 <code>timestamp_timeout</code> 范围内。如果是，则恶意软件可以执行 sudo 命令而无需提供用户的密码。此外，如果禁用 <code>tty_tickets</code>，对手可以从该用户的任何 tty 执行此操作。  在野外，恶意软件已禁用 <code>tty_tickets</code> 以潜在地使脚本编写更容易，通过发出 <code>echo \'Defaults !tty_tickets\' >> /etc/sudoers</code>。(引用: cybereason osx proton) 为了使此更改生效，恶意软件还发出了 <code>killall Terminal</code>。从 macOS Sierra 开始，sudoers 文件默认启用了 <code>tty_tickets</code>。 |
| [T1548.004](../techniques/T1548.004.md) | 带提示的提升执行 | 对手可能利用 <code>AuthorizationExecuteWithPrivileges</code> API 通过提示用户输入凭证来提升权限。(引用: AppleDocs AuthorizationExecuteWithPrivileges) 该 API 的目的是为应用程序开发人员提供一种简单的方法来执行具有 root 权限的操作，例如应用程序安装或更新。此 API 不会验证请求 root 权限的程序是否来自可信来源或是否被恶意修改。  尽管此 API 已被弃用，但在最新版本的 macOS 中仍然完全有效。调用此 API 时，用户将被提示输入其凭证，但不会对程序的来源或完整性进行检查。调用 API 的程序还可以加载可写的文件，这些文件可以被修改以执行具有提升权限的恶意行为。  对手可能会滥用 <code>AuthorizationExecuteWithPrivileges</code> 以获得 root 权限，从而在受害者上安装恶意软件并安装持久性机制。(引用: Death by 1000 installers; it's all broken!)(引用: Carbon Black Shlayer Feb 2019)(引用: OSX Coldroot RAT) 此技术可能与[伪装](https://attack.mitre.org/techniques/T1036)结合使用，以欺骗用户授予恶意代码提升的权限。(引用: Death by 1000 installers; it's all broken!)(引用: Carbon Black Shlayer Feb 2019) 此技术还已被证明可以通过修改机器上使用此 API 的合法程序来工作。(引用: Death by 1000 installers; it's all broken!) |
| [T1548.005](../techniques/T1548.005.md) | 临时提升的云访问 | 对手可能会滥用权限配置，使他们能够获得对云资源的临时提升访问权限。许多云环境允许管理员授予用户或服务帐户请求即时访问角色、模拟其他帐户、将角色传递给资源和服务或以其他方式获得与其自身不同的一组权限的短期访问权限。  即时访问是一种以细粒度、临时方式向云帐户授予额外角色的机制。这允许帐户仅以他们每天需要的权限进行操作，并在必要时请求额外权限。有时即时访问请求被配置为需要手动批准，而其他时候所需的权限会自动授予。(引用: Azure Just in Time Access 2023)  帐户模拟允许用户或服务帐户临时以另一个帐户的权限进行操作。例如，在 GCP 中，具有 `iam.serviceAccountTokenCreator` 角色的用户可以创建临时访问令牌或使用服务帐户的权限签署任意有效负载，而具有域范围委派权限的服务帐户被允许模拟 Google Workspace 帐户。(引用: Google Cloud Service Account Authentication Roles)(引用: Hunters Domain Wide Delegation Google Workspace 2023)(引用: Google Cloud Just in Time Access 2023)(引用: Palo Alto Unit 42 Google Workspace Domain Wide Delegation 2023) 在 Exchange Online 中，`ApplicationImpersonation` 角色允许服务帐户使用与指定用户帐户关联的权限。(引用: Microsoft Impersonation and EWS in Exchange)  许多云环境还包括用户将角色传递给资源的机制，允许他们执行任务并验证其他服务。虽然创建资源的用户不会直接承担他们传递给它的角色，但他们仍然可以利用角色的访问权限——例如，通过配置资源以其被授予的权限执行某些操作。在 AWS 中，具有 `PassRole` 权限的用户可以允许他们创建的服务承担给定角色，而在 GCP 中，具有 `iam.serviceAccountUser` 角色的用户可以将服务帐户附加到资源。(引用: AWS PassRole)(引用: Google Cloud Service Account Authentication Roles)  虽然用户需要特定角色分配才能使用这些功能，但云管理员可能会错误配置权限。这可能导致权限提升路径，使对手能够访问超出最初预期的资源。(引用: Rhino Google Cloud Privilege Escalation)(引用: Rhino Security Labs AWS Privilege Escalation)  **注意：** 这与[额外的云角色](https://attack.mitre.org/techniques/T1098/003)不同，后者涉及为帐户分配永久角色，而不是滥用现有权限结构以获得对资源的临时提升访问权限。然而，妥协了具有足够权限的帐户的对手可能会授予他们控制的另一个帐户[额外的云角色](https://attack.mitre.org/techniques/T1098/003)，这将允许他们也滥用这些功能。这可能比直接使用高度特权帐户更隐蔽，特别是当日志未明确说明何时进行角色模拟时。(引用: CrowdStrike StellarParticle January 2022) |
| [T1548.006](../techniques/T1548.006.md) | TCC操纵 | 攻击者可以操纵或滥用透明度、同意和控制（TCC）服务或数据库，以授予恶意可执行文件提升的权限。TCC是macOS的隐私和安全控制机制，用于确定正在运行的进程是否有权访问受TCC保护的数据或服务，例如屏幕共享、摄像头、麦克风或全磁盘访问（FDA）。  当应用程序请求访问受TCC保护的数据或服务时，TCC守护进程（`tccd`）会检查位于`/Library/Application Support/com.apple.TCC/TCC.db`（和`~/`等效）的TCC数据库，并覆盖文件（如果连接到MDM）以获取现有权限。如果权限不存在，则会提示用户授予权限。一旦授予权限，数据库将存储应用程序的权限，并且除非重置，否则不会再次提示用户。例如，当Web浏览器请求访问用户的网络摄像头时，一旦授予权限，Web浏览器可能不会再次明确提示用户。(引用: welivesecurity TCC)  攻击者可能通过滥用先前通过[进程注入](https://attack.mitre.org/techniques/T1055)授予权限的应用程序或使用另一个应用程序执行恶意二进制文件来访问受TCC保护的受限数据或服务。例如，攻击者可以使用具有FDA权限的macOS本机应用程序Finder来执行恶意的[AppleScript](https://attack.mitre.org/techniques/T1059/002)。当在Finder应用程序下执行时，恶意的[AppleScript](https://attack.mitre.org/techniques/T1059/002)继承了对系统上所有文件的访问权限，而无需用户提示。当系统完整性保护（SIP）被禁用时，TCC保护也被禁用。对于未启用SIP的系统，攻击者可以通过使用环境变量和[Launchctl](https://attack.mitre.org/techniques/T1569/001)加载攻击者控制的TCC数据库来操纵TCC数据库，以向其恶意可执行文件添加权限。(引用: TCC macOS绕过)(引用: TCC数据库) |
| [T1574](../techniques/T1574.md) | 劫持执行流 | 对手可能通过劫持操作系统运行程序的方式来执行他们自己的恶意有效载荷。劫持执行流可以用于持久性，因为这种劫持的执行可能会随着时间的推移而重复发生。对手还可能使用这些机制来提升权限或规避防御，例如应用程序控制或其他执行限制。  对手可能通过多种方式劫持执行流，包括操纵操作系统定位要执行的程序的方式。操作系统定位程序使用的库的方式也可以被拦截。操作系统查找程序/资源的位置，例如文件目录，在Windows中是注册表，也可能被污染以包含恶意有效载荷。 |
| [T1574.001](../techniques/T1574.001.md) | DLL 搜索顺序劫持 | 对手可能通过劫持用于加载 DLL 的搜索顺序来执行他们自己的恶意有效负载。Windows 系统使用一种常见的方法来查找要加载到程序中的所需 DLL。(引用: Microsoft Dynamic Link Library Search Order)(引用: FireEye Hijacking July 2010) 劫持 DLL 加载可能是为了建立持久性以及提升权限和/或规避文件执行限制。  对手可以通过多种方式劫持 DLL 加载。对手可能会在目录中植入特洛伊木马动态链接库文件 (DLL)，该目录将在请求的合法库之前被搜索，从而导致 Windows 在调用受害者程序时加载他们的恶意库。对手还可能通过放置与模糊指定的 DLL 同名的恶意 DLL 在 Windows 搜索合法 DLL 之前的位置来执行 DLL 预加载，也称为二进制植入攻击。(引用: OWASP Binary Planting) 通常这个位置是程序的当前工作目录。(引用: FireEye fxsst June 2011) 远程 DLL 预加载攻击发生在程序将其当前目录设置为远程位置（如 Web 共享）之前加载 DLL。(引用: Microsoft Security Advisory 2269637)  幻影 DLL 劫持是一种特定类型的 DLL 搜索顺序劫持，对手针对对不存在的 DLL 文件的引用。(引用: Hexacorn DLL Hijacking)(引用: Adversaries Hijack DLLs) 他们可能能够通过在缺失模块的位置植入具有正确名称的恶意 DLL 来加载自己的恶意 DLL。  对手还可以通过 DLL 重定向直接修改搜索顺序，启用后（在注册表中并创建重定向文件）可能导致程序加载不同的 DLL。(引用: Microsoft Dynamic-Link Library Redirection)(引用: Microsoft Manifests)(引用: FireEye DLL Search Order Hijacking)  如果配置为以更高权限级别运行的程序易受路径劫持攻击，那么加载的对手控制的 DLL 也将以更高权限级别执行。在这种情况下，该技术可用于从用户到管理员或 SYSTEM 的权限提升，或从管理员到 SYSTEM，具体取决于程序。受路径劫持攻击的程序可能会表现正常，因为恶意 DLL 可能会配置为也加载它们原本要替换的合法 DLL。 |
| [T1574.002](../techniques/T1574.002.md) | DLL侧加载 | 攻击者可能通过侧加载DLL执行其恶意负载。类似于[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)，侧加载涉及劫持程序加载的DLL。但不仅仅是将DLL放置在程序的搜索顺序中然后等待受害者应用程序被调用，攻击者可能通过放置并调用执行其负载的合法应用程序直接侧加载其负载。  侧加载利用加载器使用的DLL搜索顺序，将受害者应用程序和恶意负载并排放置。攻击者可能使用侧加载作为在合法、受信任且可能提升权限的系统或软件进程下掩盖其操作的手段。用于侧加载负载的良性可执行文件在交付和/或执行期间可能不会被标记。攻击者负载在被加载到受信任进程的内存之前也可能被加密/打包或以其他方式混淆。(引用: FireEye DLL侧加载) |
| [T1574.004](../techniques/T1574.004.md) | Dylib劫持 | 对手可能通过在受害者应用程序在运行时搜索的路径中放置具有预期名称的恶意动态库（dylib）来执行其负载。动态加载器将根据搜索路径的顺序尝试查找dylib。dylib的路径可能以<code>@rpath</code>为前缀，这允许开发人员使用相对路径在运行时根据可执行文件的位置指定一组搜索路径。此外，如果使用弱链接，例如<code>LC_LOAD_WEAK_DYLIB</code>函数，即使预期的dylib不存在，应用程序仍将执行。弱链接使开发人员能够在添加新API的多个macOS版本上运行应用程序。  对手可能通过在识别的路径中插入具有缺失dylib名称的恶意dylib来获得执行。(引用: Wardle Dylib Hijack Vulnerable Apps)(引用: Wardle Dylib Hijacking OSX 2015)(引用: Github EmpireProject HijackScanner)(引用: Github EmpireProject CreateHijacker Dylib) dylib被加载到应用程序的地址空间中，允许恶意dylib继承应用程序的权限级别和资源。根据应用程序的不同，这可能导致权限提升和不受限制的网络访问。由于执行被掩盖在合法进程下，此方法还可能逃避安全产品的检测。(引用: Writing Bad Malware for OSX)(引用: wardle artofmalware volume1)(引用: MalwareUnicorn macOS Dylib Injection MachO) |
| [T1574.005](../techniques/T1574.005.md) | 可执行安装文件权限弱点 | 对手可能通过劫持安装程序使用的二进制文件来执行他们自己的恶意负载。这些进程可能会自动执行特定的二进制文件，作为其功能的一部分或执行其他操作。如果包含目标二进制文件的文件系统目录或二进制文件本身的权限设置不正确，则可以使用用户级权限覆盖目标二进制文件，并由原始进程执行。如果原始进程和线程在更高权限级别下运行，则替换的二进制文件也将在更高权限级别下执行，这可能包括 SYSTEM。  此技术的另一种变体可以通过利用可执行自解压安装程序中常见的弱点来执行。在安装过程中，安装程序通常使用<code>%TEMP%</code>目录中的子目录来解压缩 DLL、EXE 或其他负载等二进制文件。当安装程序创建子目录和文件时，它们通常不会设置适当的权限来限制写访问，这允许在子目录中执行不受信任的代码或覆盖安装过程中使用的二进制文件。这种行为与[DLL 搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)有关，并可能利用其优势。  对手可能会使用此技术替换合法的二进制文件，以更高权限级别执行代码。一些安装程序还可能需要提升权限，这将在执行对手控制的代码时导致权限提升。这种行为与[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)有关。已经向软件供应商报告了几个现有常见安装程序中此弱点的示例。(引用: mozilla_sec_adv_2012)(引用: Executable Installers are Vulnerable) 如果执行进程设置为在特定时间或某个事件（例如系统启动）期间运行，则此技术还可用于持久性。 |
| [T1574.006](../techniques/T1574.006.md) | 动态链接器劫持 | 对手可能通过劫持动态链接器用于加载共享库的环境变量来执行他们自己的恶意负载。在程序的执行准备阶段，动态链接器从环境变量和文件（如 Linux 上的 <code>LD_PRELOAD</code> 或 macOS 上的 <code>DYLD_INSERT_LIBRARIES</code>）加载指定的共享库的绝对路径。环境变量中指定的库首先加载，优先于具有相同函数名称的系统库。（引用：Man LD.SO）（引用：TLDP 共享库）（引用：Apple Doco Archive 动态库）这些变量通常由开发人员用于调试二进制文件而无需重新编译、解决映射符号冲突以及在不更改原始库的情况下实现自定义函数。（引用：Baeldung LD_PRELOAD）  在 Linux 和 macOS 上，劫持动态链接器变量可能会授予对受害者进程内存、系统/网络资源的访问权限，并可能提升权限。此方法还可能规避安全产品的检测，因为执行被掩盖在合法进程下。对手可以使用 <code>export</code> 命令、<code>setenv</code> 函数或 <code>putenv</code> 函数通过命令行设置环境变量。对手还可以利用 [动态链接器劫持](https://attack.mitre.org/techniques/T1574/006) 在 shell 中导出变量或使用更高级别的语法（如 Python 的 <code>os.environ</code>）以编程方式设置变量。  在 Linux 上，对手可能会设置 <code>LD_PRELOAD</code> 以指向与受害者程序请求的合法库名称匹配的恶意库，从而导致操作系统在执行受害者程序时加载对手的恶意代码。<code>LD_PRELOAD</code> 可以通过环境变量或 <code>/etc/ld.so.preload</code> 文件设置。（引用：Man LD.SO）（引用：TLDP 共享库）由 <code>LD_PRELOAD</code> 指定的库由 <code>dlopen()</code> 和 <code>mmap()</code> 分别加载和映射到内存中。（引用：Linux 和 macOS 上的代码注入）（引用：Uninformed Needle）（引用：Phrack halfdead 1997）（引用：Brown Exploiting Linkers）  在 macOS 上，此行为在概念上与 Linux 上相同，只是在较低级别上实现 macOS 动态库（dyld）有所不同。对手可以设置 <code>DYLD_INSERT_LIBRARIES</code> 环境变量以指向包含受害者程序请求的合法库或函数名称的恶意库。（引用：TheEvilBit DYLD_INSERT_LIBRARIES）（引用：Timac DYLD_INSERT_LIBRARIES）（引用：Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass） |
| [T1574.007](../techniques/T1574.007.md) | 通过PATH环境变量进行路径拦截 | 对手可能通过劫持用于加载库的环境变量来执行自己的恶意有效负载。PATH环境变量包含一个目录列表（用户和系统），操作系统按顺序搜索这些目录以查找从脚本或命令行调用的二进制文件。  对手可以将恶意程序放置在PATH环境变量列表中较早的条目中，从而导致操作系统在按顺序搜索该PATH列表时执行恶意二进制文件而不是合法二进制文件。  例如，在Windows上，如果对手将名为“net.exe”的恶意程序放置在`C:\example path`中，该路径默认情况下优先于`C:\Windows\system32\net.exe`在PATH环境变量中，当从命令行执行“net”时，将调用`C:\example path`而不是系统的合法可执行文件`C:\Windows\system32\net.exe`。某些执行程序的方法依赖于PATH环境变量来确定在未给出程序路径时要搜索的位置，例如从[命令和脚本解释器](https://attack.mitre.org/techniques/T1059)执行程序。(引用: ExpressVPN PATH env Windows 2021)  对手还可以直接修改指定要搜索目录的$PATH变量。对手可以修改$PATH变量以指向他们有写访问权限的目录。当调用使用$PATH变量的程序时，操作系统将搜索指定目录并执行恶意二进制文件。在macOS上，这也可以通过修改$HOME变量来执行。这些变量可以使用命令行、launchctl、[Unix Shell配置修改](https://attack.mitre.org/techniques/T1546/004)或修改`/etc/paths.d`文件夹内容来修改。(引用: uptycs Fake POC linux malware 2023)(引用: nixCraft macOS PATH variables)(引用: Elastic Rules macOS launchctl 2022) |
| [T1574.008](../techniques/T1574.008.md) | 通过搜索顺序劫持进行路径拦截 | 对手可能通过劫持用于加载其他程序的搜索顺序来执行他们自己的恶意有效负载。由于某些程序在调用其他程序时不使用完整路径，对手可能会将他们自己的文件放置在调用程序所在的目录中，从而导致操作系统在调用程序的请求下启动他们的恶意软件。  搜索顺序劫持发生在对手滥用Windows搜索未指定路径的程序的顺序时。与[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)不同，搜索顺序因执行程序的方法而异。(引用: Microsoft CreateProcess) (引用: Windows NT Command Shell) (引用: Microsoft WinExec) 然而，Windows通常会在搜索Windows系统目录之前搜索启动程序的目录。发现易受搜索顺序劫持（即未指定可执行文件路径）的程序的对手可能会通过在启动程序的目录中创建一个命名为不正确指定程序的程序来利用此漏洞。  例如，“example.exe”运行“cmd.exe”并带有命令行参数<code>net user</code>。对手可能会在example.exe所在的目录中放置一个名为“net.exe”的程序，“net.exe”将被运行而不是Windows系统实用程序net。此外，如果对手在与“net.exe”相同的目录中放置一个名为“net.com”的程序，那么<code>cmd.exe /C net user</code>将执行“net.com”而不是“net.exe”，因为在PATHEXT下定义的可执行文件扩展名顺序。(引用: Microsoft Environment Property)  搜索顺序劫持也是劫持DLL加载的常见做法，并在[DLL搜索顺序劫持](https://attack.mitre.org/techniques/T1574/001)中进行了介绍。 |
| [T1574.009](../techniques/T1574.009.md) | 通过未加引号的路径进行路径拦截 | 对手可能通过劫持易受攻击的文件路径引用来执行他们自己的恶意有效载荷。对手可以利用缺乏引号的路径，通过在路径中的更高级目录中放置可执行文件，使Windows选择对手的可执行文件来启动。  如果路径中有一个或多个空格且未加引号（例如<code>C:\unsafe path with space\program.exe</code>与<code>"C:\safe path with space\program.exe"</code>），服务路径(引用: Microsoft CurrentControlSet Services)和快捷方式路径也可能容易受到路径拦截的攻击。(引用: Help eliminate unquoted path)（存储在Windows注册表键中）对手可以在路径的更高级目录中放置一个可执行文件，Windows将解析该可执行文件而不是预期的可执行文件。例如，如果快捷方式中的路径是<code>C:\program files\myapp.exe</code>，对手可能会在<code>C:\program.exe</code>创建一个程序，该程序将被运行而不是预期的程序。(引用: Windows Unquoted Services)(引用: Windows Privilege Escalation Guide)  如果可执行文件被定期调用，此技术可以用于持久性，如果被拦截的可执行文件由更高权限的进程启动，则可以用于权限提升。 |
| [T1574.010](../techniques/T1574.010.md) | 服务文件权限弱点 | 对手可能通过劫持服务使用的二进制文件来执行他们自己的恶意有效载荷。对手可能利用Windows服务权限中的漏洞来替换服务启动时执行的二进制文件。这些服务进程可能会自动执行特定的二进制文件，作为其功能的一部分或执行其他操作。如果包含目标二进制文件的文件系统目录或二进制文件本身的权限设置不正确，则可以使用用户级权限覆盖目标二进制文件，并由原始进程执行。如果原始进程和线程在更高权限级别下运行，则替换的二进制文件也将在更高权限级别下执行，这可能包括SYSTEM。  对手可能使用此技术替换合法二进制文件为恶意二进制文件，以便在更高权限级别下执行代码。如果执行进程设置为在特定时间或某个事件（例如系统启动）期间运行，则此技术也可用于持久性。 |
| [T1574.011](../techniques/T1574.011.md) | 服务注册表权限弱点 | 对手可能通过劫持服务使用的注册表项来执行他们自己的恶意有效负载。对手可能会利用服务注册表项权限中的漏洞，将原本指定的可执行文件重定向到他们控制的文件，以便在服务启动时启动他们自己的代码。Windows 在 <code>HKLM\SYSTEM\CurrentControlSet\Services</code> 下的注册表中存储本地服务配置信息。可以通过服务控制器、sc.exe、[PowerShell](https://attack.mitre.org/techniques/T1059/001) 或 [Reg](https://attack.mitre.org/software/S0075) 等工具操作存储在服务注册表项下的信息。对注册表项的访问通过访问控制列表和用户权限进行控制。(引用: Registry Key Security)(引用: malware_hides_service)  如果用户和组的权限设置不正确，并允许访问服务的注册表项，对手可能会更改服务的 binPath/ImagePath 以指向他们控制的不同可执行文件。当服务启动或重新启动时，对手控制的程序将执行，允许对手在服务设置为执行的帐户上下文（本地/域帐户、SYSTEM、LocalService 或 NetworkService）中建立持久性和/或提升权限。  对手还可能更改服务注册表树中的其他注册表项。例如，可以更改 <code>FailureCommand</code> 键，以便在服务失败或故意损坏时在提升的上下文中执行服务。(引用: Kansa Service related collectors)(引用: Tweet Registry Perms Weakness)  <code>Performance</code> 键包含驱动程序服务性能 DLL 的名称和 DLL 中几个导出函数的名称。(引用: microsoft_services_registry_tree) 如果 <code>Performance</code> 键尚不存在，并且对手控制的用户具有 <code>Create Subkey</code> 权限，对手可能会在服务的注册表树中创建 <code>Performance</code> 键以指向恶意 DLL。(引用: insecure_reg_perms)  对手还可能添加 <code>Parameters</code> 键，该键存储驱动程序特定数据，或其他自定义子键以建立持久性或启用其他恶意活动。(引用: microsoft_services_registry_tree)(引用: troj_zegost) 此外，如果对手使用 svchost.exe 启动他们的恶意服务，可以使用 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\servicename\Parameters\ServiceDll</code> 标识服务的文件。(引用: malware_hides_service) |
| [T1574.012](../techniques/T1574.012.md) | COR_PROFILER | 对手可能利用COR_PROFILER环境变量劫持加载.NET CLR的程序的执行流。COR_PROFILER是一个.NET框架功能，允许开发人员指定一个非托管（或.NET外部）分析DLL加载到每个加载公共语言运行时（CLR）的.NET进程中。这些分析器旨在监视、排除故障和调试由.NET CLR执行的托管代码。(引用: Microsoft Profiling Mar 2017)(引用: Microsoft COR_PROFILER Feb 2013)  COR_PROFILER环境变量可以在各种范围内设置（系统、用户或进程），导致不同级别的影响。系统和用户范围的环境变量范围在注册表中指定，其中可以将[组件对象模型](https://attack.mitre.org/techniques/T1559/001)（COM）对象注册为分析DLL。还可以在内存中创建进程范围的COR_PROFILER，而无需修改注册表。从.NET框架4开始，只要在COR_PROFILER_PATH环境变量中指定DLL的位置，就不需要注册分析DLL。(引用: Microsoft COR_PROFILER Feb 2013)  对手可能滥用COR_PROFILER建立持久性，每次调用CLR时在所有.NET进程的上下文中执行恶意DLL。如果受害者.NET进程以更高权限级别执行，COR_PROFILER还可以用于提升权限（例如[绕过用户帐户控制](https://attack.mitre.org/techniques/T1548/002)），以及挂钩和[削弱防御](https://attack.mitre.org/techniques/T1562)由.NET进程提供。(引用: RedCanary Mockingbird May 2020)(引用: Red Canary COR_PROFILER May 2020)(引用: Almond COR_PROFILER Apr 2019)(引用: GitHub OmerYa Invisi-Shell)(引用: subTee .NET Profilers May 2017) |
| [T1574.013](../techniques/T1574.013.md) | KernelCallbackTable | 对手可能滥用进程的<code>KernelCallbackTable</code>来劫持其执行流以运行自己的有效载荷。(引用: Lazarus APT January 2022)(引用: FinFisher exposed) <code>KernelCallbackTable</code>可以在进程环境块（PEB）中找到，并在加载<code>user32.dll</code>后初始化为GUI进程可用的图形函数数组。(引用: Windows Process Injection KernelCallbackTable)  对手可能通过替换原始回调函数为恶意有效载荷来劫持进程的执行流。修改回调函数可以通过涉及相关行为的各种方式实现，例如[反射代码加载](https://attack.mitre.org/techniques/T1620)或[进程注入](https://attack.mitre.org/techniques/T1055)到另一个进程中。  可以通过定位PEB（例如，通过调用<code>NtQueryInformationProcess()</code> [本机API](https://attack.mitre.org/techniques/T1106)函数）获得指向<code>KernelCallbackTable</code>内存地址的指针。(引用: NtQueryInformationProcess) 一旦找到指针，可以复制<code>KernelCallbackTable</code>，并将表中的函数（例如<code>fnCOPYDATA</code>）设置为恶意有效载荷的地址（例如通过<code>WriteProcessMemory()</code>）。然后更新PEB以包含新表的地址。一旦调用篡改的函数，恶意有效载荷将被触发。(引用: Lazarus APT January 2022)  篡改的函数通常使用Windows消息调用。在劫持进程并执行恶意代码后，<code>KernelCallbackTable</code>也可能由恶意有效载荷的其余部分恢复到其原始状态。(引用: Lazarus APT January 2022) 使用<code>KernelCallbackTable</code>劫持执行流可能会规避安全产品的检测，因为执行可以掩盖在合法进程下。 |
| [T1574.014](../techniques/T1574.014.md) | AppDomainManager | 对手可能通过劫持 .NET `AppDomainManager` 加载程序集的方式来执行他们自己的恶意有效负载。 .NET 框架使用 `AppDomainManager` 类在进程内创建和管理一个或多个隔离的运行时环境（称为应用程序域）以托管 .NET 应用程序的执行。程序集（编译为运行 .NET 代码的 `.exe` 或 `.dll` 二进制文件）可以作为可执行代码加载到应用程序域中。(引用: Microsoft App Domains)  称为“AppDomainManager 注入”，对手可能通过劫持 .NET 应用程序加载程序集的方式来执行任意代码。例如，恶意软件可能在目标进程内创建一个自定义应用程序域以加载和执行任意程序集。或者，可以篡改定义 .NET 运行时设置的配置文件（`.config`）或进程环境变量，以指示原本无害的 .NET 应用程序将恶意程序集（按名称标识）加载到目标进程中。(引用: PenTestLabs AppDomainManagerInject)(引用: PwC Yellow Liderc)(引用: Rapid7 AppDomain Manager Injection) |
| [T1586.003](../techniques/T1586.003.md) | 云账户 | 云环境中的有效账户可能允许对手执行操作以实现初始访问、持久性、权限提升或防御规避。云账户是由组织创建和配置的账户，供用户、远程支持、服务或管理云服务提供商或SaaS应用程序中的资源使用。云账户可以仅存在于云中；或者，它们可能通过与其他身份源（例如Windows Active Directory）的同步或联合在本地系统和云之间混合连接。(引用: AWS Identity Federation)(引用: Google Federating GC)(引用: Microsoft Deploying AD Federation)  服务或用户账户可能通过[暴力破解](https://attack.mitre.org/techniques/T1110)、[网络钓鱼](https://attack.mitre.org/techniques/T1566)或各种其他手段成为对手的目标，以获得对环境的访问权限。联合或同步账户可能是对手影响本地系统和云环境的途径——例如，通过利用共享凭据登录到[远程服务](https://attack.mitre.org/techniques/T1021)。高权限云账户，无论是联合、同步还是仅云账户，也可能允许通过SaaS [软件部署工具](https://attack.mitre.org/techniques/T1072)在混合连接设备上运行命令，从而转移到本地环境。  对手可能会在被破坏的云账户上创建长期的[附加云凭据](https://attack.mitre.org/techniques/T1098/001)，以在环境中保持持久性。这些凭据还可以用于绕过多因素身份验证等安全控制。  云账户还可能能够通过环境中的各种手段获得[临时提升的云访问权限](https://attack.mitre.org/techniques/T1548/005)或其他权限。角色分配或角色假设策略中的配置错误可能允许对手使用这些机制来利用超出账户预期范围的权限。这些超权限账户可能用于通过[云API](https://attack.mitre.org/techniques/T1059/009)或其他方法从在线存储账户和数据库中收集敏感数据。  |
| [T1611](../techniques/T1611.md) | 逃逸到主机 | 对手可能会突破容器以访问底层主机。这可以使对手从主机级别访问其他容器化资源或访问主机本身。原则上，容器化资源应提供应用程序功能的明确分离，并与主机环境隔离。(引用: Docker Overview)  对手可能通过多种方式逃逸到主机环境。例如，创建一个配置为使用绑定参数挂载主机文件系统的容器，这允许对手在主机上放置有效负载并执行控制实用程序，例如 cron；利用特权容器在底层主机上运行命令或加载恶意内核模块；或滥用系统调用，例如 `unshare` 和 `keyctl` 以提升权限并窃取秘密。(引用: Docker Bind Mounts)(引用: Trend Micro Privileged Container)(引用: Intezer Doki July 20)(引用: Container Escape)(引用: Crowdstrike Kubernetes Container Escape)(引用: Keyctl-unmask)  此外，对手可能能够利用挂载的容器管理套接字（例如 `docker.sock`）的受损容器，通过[容器管理命令](https://attack.mitre.org/techniques/T1609)突破容器。(引用: Container Escape) 对手还可能通过[特权提升利用](https://attack.mitre.org/techniques/T1068)逃逸，例如利用全局符号链接中的漏洞以访问主机机器的根目录。(引用: Windows Server Containers Are Open)  访问主机可能为对手提供实现后续目标的机会，例如建立持久性、在环境中横向移动、访问主机上运行的其他容器或在主机上设置命令和控制通道。 |
